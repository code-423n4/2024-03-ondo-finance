{
  "language": "Solidity",
  "sources": {
    "contracts/RWAHubNonStableInstantMints.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\n\npragma solidity 0.8.16;\n\nimport \"contracts/RWAHubOffChainRedemptions.sol\";\nimport \"contracts/InstantMintTimeBasedRateLimiter.sol\";\nimport \"contracts/interfaces/IRWAHubNonStableInstantMint.sol\";\n\nabstract contract RWAHubNonStableInstantMints is\n  RWAHubOffChainRedemptions,\n  InstantMintTimeBasedRateLimiter,\n  IRWAHubNonStableInstantMint\n{\n  using SafeERC20 for IERC20;\n\n  // Fee collected when instant minting RWA-nonStable (in basis points)\n  uint256 public instantMintFee = 10;\n\n  // The % (in bps) of rwa to instantly give to the user\n  uint256 public instantMintAmountBps = 9_000;\n\n  // Flag whether instantMint is paused\n  bool public instantMintPaused = true;\n  bool public claimExcessPaused = true;\n\n  // Address to manage instant mints/redeems\n  address public instantMintAssetManager;\n\n  // Mapping used to store the instantMint amount for a given deposit Id\n  mapping(bytes32 => uint256) public depositIdToInstantMintAmount;\n\n  constructor(\n    address _collateral,\n    address _rwa,\n    address managerAdmin,\n    address pauser,\n    address _assetSender,\n    address _feeRecipient,\n    uint256 _minimumDepositAmount,\n    uint256 _minimumRedemptionAmount,\n    address _instantMintAssetManager\n  )\n    RWAHubOffChainRedemptions(\n      _collateral,\n      _rwa,\n      managerAdmin,\n      pauser,\n      _assetSender,\n      _feeRecipient,\n      _minimumDepositAmount,\n      _minimumRedemptionAmount\n    )\n    InstantMintTimeBasedRateLimiter(0, 0, 0, 0)\n  {\n    instantMintAssetManager = _instantMintAssetManager;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                     Instant Mint Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Function to allow for investors to instantly mint a fraction of\n   *         their total deposited amount.\n   *\n   * @param amount The amount of collateral to `instantMint`\n   *\n   *\n   * @dev The daily ∆ price for the rwa Asset must not exceed:\n   *      10_000 - `instantMintAmountBps`\n   *      eg: 10_000 - 9_000 -> 1_000 (in bps) -> 10% ∆ in price\n   *      If this condition is violated there will be problems!\n   */\n  function instantMint(\n    uint256 amount\n  )\n    external\n    nonReentrant\n    ifNotPaused(instantMintPaused)\n    checkRestrictions(msg.sender)\n  {\n    if (amount < minimumDepositAmount) {\n      revert DepositTooSmall();\n    }\n\n    // Calculate fees\n    uint256 instantMintFeesInCollateral = _getInstantMintFees(amount);\n    uint256 depositAmountAfterFees = amount - instantMintFeesInCollateral;\n\n    // Transfer collateral\n    collateral.safeTransferFrom(msg.sender, instantMintAssetManager, amount);\n\n    // Calculate mint amount\n    uint256 price = pricer.getLatestPrice();\n    uint256 rwaGiven = _getInstantMintAmount(depositAmountAfterFees, price);\n\n    // Check mint limit\n    _checkAndUpdateInstantMintLimit(rwaGiven);\n\n    bytes32 depositId = bytes32(subscriptionRequestCounter++);\n    depositIdToDepositor[depositId] = Depositor(\n      msg.sender,\n      depositAmountAfterFees,\n      0\n    );\n\n    depositIdToInstantMintAmount[depositId] = rwaGiven;\n\n    rwa.mint(msg.sender, rwaGiven);\n\n    emit InstantMint(\n      msg.sender,\n      amount,\n      depositAmountAfterFees,\n      instantMintFeesInCollateral,\n      rwaGiven,\n      price,\n      depositId\n    );\n  }\n\n  /**\n   * @notice Function for users to claim their remain excess after their priceId\n   *         has been set.\n   *\n   * @param instantMintIds The DepositIds corresponding to instant mint\n   *                       requests\n   *\n   * @dev Function will revert if a deposit Id was not generated through\n   *      `instantMint`\n   */\n  function claimExcess(\n    bytes32[] calldata instantMintIds\n  )\n    external\n    nonReentrant\n    ifNotPaused(claimExcessPaused)\n    checkRestrictions(msg.sender)\n  {\n    uint256 excessSize = instantMintIds.length;\n    for (uint256 i; i < excessSize; ++i) {\n      _claimExcess(instantMintIds[i]);\n    }\n  }\n\n  /**\n   * @notice Internal function used to claim excess for a given depositId\n   *\n   * @param instantMintId The depositId correspond to an instant mint\n   *                      request\n   */\n  function _claimExcess(bytes32 instantMintId) internal virtual {\n    // Get depositor info and instant mint amount\n    Depositor memory depositor = depositIdToDepositor[instantMintId];\n    uint256 rwaGiven = depositIdToInstantMintAmount[instantMintId];\n\n    if (depositor.priceId == 0) {\n      revert PriceIdNotSet();\n    }\n    if (rwaGiven == 0) {\n      revert CannotClaimExcess();\n    }\n\n    // Get price and rwaOwed\n    uint256 price = pricer.getPrice(depositor.priceId);\n    uint256 rwaOwed = _getMintAmountForPrice(\n      depositor.amountDepositedMinusFees,\n      price\n    );\n\n    uint256 rwaDue = rwaOwed - rwaGiven;\n\n    delete depositIdToDepositor[instantMintId];\n    delete depositIdToInstantMintAmount[instantMintId];\n\n    rwa.mint(depositor.user, rwaDue);\n\n    emit ExcessMintClaimed(\n      depositor.user,\n      rwaOwed,\n      rwaDue,\n      depositor.amountDepositedMinusFees,\n      price,\n      instantMintId\n    );\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                 Override base for new accounting\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Overriden function from rwaHub, checks that a depositId does not\n   *         correspond to an instant mint\n   *\n   * @param depositIds Array for depositIds to claim\n   */\n  function claimMint(\n    bytes32[] calldata depositIds\n  ) external override nonReentrant ifNotPaused(subscriptionPaused) {\n    uint256 depositsSize = depositIds.length;\n    for (uint256 i; i < depositsSize; ++i) {\n      if (depositIdToInstantMintAmount[depositIds[i]] != 0) {\n        revert CannotClaimMint();\n      }\n      _claimMint(depositIds[i]);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        Pause Utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Guarded function to pause instant mints\n   */\n  function pauseInstantMint() external onlyRole(PAUSER_ADMIN) {\n    instantMintPaused = true;\n    emit InstantMintPaused(msg.sender);\n  }\n\n  /**\n   * @notice Guarded function to unpause instant mints\n   */\n  function unpauseInstantMint() external onlyRole(MANAGER_ADMIN) {\n    instantMintPaused = false;\n    emit InstantMintUnpaused(msg.sender);\n  }\n\n  /**\n   * @notice Guarded function to pause claims of excess resulting from\n   *         instant mints\n   */\n  function pauseClaimExcess() external onlyRole(PAUSER_ADMIN) {\n    claimExcessPaused = true;\n    emit ClaimExcessPaused(msg.sender);\n  }\n\n  /**\n   * @notice Gurarded function to unpause claims of excess resulting from\n   *         instant mints\n   */\n  function unpauseClaimExcess() external onlyRole(MANAGER_ADMIN) {\n    claimExcessPaused = false;\n    emit ClaimExcessUnpaused(msg.sender);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      Rate limiting utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Set the mintLimit constraint inside the TimeBasedRateLimiter\n   *         base contract\n   *\n   * @param newMintLimit New limit that dictates how much RWA can be minted\n   *                     in a specified duration\n   *                     (in 18 decimals per the RWA contract)\n   */\n  function setInstantMintLimit(\n    uint256 newMintLimit\n  ) external onlyRole(MANAGER_ADMIN) {\n    _setInstantMintLimit(newMintLimit);\n  }\n\n  /**\n   * @notice Sets mintLimitDuration constraint inside the TimeBasedRateLimiter\n   *         base contract\n   *\n   * @param newMintLimitDuration New limit that specifies the interval\n   *                             (in seconds) in which only mintLimit RWA\n   *                             can be minted within\n   */\n  function setInstantMintLimitDuration(\n    uint256 newMintLimitDuration\n  ) external onlyRole(MANAGER_ADMIN) {\n    _setInstantMintLimitDuration(newMintLimitDuration);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                           Admin Utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Admin function to overwrite entries in the `depositIdToInstantMintAmount`\n   *         mapping\n   *\n   * @param depositId   The depositId of the entry we wish to overwrite\n   * @param amountGiven The new amount of rwa instantly minted\n   */\n  function overwriteInstantMintAmountGiven(\n    bytes32 depositId,\n    uint256 amountGiven\n  ) external onlyRole(MANAGER_ADMIN) {\n    uint256 oldGiven = depositIdToInstantMintAmount[depositId];\n    depositIdToInstantMintAmount[depositId] = amountGiven;\n    emit InstantMintGivenOverriden(depositId, oldGiven, amountGiven);\n  }\n\n  /**\n   * @notice Guarded function to set the `instantMintAssetManager`\n   *\n   * @param _instantMintAssetManager The address to update\n   *                                 `instantMintAssetManager` to\n   */\n  function setInstantMintAssetManager(\n    address _instantMintAssetManager\n  ) external onlyRole(MANAGER_ADMIN) {\n    address oldInstantMintAssetManager = instantMintAssetManager;\n    instantMintAssetManager = _instantMintAssetManager;\n    emit InstantMintAssetManagerSet(\n      oldInstantMintAssetManager,\n      instantMintAssetManager\n    );\n  }\n\n  /**\n   * @notice Sets the instant mint fee\n   *\n   * @param _instantMintFee new mint fee specified in basis points\n   *\n   * @dev `_instantMintFee` must not exceed 100% (or 10_000 bps)\n   */\n  function setInstantMintFee(\n    uint256 _instantMintFee\n  ) external onlyRole(MANAGER_ADMIN) {\n    if (_instantMintFee > BPS_DENOMINATOR) {\n      revert FeeTooLarge();\n    }\n    uint256 oldInstantMintFee = instantMintFee;\n    instantMintFee = _instantMintFee;\n    emit InstantMintFeeSet(oldInstantMintFee, _instantMintFee);\n  }\n\n  /**\n   * @notice Sets the % (in bps) for the portion of a deposit amount\n   *         that is to be instantly minted\n   *\n   * @dev This value really should not be above 90% -> 9_000 bps\n   */\n  function setInstantMintAmount(\n    uint256 bpsToInstantMint\n  ) external onlyRole(MANAGER_ADMIN) {\n    if (bpsToInstantMint > BPS_DENOMINATOR) {\n      revert FeeTooLarge();\n    }\n    uint256 oldInstantMintAmt = instantMintAmountBps;\n    instantMintAmountBps = bpsToInstantMint;\n    emit InstantMintAmountSet(oldInstantMintAmt, instantMintAmountBps);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        Calculation utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Internal function to get the fees corresponding to\n   *          instantly minting\n   */\n  function _getInstantMintFees(\n    uint256 collateralAmount\n  ) internal view returns (uint256) {\n    return (collateralAmount * instantMintFee) / BPS_DENOMINATOR;\n  }\n\n  /**\n   * @notice Internal function to calculate the amount due given the latest price\n   *         and the `instantMintAmountBps` (Fraction of deposits to instantly mint)\n   */\n  function _getInstantMintAmount(\n    uint256 collateralAmountIn,\n    uint256 price\n  ) internal view returns (uint256 rwaInstantMint) {\n    uint256 amountE36 = _scaleUp(collateralAmountIn) * 1e18;\n    uint256 rwaOwedLatestRate = amountE36 / price;\n    rwaInstantMint =\n      (rwaOwedLatestRate * instantMintAmountBps) /\n      BPS_DENOMINATOR;\n  }\n}\n"
    },
    "contracts/RWAHubOffChainRedemptions.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\n\npragma solidity 0.8.16;\n\nimport \"contracts/RWAHub.sol\";\nimport \"contracts/interfaces/IRWAHubOffChainRedemptions.sol\";\n\nabstract contract RWAHubOffChainRedemptions is\n  RWAHub,\n  IRWAHubOffChainRedemptions\n{\n  // To enable and disable off chain redemptions\n  bool public offChainRedemptionPaused;\n\n  // Minimum off chain redemption amount\n  uint256 public minimumOffChainRedemptionAmount;\n\n  constructor(\n    address _collateral,\n    address _rwa,\n    address managerAdmin,\n    address pauser,\n    address _assetSender,\n    address _feeRecipient,\n    uint256 _minimumDepositAmount,\n    uint256 _minimumRedemptionAmount\n  )\n    RWAHub(\n      _collateral,\n      _rwa,\n      managerAdmin,\n      pauser,\n      _assetSender,\n      _feeRecipient,\n      _minimumDepositAmount,\n      _minimumRedemptionAmount\n    )\n  {\n    // Default to the same minimum redemption amount as for On-Chain\n    // redemptions.\n    minimumOffChainRedemptionAmount = _minimumRedemptionAmount;\n  }\n\n  /**\n   * @notice Request a redemption to be serviced off chain.\n   *\n   * @param amountRWATokenToRedeem The requested redemption amount\n   * @param offChainDestination    A hash of the destination to which\n   *                               the request should be serviced to.\n   */\n  function requestRedemptionServicedOffchain(\n    uint256 amountRWATokenToRedeem,\n    bytes32 offChainDestination\n  ) external nonReentrant ifNotPaused(offChainRedemptionPaused) {\n    if (amountRWATokenToRedeem < minimumOffChainRedemptionAmount) {\n      revert RedemptionTooSmall();\n    }\n\n    bytes32 redemptionId = bytes32(redemptionRequestCounter++);\n\n    rwa.burnFrom(msg.sender, amountRWATokenToRedeem);\n\n    emit RedemptionRequestedServicedOffChain(\n      msg.sender,\n      redemptionId,\n      amountRWATokenToRedeem,\n      offChainDestination\n    );\n  }\n\n  /**\n   * @notice Function to pause off chain redemptoins\n   */\n  function pauseOffChainRedemption() external onlyRole(PAUSER_ADMIN) {\n    offChainRedemptionPaused = true;\n    emit OffChainRedemptionPaused(msg.sender);\n  }\n\n  /**\n   * @notice Function to unpause off chain redemptoins\n   */\n  function unpauseOffChainRedemption() external onlyRole(MANAGER_ADMIN) {\n    offChainRedemptionPaused = false;\n    emit OffChainRedemptionUnpaused(msg.sender);\n  }\n\n  /**\n   * @notice Admin Function to set the minimum off chain redemption amount\n   *\n   * @param _minimumOffChainRedemptionAmount The new minimum off chain\n   *                                         redemption amount\n   */\n  function setOffChainRedemptionMinimum(\n    uint256 _minimumOffChainRedemptionAmount\n  ) external onlyRole(MANAGER_ADMIN) {\n    uint256 oldMinimum = minimumOffChainRedemptionAmount;\n    minimumOffChainRedemptionAmount = _minimumOffChainRedemptionAmount;\n    emit OffChainRedemptionMinimumSet(\n      oldMinimum,\n      _minimumOffChainRedemptionAmount\n    );\n  }\n}\n"
    },
    "contracts/InstantMintTimeBasedRateLimiter.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\n/**\n * @title InstantMintTimeBasedRateLimiter\n *\n * @notice This abstract contract implements two rate limiters: one for minting\n *         and one for redeeming. Each limit is completely independent: mints\n *         and redemption don't offset each other. Each limit is associated\n *         with a duration, after which the tracked amount is reset. The\n *         amounts tracked are agnostic to a specific token; the usage is\n *         determined by the inheriting contracts.\n *\n * @dev Although this contract has all of its functions implemented, this\n *      contract is marked abstract to prevent an accidental deployment and to\n *      signify that we would never deploy this contract standalone.\n *\n */\nabstract contract InstantMintTimeBasedRateLimiter {\n  // `currentInstantMintAmount` resets after this interval (in seconds)\n  uint256 public resetInstantMintDuration;\n  // timestamp when `currentInstantMintAmount` was last reset\n  uint256 public lastResetInstantMintTime;\n\n  // maximum amount that can be minted during a `resetInstantMintDuration` window\n  uint256 public instantMintLimit;\n  // amount already minted during the current `resetInstantMintDuration` window\n  uint256 public currentInstantMintAmount;\n\n  // `currentInstantRedemptionAmount` resets after this interval (in seconds)\n  uint256 public resetInstantRedemptionDuration;\n  // timestamp when the `currentInstantRedemptionAmount` was last reset\n  uint256 public lastResetInstantRedemptionTime;\n\n  // maximum amount that can be redeemed during a `resetInstantRedemptionDuration` window\n  uint256 public instantRedemptionLimit;\n  // amount already redeemed during the current `resetInstantRedemptionDuration` window\n  uint256 public currentInstantRedemptionAmount;\n\n  /**\n   * @notice In the constructor, we initialize the variables for the mint and\n   *         redemption rate limiters.\n   *\n   * @param _instantMintResetDuration   `currentInstantMintAmount` resets after this interval\n   *                                    (in seconds)\n   * @param _instantRedemptionResetDuration `currentInstantRedemptionAmount` resets after this\n   *                                    interval (in seconds)\n   * @param _instantMintLimit           maximum amount that can be minted during a\n   *                                    `resetInstantMintDuration` window\n   * @param _instantRedemptionLimit     maximum amount that can be redeemed during a\n   *                                    `resetInstantRedemptionDuration` window\n   *\n   * @dev If a duration is zero, the limit resets before each mint/redemption.\n   * @dev If a limit is zero, the relevant check always fails.\n   */\n  constructor(\n    uint256 _instantMintResetDuration,\n    uint256 _instantRedemptionResetDuration,\n    uint256 _instantMintLimit,\n    uint256 _instantRedemptionLimit\n  ) {\n    resetInstantMintDuration = _instantMintResetDuration; // can be zero for per-block limit\n    resetInstantRedemptionDuration = _instantRedemptionResetDuration; // can be zero for per-block limit\n    instantMintLimit = _instantMintLimit; // can be zero to disable minting\n    instantRedemptionLimit = _instantRedemptionLimit; // can be zero to disable redemptions\n\n    lastResetInstantMintTime = block.timestamp;\n    lastResetInstantRedemptionTime = block.timestamp;\n  }\n\n  /**\n   * @notice Checks the requested mint amount against the rate limiter (and\n   *         updates the remaining amount)\n   *\n   * @param amount The requested mint amount\n   *\n   * @dev Reverts if the requested mint amount exceeds the current limit\n   */\n  function _checkAndUpdateInstantMintLimit(uint256 amount) internal {\n    require(amount > 0, \"RateLimit: mint amount can't be zero\");\n\n    if (\n      block.timestamp >= lastResetInstantMintTime + resetInstantMintDuration\n    ) {\n      // time has passed, reset\n      currentInstantMintAmount = 0;\n      lastResetInstantMintTime = block.timestamp;\n    }\n    require(\n      amount <= instantMintLimit - currentInstantMintAmount,\n      \"RateLimit: Mint exceeds rate limit\"\n    );\n\n    currentInstantMintAmount += amount;\n  }\n\n  /**\n   * @notice Checks the requested redemption amount against the rate limiter\n   *         (and updates the remaining amount)\n   *\n   * @param amount The requested redemption amount\n   *\n   * @dev Reverts if the requested redemption amount exceeds the current\n   *      limit\n   */\n  function _checkAndUpdateInstantRedemptionLimit(uint256 amount) internal {\n    require(amount > 0, \"RateLimit: redemption amount can't be zero\");\n\n    if (\n      block.timestamp >=\n      lastResetInstantRedemptionTime + resetInstantRedemptionDuration\n    ) {\n      // time has passed, reset\n      currentInstantRedemptionAmount = 0;\n      lastResetInstantRedemptionTime = block.timestamp;\n    }\n    require(\n      amount <= instantRedemptionLimit - currentInstantRedemptionAmount,\n      \"RateLimit: Redemption exceeds rate limit\"\n    );\n    currentInstantRedemptionAmount += amount;\n  }\n\n  /**\n   * @notice Update the amount of token that can be minted during one duration\n   *\n   * @param _instantMintLimit The token amount\n   *\n   * @dev If a limit is zero, the relevant check always fails.\n   */\n  function _setInstantMintLimit(uint256 _instantMintLimit) internal {\n    instantMintLimit = _instantMintLimit;\n    emit InstantMintLimitSet(_instantMintLimit);\n  }\n\n  /**\n   * @notice Update the amount of token that can be redeemed during one duration\n   *\n   * @param _redemptionLimit The token amount\n   *\n   * @dev If a limit is zero, the relevant check always fails.\n   */\n  function _setInstantRedemptionLimit(uint256 _redemptionLimit) internal {\n    instantRedemptionLimit = _redemptionLimit;\n    emit InstantRedemptionLimitSet(_redemptionLimit);\n  }\n\n  /**\n   * @notice Update the duration for the mint rate limiter\n   *\n   * @param _instantMintResetDuration The duration in seconds\n   *\n   * @dev If a duration is zero, the limit resets before each mint/redemption\n   */\n  function _setInstantMintLimitDuration(\n    uint256 _instantMintResetDuration\n  ) internal {\n    resetInstantMintDuration = _instantMintResetDuration;\n    emit InstantMintLimitDurationSet(_instantMintResetDuration);\n  }\n\n  /**\n   * @notice Update the duration for the redemption rate limiter\n   *\n   * @param _instantRedemptionResetDuration The duration in seconds\n   *\n   * @dev If a duration is zero, the limit resets before each mint/redemption\n   */\n  function _setInstantRedemptionLimitDuration(\n    uint256 _instantRedemptionResetDuration\n  ) internal {\n    resetInstantRedemptionDuration = _instantRedemptionResetDuration;\n    emit InstantRedemptionLimitDurationSet(_instantRedemptionResetDuration);\n  }\n\n  /**\n   * @notice Event emitted when instant mint limit is set\n   *\n   * @param instantMintLimit How much of some token can be minted within\n   *                  an interval of length `resetInstantMintDuration`\n   *\n   * @dev See inheriting contract for representation\n   */\n  event InstantMintLimitSet(uint256 instantMintLimit);\n\n  /**\n   * @notice Event emitted when instant redemption limit is set\n   *\n   * @param instantRedemptionLimit How much of some token can be redeemed within\n   *                    an interval of length `resetInstantRedemptionDuration`\n   *\n   * @dev See inheriting contract for representation\n   */\n  event InstantRedemptionLimitSet(uint256 instantRedemptionLimit);\n\n  /**\n   * @notice Event emitted when mint limit duration is set\n   *\n   * @param instantMintLimitDuration The time window in which `instantMintLimit`\n   *                          of some token can be minted\n   *\n   * @dev instantMintLimitDuration is specified in seconds\n   */\n  event InstantMintLimitDurationSet(uint256 instantMintLimitDuration);\n\n  /**\n   * @notice Event emitted when redemption limit duration is set\n   *\n   * @param redemptionLimitDuration The time window in which `instantRedemptionLimit`\n   *                            of some token can be redeemed\n   *\n   * @dev redemptionLimitDuration is specified in seconds.\n   */\n  event InstantRedemptionLimitDurationSet(uint256 redemptionLimitDuration);\n}\n"
    },
    "contracts/interfaces/IRWAHubNonStableInstantMint.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IRWAHub.sol\";\n\ninterface IRWAHubNonStableInstantMint {\n  /**\n   * @notice Event emitted when an instant mint is completed\n   *\n   * @param user                      The address of the user\n   * @param collateralAmountDeposited The amount of collateral deposited\n   * @param collateralAmountAfterFees The amount of collateral after fees\n   * @param feesInCollateral          The amount of fees in collateral\n   * @param rwaGiven                  The amount of rwa minted to the user\n   * @param priceMinted               The price at which the rwa was minted at\n   * @param depositId                 The id of the deposit in RWAHub\n   */\n  event InstantMint(\n    address indexed user,\n    uint256 collateralAmountDeposited,\n    uint256 collateralAmountAfterFees,\n    uint256 feesInCollateral,\n    uint256 rwaGiven,\n    uint256 priceMinted,\n    bytes32 depositId\n  );\n\n  /**\n   * @notice Event emitted when the excess of the instant mint is claimed\n   *\n   * @param user           The address of the user\n   * @param totalRWAOwed   The total amount of rwa owed (instant mint + excess)\n   * @param rwaExcessDue   The amount of excess rwa owed\n   * @param rwaExcessGiven The amount of rwa excess given in this claim\n   * @param priceClaimed   The price at which the excess rwa was claimed at\n   * @param depositId      The id of the deposit in RWAHub\n   */\n  event ExcessMintClaimed(\n    address indexed user,\n    uint256 totalRWAOwed,\n    uint256 rwaExcessDue,\n    uint256 rwaExcessGiven,\n    uint256 priceClaimed,\n    bytes32 depositId\n  );\n\n  /**\n   * @notice Event emitted when instant mint given is overriden\n   *\n   * @param depositId   The id of the deposit in RWAHub\n   * @param oldGivenAmt The old amount of rwa given\n   * @param newGivenAmt The new amount of rwa given\n   */\n  event InstantMintGivenOverriden(\n    bytes32 indexed depositId,\n    uint256 oldGivenAmt,\n    uint256 newGivenAmt\n  );\n\n  /**\n   * @notice Event emitted when instant mint asset manager is set\n   *\n   * @param oldInstantMintAssetManager Old instant mint asset manager\n   * @param newInstantMintAssetManager New instant mint asset manager\n   */\n  event InstantMintAssetManagerSet(\n    address oldInstantMintAssetManager,\n    address newInstantMintAssetManager\n  );\n\n  /**\n   * @notice Event emitted when instant mint amount % (in bps) is set\n   *\n   * @param oldInstantMintBps Old instant mint amount in bps\n   * @param newInstantMintBps New instant mint amount in bps\n   */\n  event InstantMintAmountSet(\n    uint256 oldInstantMintBps,\n    uint256 newInstantMintBps\n  );\n\n  /**\n   * @notice Event emitted when instant mints are paused\n   *\n   * @param caller Address which initiated the pause\n   */\n  event InstantMintPaused(address caller);\n\n  /**\n   * @notice Event emitted when instant mints are unpaused\n   *\n   * @param caller Address which initiated the unpause\n   */\n  event InstantMintUnpaused(address caller);\n\n  /**\n   * @notice Event emitted when claiming excess is paused\n   *\n   * @param caller Address which initiated the pause\n   */\n  event ClaimExcessPaused(address caller);\n\n  /**\n   * @notice Event emitted when claiming excess is unpaused\n   *\n   * @param caller Address which initiated the unpause\n   */\n  event ClaimExcessUnpaused(address caller);\n\n  /**\n   * @notice Event emitted when instant mint fee is set\n   *\n   * @param oldFee Old fee\n   * @param newFee New fee\n   *\n   * @dev See inheriting contract for decimals representation\n   */\n  event InstantMintFeeSet(uint256 oldFee, uint256 newFee);\n\n  // Errors\n  error CannotClaimExcess();\n  error CannotClaimMint();\n}\n"
    },
    "contracts/RWAHub.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IPricerReader.sol\";\nimport \"contracts/interfaces/IRWALike.sol\";\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\nimport \"contracts/external/openzeppelin/contracts/token/SafeERC20.sol\";\nimport \"contracts/interfaces/IRWAHub.sol\";\n\n// Additional Dependencies\nimport \"contracts/external/openzeppelin/contracts/token/IERC20Metadata.sol\";\nimport \"contracts/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"contracts/external/openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nabstract contract RWAHub is IRWAHub, ReentrancyGuard, AccessControlEnumerable {\n  using SafeERC20 for IERC20;\n  // RWA Token contract\n  IRWALike public immutable rwa;\n  // Pointer to Pricer\n  IPricerReader public pricer;\n  // Address to receive deposits\n  address public constant assetRecipient = 0x3d7a5eDFCDCA0f9FDD066Fb94D306f2b4Cc7DB17; // Polygon Dev Multisig\n  // Address to send redemptions\n  address public assetSender;\n  // Address fee recipient\n  address public feeRecipient;\n  // Mapping from deposit Id -> Depositor\n  mapping(bytes32 => Depositor) public depositIdToDepositor;\n  // Mapping from redemptionId -> Redeemer\n  mapping(bytes32 => Redeemer) public redemptionIdToRedeemer;\n\n  /// @dev Mint/Redeem Parameters\n  // Minimum amount that must be deposited to mint the RWA token\n  // Denoted in decimals of `collateral`\n  uint256 public minimumDepositAmount;\n\n  // Minimum amount that must be redeemed for a withdraw request\n  uint256 public minimumRedemptionAmount;\n\n  // Minting fee specified in basis points\n  uint256 public mintFee = 0;\n\n  // Redemption fee specified in basis points\n  uint256 public redemptionFee = 0;\n\n  // The asset accepted by the RWAHub\n  IERC20 public immutable collateral;\n\n  // Decimal multiplier representing the difference between `rwa` decimals\n  // In `collateral` token decimals\n  uint256 public immutable decimalsMultiplier;\n\n  // Deposit counter to map subscription requests to\n  uint256 public subscriptionRequestCounter = 1;\n\n  // Redemption Id to map from\n  uint256 public redemptionRequestCounter = 1;\n\n  // Helper constant that allows us to specify basis points in calculations\n  uint256 public constant BPS_DENOMINATOR = 10_000;\n\n  // Pause variables\n  bool public redemptionPaused;\n  bool public subscriptionPaused;\n\n  /// @dev Role based access control roles\n  bytes32 public constant MANAGER_ADMIN = keccak256(\"MANAGER_ADMIN\");\n  bytes32 public constant PAUSER_ADMIN = keccak256(\"PAUSER_ADMIN\");\n  bytes32 public constant PRICE_ID_SETTER_ROLE =\n    keccak256(\"PRICE_ID_SETTER_ROLE\");\n  bytes32 public constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\n\n  /// @notice constructor\n  constructor(\n    address _collateral,\n    address _rwa,\n    address managerAdmin,\n    address pauser,\n    address _assetSender,\n    address _feeRecipient,\n    uint256 _minimumDepositAmount,\n    uint256 _minimumRedemptionAmount\n  ) {\n    if (_collateral == address(0)) {\n      revert CollateralCannotBeZero();\n    }\n    if (_rwa == address(0)) {\n      revert RWACannotBeZero();\n    }\n    if (_assetSender == address(0)) {\n      revert AssetSenderCannotBeZero();\n    }\n    if (_feeRecipient == address(0)) {\n      revert FeeRecipientCannotBeZero();\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, managerAdmin);\n    _grantRole(MANAGER_ADMIN, managerAdmin);\n    _grantRole(PAUSER_ADMIN, pauser);\n    _setRoleAdmin(PAUSER_ADMIN, MANAGER_ADMIN);\n    _setRoleAdmin(PRICE_ID_SETTER_ROLE, MANAGER_ADMIN);\n    _setRoleAdmin(RELAYER_ROLE, MANAGER_ADMIN);\n\n    collateral = IERC20(_collateral);\n    rwa = IRWALike(_rwa);\n    feeRecipient = _feeRecipient;\n    assetSender = _assetSender;\n    minimumDepositAmount = _minimumDepositAmount;\n    minimumRedemptionAmount = _minimumRedemptionAmount;\n\n    decimalsMultiplier =\n      10 **\n        (IERC20Metadata(_rwa).decimals() -\n          IERC20Metadata(_collateral).decimals());\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                  Subscription/Redemption Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Function used by users to request subscription to the fund\n   *\n   * @param amount The amount of collateral one wished to deposit\n   */\n  function requestSubscription(\n    uint256 amount\n  )\n    external\n    virtual\n    nonReentrant\n    ifNotPaused(subscriptionPaused)\n    checkRestrictions(msg.sender)\n  {\n    if (amount < minimumDepositAmount) {\n      revert DepositTooSmall();\n    }\n\n    uint256 feesInCollateral = _getMintFees(amount);\n    uint256 depositAmountAfterFee = amount - feesInCollateral;\n\n    // Link the depositor to their deposit ID\n    bytes32 depositId = bytes32(subscriptionRequestCounter++);\n    depositIdToDepositor[depositId] = Depositor(\n      msg.sender,\n      depositAmountAfterFee,\n      0\n    );\n\n    if (feesInCollateral > 0) {\n      collateral.safeTransferFrom(msg.sender, feeRecipient, feesInCollateral);\n    }\n\n    collateral.safeTransferFrom(\n      msg.sender,\n      assetRecipient,\n      depositAmountAfterFee\n    );\n\n    emit MintRequested(\n      msg.sender,\n      depositId,\n      amount,\n      depositAmountAfterFee,\n      feesInCollateral\n    );\n  }\n\n  /**\n   * @notice Function used to claim tokens corresponding to a deposit request\n   *\n   * @param depositIds An array containing the deposit Ids one wishes to claim\n   *\n   * @dev Implicitly does all transfer checks present in underlying `rwa`\n   * @dev The priceId corresponding to a given depositId must be set prior to\n   *      claiming a mint\n   */\n  function claimMint(\n    bytes32[] calldata depositIds\n  ) external virtual nonReentrant ifNotPaused(subscriptionPaused) {\n    uint256 depositsSize = depositIds.length;\n    for (uint256 i = 0; i < depositsSize; ++i) {\n      _claimMint(depositIds[i]);\n    }\n  }\n\n  /**\n   * @notice Internal claim mint helper\n   *\n   * @dev This function can be overriden to implement custom claiming logic\n   */\n  function _claimMint(bytes32 depositId) internal virtual {\n    Depositor memory depositor = depositIdToDepositor[depositId];\n    // Revert if priceId is not set\n    if (depositor.priceId == 0) {\n      revert PriceIdNotSet();\n    }\n\n    uint256 price = pricer.getPrice(depositor.priceId);\n    uint256 rwaOwed = _getMintAmountForPrice(\n      depositor.amountDepositedMinusFees,\n      price\n    );\n\n    delete depositIdToDepositor[depositId];\n    rwa.mint(depositor.user, rwaOwed);\n\n    emit MintCompleted(\n      depositor.user,\n      depositId,\n      rwaOwed,\n      depositor.amountDepositedMinusFees,\n      price,\n      depositor.priceId\n    );\n  }\n\n  /**\n   * @notice Function used by users to request a redemption from the fund\n   *\n   * @param amount The amount (in units of `rwa`) that a user wishes to redeem\n   *               from the fund\n   */\n  function requestRedemption(\n    uint256 amount\n  ) external virtual nonReentrant ifNotPaused(redemptionPaused) {\n    if (amount < minimumRedemptionAmount) {\n      revert RedemptionTooSmall();\n    }\n    bytes32 redemptionId = bytes32(redemptionRequestCounter++);\n    redemptionIdToRedeemer[redemptionId] = Redeemer(msg.sender, amount, 0);\n\n    rwa.burnFrom(msg.sender, amount);\n\n    emit RedemptionRequested(msg.sender, redemptionId, amount);\n  }\n\n  /**\n   * @notice Function to claim collateral corresponding to a redemption request\n   *\n   * @param redemptionIds an Array of redemption Id's which ought to fulfilled\n   *\n   * @dev Implicitly does all checks present in underlying `rwa`\n   * @dev The price Id corresponding to a redemptionId must be set prior to\n   *      claiming a redemption\n   */\n  function claimRedemption(\n    bytes32[] calldata redemptionIds\n  ) external virtual nonReentrant ifNotPaused(redemptionPaused) {\n    uint256 fees;\n    uint256 redemptionsSize = redemptionIds.length;\n    for (uint256 i = 0; i < redemptionsSize; ++i) {\n      Redeemer memory member = redemptionIdToRedeemer[redemptionIds[i]];\n      _checkRestrictions(member.user);\n      if (member.priceId == 0) {\n        // Then the price for this redemption has not been set\n        revert PriceIdNotSet();\n      }\n\n      // Calculate collateral due and fees\n      uint256 price = pricer.getPrice(member.priceId);\n      uint256 collateralDue = _getRedemptionAmountForRwa(\n        member.amountRwaTokenBurned,\n        price\n      );\n      uint256 fee = _getRedemptionFees(collateralDue);\n      uint256 collateralDuePostFees = collateralDue - fee;\n      fees += fee;\n\n      delete redemptionIdToRedeemer[redemptionIds[i]];\n\n      collateral.safeTransferFrom(\n        assetSender,\n        member.user,\n        collateralDuePostFees\n      );\n\n      emit RedemptionCompleted(\n        member.user,\n        redemptionIds[i],\n        member.amountRwaTokenBurned,\n        collateralDuePostFees,\n        fee,\n        price,\n        member.priceId\n      );\n    }\n    if (fees > 0) {\n      collateral.safeTransferFrom(assetSender, feeRecipient, fees);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                         Relayer Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Adds a deposit proof to the contract\n   *\n   * @param txHash                The transaction hash of the deposit\n   * @param user                  The address of the user who made the deposit\n   * @param depositAmountAfterFee The amount of the deposit after fees\n   * @param feeAmount             The amount of the fees taken\n   * @param timestamp             The timestamp of the deposit\n   *\n   * @dev txHash is used as the depositId in storage\n   * @dev All amounts are in decimals of `collateral`\n   */\n  function addProof(\n    bytes32 txHash,\n    address user,\n    uint256 depositAmountAfterFee,\n    uint256 feeAmount,\n    uint256 timestamp\n  ) external override onlyRole(RELAYER_ROLE) checkRestrictions(user) {\n    if (depositIdToDepositor[txHash].user != address(0)) {\n      revert DepositProofAlreadyExists();\n    }\n    depositIdToDepositor[txHash] = Depositor(user, depositAmountAfterFee, 0);\n    emit DepositProofAdded(\n      txHash,\n      user,\n      depositAmountAfterFee,\n      feeAmount,\n      timestamp\n    );\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                           PriceId Setters\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Admin function to associate a depositId with a given Price Id\n   *\n   * @param depositIds an Array of deposit Ids to be associated\n   * @param priceIds   an Array of price Ids to be associated\n   *\n   * @dev Array size must match\n   */\n  function setPriceIdForDeposits(\n    bytes32[] calldata depositIds,\n    uint256[] calldata priceIds\n  ) public virtual onlyRole(PRICE_ID_SETTER_ROLE) {\n    uint256 depositsSize = depositIds.length;\n    if (depositsSize != priceIds.length) {\n      revert ArraySizeMismatch();\n    }\n    for (uint256 i = 0; i < depositsSize; ++i) {\n      if (depositIdToDepositor[depositIds[i]].user == address(0)) {\n        revert DepositorNull();\n      }\n      if (depositIdToDepositor[depositIds[i]].priceId != 0) {\n        revert PriceIdAlreadySet();\n      }\n      depositIdToDepositor[depositIds[i]].priceId = priceIds[i];\n      emit PriceIdSetForDeposit(depositIds[i], priceIds[i]);\n    }\n  }\n\n  /**\n   * @notice Admin function to associate redemptionId with a given priceId\n   *\n   * @param redemptionIds an Array of redemptionIds to associate\n   * @param priceIds  an Array of priceIds to associate\n   */\n  function setPriceIdForRedemptions(\n    bytes32[] calldata redemptionIds,\n    uint256[] calldata priceIds\n  ) public virtual onlyRole(PRICE_ID_SETTER_ROLE) {\n    uint256 redemptionsSize = redemptionIds.length;\n    if (redemptionsSize != priceIds.length) {\n      revert ArraySizeMismatch();\n    }\n    for (uint256 i = 0; i < redemptionsSize; ++i) {\n      if (redemptionIdToRedeemer[redemptionIds[i]].priceId != 0) {\n        revert PriceIdAlreadySet();\n      }\n      redemptionIdToRedeemer[redemptionIds[i]].priceId = priceIds[i];\n      emit PriceIdSetForRedemption(redemptionIds[i], priceIds[i]);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                           Admin Setters\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Admin function to overwrite entries in the depoitIdToDepositor\n   *         mapping\n   *\n   * @param depositIdToOverwrite  The depositId of the entry we wish to\n   *                              overwrite\n   * @param user                  The user for the new entry\n   * @param depositAmountAfterFee The deposit value for the new entry\n   * @param priceId               The priceId to be associated with the new\n   *                              entry\n   */\n  function overwriteDepositor(\n    bytes32 depositIdToOverwrite,\n    address user,\n    uint256 depositAmountAfterFee,\n    uint256 priceId\n  ) external onlyRole(MANAGER_ADMIN) checkRestrictions(user) {\n    Depositor memory oldDepositor = depositIdToDepositor[depositIdToOverwrite];\n\n    depositIdToDepositor[depositIdToOverwrite] = Depositor(\n      user,\n      depositAmountAfterFee,\n      priceId\n    );\n\n    emit DepositorOverwritten(\n      depositIdToOverwrite,\n      oldDepositor.user,\n      user,\n      oldDepositor.priceId,\n      priceId,\n      oldDepositor.amountDepositedMinusFees,\n      depositAmountAfterFee\n    );\n  }\n\n  /**\n   * @notice Admin function to overwrite entries in the redemptionIdToRedeemer\n   *         mapping\n   *\n   * @param redemptionIdToOverwrite The redemptionId of the entry we wish to\n   *                                overwrite\n   * @param user                    The user for the new entry\n   * @param rwaTokenAmountBurned    The burn amount for the new entry\n   * @param priceId                 The priceID to be associated with the new\n   *                                entry\n   */\n  function overwriteRedeemer(\n    bytes32 redemptionIdToOverwrite,\n    address user,\n    uint256 rwaTokenAmountBurned,\n    uint256 priceId\n  ) external onlyRole(MANAGER_ADMIN) checkRestrictions(user) {\n    Redeemer memory oldRedeemer = redemptionIdToRedeemer[\n      redemptionIdToOverwrite\n    ];\n    redemptionIdToRedeemer[redemptionIdToOverwrite] = Redeemer(\n      user,\n      rwaTokenAmountBurned,\n      priceId\n    );\n    emit RedeemerOverwritten(\n      redemptionIdToOverwrite,\n      oldRedeemer.user,\n      user,\n      oldRedeemer.priceId,\n      priceId,\n      oldRedeemer.amountRwaTokenBurned,\n      rwaTokenAmountBurned\n    );\n  }\n\n  /**\n   * @notice Admin function to set the minimum amount to redeem\n   *\n   * @param _minimumRedemptionAmount The minimum amount required to submit a\n   *                                 redemption request\n   */\n  function setMinimumRedemptionAmount(\n    uint256 _minimumRedemptionAmount\n  ) external onlyRole(MANAGER_ADMIN) {\n    if (_minimumRedemptionAmount < BPS_DENOMINATOR) {\n      revert AmountTooSmall();\n    }\n    uint256 oldRedeemMinimum = minimumRedemptionAmount;\n    minimumRedemptionAmount = _minimumRedemptionAmount;\n    emit MinimumRedemptionAmountSet(oldRedeemMinimum, _minimumRedemptionAmount);\n  }\n\n  /**\n   * @notice Admin function to set the minimum amount required for a deposit\n   *\n   * @param minDepositAmount The minimum amount required to submit a deposit\n   *                         request\n   */\n  function setMinimumDepositAmount(\n    uint256 minDepositAmount\n  ) external onlyRole(MANAGER_ADMIN) {\n    if (minDepositAmount < BPS_DENOMINATOR) {\n      revert AmountTooSmall();\n    }\n    uint256 oldMinimumDepositAmount = minimumDepositAmount;\n    minimumDepositAmount = minDepositAmount;\n    emit MinimumDepositAmountSet(oldMinimumDepositAmount, minDepositAmount);\n  }\n\n  /**\n   * @notice Admin function to set the mint fee\n   *\n   * @param _mintFee The new mint fee specified in basis points\n   *\n   * @dev The maximum fee that can be set is 10_000 bps, or 100%\n   */\n  function setMintFee(uint256 _mintFee) external onlyRole(MANAGER_ADMIN) {\n    if (_mintFee > BPS_DENOMINATOR) {\n      revert FeeTooLarge();\n    }\n    uint256 oldMintFee = mintFee;\n    mintFee = _mintFee;\n    emit MintFeeSet(oldMintFee, _mintFee);\n  }\n\n  /**\n   * @notice Admin function to set the redeem fee\n   *\n   * @param _redemptionFee The new redeem fee specified in basis points\n   *\n   * @dev The maximum fee that can be set is 10_000 bps, or 100%\n   */\n  function setRedemptionFee(\n    uint256 _redemptionFee\n  ) external onlyRole(MANAGER_ADMIN) {\n    if (_redemptionFee > BPS_DENOMINATOR) {\n      revert FeeTooLarge();\n    }\n    uint256 oldRedeemFee = redemptionFee;\n    redemptionFee = _redemptionFee;\n    emit RedemptionFeeSet(oldRedeemFee, _redemptionFee);\n  }\n\n  /**\n   * @notice Admin function to set the address of the Pricer contract\n   *\n   * @param newPricer The address of the new pricer contract\n   */\n  function setPricer(address newPricer) external onlyRole(MANAGER_ADMIN) {\n    address oldPricer = address(pricer);\n    pricer = IPricerReader(newPricer);\n    emit NewPricerSet(oldPricer, newPricer);\n  }\n\n  /**\n   * @notice Admin function to set the address of `feeRecipient`\n   *\n   * @param newFeeRecipient The address of the new `feeRecipient`\n   */\n  function setFeeRecipient(\n    address newFeeRecipient\n  ) external onlyRole(MANAGER_ADMIN) {\n    address oldFeeRecipient = feeRecipient;\n    feeRecipient = newFeeRecipient;\n    emit FeeRecipientSet(oldFeeRecipient, feeRecipient);\n  }\n\n  /**\n   * @notice Admin function to set the address of `assetSender`\n   *\n   * @param newAssetSender The address of the new `assetSender`\n   */\n  function setAssetSender(\n    address newAssetSender\n  ) external onlyRole(MANAGER_ADMIN) {\n    address oldAssetSender = assetSender;\n    assetSender = newAssetSender;\n    emit AssetSenderSet(oldAssetSender, newAssetSender);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            Pause Utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Modifier to check if a feature is paused\n   *\n   * @param feature The feature to check if paused\n   */\n  modifier ifNotPaused(bool feature) {\n    if (feature) {\n      revert FeaturePaused();\n    }\n    _;\n  }\n\n  /**\n   * @notice Function to pause subscription to RWAHub\n   */\n  function pauseSubscription() external onlyRole(PAUSER_ADMIN) {\n    subscriptionPaused = true;\n    emit SubscriptionPaused(msg.sender);\n  }\n\n  /**\n   * @notice Function to pause redemptions to RWAHub\n   */\n  function pauseRedemption() external onlyRole(PAUSER_ADMIN) {\n    redemptionPaused = true;\n    emit RedemptionPaused(msg.sender);\n  }\n\n  /**\n   * @notice Function to unpause subscriptions to RWAHub\n   */\n  function unpauseSubscription() external onlyRole(MANAGER_ADMIN) {\n    subscriptionPaused = false;\n    emit SubscriptionUnpaused(msg.sender);\n  }\n\n  /**\n   * @notice Function to unpause redemptions to RWAHub\n   */\n  function unpauseRedemption() external onlyRole(MANAGER_ADMIN) {\n    redemptionPaused = false;\n    emit RedemptionUnpaused(msg.sender);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      Check Restriction Utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Modifier to check restrictions status of an account\n   *\n   * @param account The account to check\n   */\n  modifier checkRestrictions(address account) {\n    _checkRestrictions(account);\n    _;\n  }\n\n  /**\n   * @notice internal function to check restriction status\n   *         of an address\n   *\n   * @param account The account to check restriction status for\n   *\n   * @dev This function is virtual to be overridden by child contract\n   *      to check restrictions on a more granular level\n   */\n  function _checkRestrictions(address account) internal view virtual;\n\n  /*//////////////////////////////////////////////////////////////\n                           Math Utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Given amount of `collateral`, returns how much in fees\n   *         are owed\n   *\n   *\n   * @param collateralAmount Amount `collateral` to calculate fees\n   *                         (in decimals of `collateral`)\n   */\n  function _getMintFees(\n    uint256 collateralAmount\n  ) internal view returns (uint256) {\n    return (collateralAmount * mintFee) / BPS_DENOMINATOR;\n  }\n\n  /**\n   * @notice Given amount of `collateral`, returns how much in fees\n   *         are owed\n   *\n   * @param collateralAmount Amount of `collateral` to calculate fees\n   *                         (in decimals of `collateral`)\n   */\n  function _getRedemptionFees(\n    uint256 collateralAmount\n  ) internal view returns (uint256) {\n    return (collateralAmount * redemptionFee) / BPS_DENOMINATOR;\n  }\n\n  /**\n   * @notice Given a deposit amount and priceId, returns the amount\n   *         of `rwa` due\n   *\n   * @param depositAmt The amount deposited in units of `collateral`\n   * @param price      The price associated with this deposit\n   */\n  function _getMintAmountForPrice(\n    uint256 depositAmt,\n    uint256 price\n  ) internal view returns (uint256 rwaAmountOut) {\n    uint256 amountE36 = _scaleUp(depositAmt) * 1e18;\n    // Will revert with div by 0 if price not defined for a priceId\n    rwaAmountOut = amountE36 / price;\n  }\n\n  /**\n   * @notice Given a redemption amount and a priceId, returns the amount\n   *         of `collateral` due\n   *\n   * @param rwaTokenAmountBurned The amount of `rwa` burned for a redemption\n   * @param price                The price associated with this redemption\n   */\n  function _getRedemptionAmountForRwa(\n    uint256 rwaTokenAmountBurned,\n    uint256 price\n  ) internal view returns (uint256 collateralOwed) {\n    uint256 amountE36 = rwaTokenAmountBurned * price;\n    collateralOwed = _scaleDown(amountE36 / 1e18);\n  }\n\n  /**\n   * @notice Scale provided amount up by `decimalsMultiplier`\n   *\n   * @dev This helper is used for converting the collateral's decimals\n   *      representation to the RWA amount decimals representation.\n   */\n  function _scaleUp(uint256 amount) internal view returns (uint256) {\n    return amount * decimalsMultiplier;\n  }\n\n  /**\n   * @notice Scale provided amount down by `decimalsMultiplier`\n   *\n   * @dev This helper is used for converting `rwa`'s decimal\n   *      representation to the `collateral`'s decimal representation\n   */\n  function _scaleDown(uint256 amount) internal view returns (uint256) {\n    return amount / decimalsMultiplier;\n  }\n}\n"
    },
    "contracts/interfaces/IRWAHubOffChainRedemptions.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n */\npragma solidity 0.8.16;\n\ninterface IRWAHubOffChainRedemptions {\n  function requestRedemptionServicedOffchain(\n    uint256 amountRWATokenToRedeem,\n    bytes32 offChainDestination\n  ) external;\n\n  function pauseOffChainRedemption() external;\n\n  function unpauseOffChainRedemption() external;\n\n  function setOffChainRedemptionMinimum(uint256 minimumAmount) external;\n\n  /**\n   * @notice Event emitted when redemption request is submitted\n   *\n   * @param user                The user submitting the offchain redemption request\n   * @param redemptionId        The id corresponding to a given offchain redemption request\n   * @param rwaTokenAmountIn    The amount of cash being burned\n   * @param offChainDestination Hash of destination to which the request\n   *                            should be serviced to\n   */\n  event RedemptionRequestedServicedOffChain(\n    address indexed user,\n    bytes32 indexed redemptionId,\n    uint256 rwaTokenAmountIn,\n    bytes32 offChainDestination\n  );\n\n  /**\n   * @notice Event emitted when the off chain redemption feature is\n   *         paused\n   *\n   * @param caller Address which initiated the pause\n   */\n  event OffChainRedemptionPaused(address caller);\n\n  /**\n   * @notice Event emitted when the off chain redemption feature is\n   *         unpaused\n   *\n   * @param caller Address which initiated the unpause\n   */\n  event OffChainRedemptionUnpaused(address caller);\n\n  /**\n   * @notice Event emitted when the off chain redemption minimum is\n   *         updated\n   *\n   * @param oldMinimum the old minimum redemption amount\n   * @param newMinimum the new minimum redemption amount\n   */\n  event OffChainRedemptionMinimumSet(uint256 oldMinimum, uint256 newMinimum);\n}\n"
    },
    "contracts/interfaces/IPricerReader.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\ninterface IPricerReader {\n  /**\n   * @notice Gets the latest price of the asset\n   *\n   * @return uint256 The latest price of the asset\n   */\n  function getLatestPrice() external view returns (uint256);\n\n  /**\n   * @notice Gets the price of the asset at a specific priceId\n   *\n   * @param priceId The priceId at which to get the price\n   *\n   * @return uint256 The price of the asset with the given priceId\n   */\n  function getPrice(uint256 priceId) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IRWALike.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n */\npragma solidity 0.8.16;\n\n// This interface is not inherited directly by RWA, instead, it is a\n// subset of functions provided by all RWA tokens that the RWA Hub\n// Client uses.\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\n\ninterface IRWALike is IERC20 {\n  function mint(address to, uint256 amount) external;\n\n  function burn(uint256 amount) external;\n\n  function burnFrom(address from, uint256 amount) external;\n}\n"
    },
    "contracts/external/openzeppelin/contracts/token/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `to`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `from` to `to` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/external/openzeppelin/contracts/token/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\nimport \"contracts/external/openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  using Address for address;\n\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.transfer.selector, to, value)\n    );\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n    );\n  }\n\n  /**\n   * @dev Deprecated. This function has issues similar to the ones found in\n   * {IERC20-approve}, and its usage is discouraged.\n   *\n   * Whenever possible, use {safeIncreaseAllowance} and\n   * {safeDecreaseAllowance} instead.\n   */\n  function safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.approve.selector, spender, value)\n    );\n  }\n\n  function safeIncreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n    );\n  }\n\n  function safeDecreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    unchecked {\n      uint256 oldAllowance = token.allowance(address(this), spender);\n      require(\n        oldAllowance >= value,\n        \"SafeERC20: decreased allowance below zero\"\n      );\n      uint256 newAllowance = oldAllowance - value;\n      _callOptionalReturn(\n        token,\n        abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n      );\n    }\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\n   * @param token The token targeted by the call.\n   * @param data The call data (encoded using abi.encode or one of its variants).\n   */\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n    // the target address contains contract code and also asserts for success in the low-level call.\n\n    bytes memory returndata =\n      address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n    if (returndata.length > 0) {\n      // Return data is optional\n      require(\n        abi.decode(returndata, (bool)),\n        \"SafeERC20: ERC20 operation did not succeed\"\n      );\n    }\n  }\n}\n"
    },
    "contracts/interfaces/IRWAHub.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n */\npragma solidity 0.8.16;\n\ninterface IRWAHub {\n  // Struct to contain the deposit information for a given depositId\n  struct Depositor {\n    address user;\n    uint256 amountDepositedMinusFees;\n    uint256 priceId;\n  }\n\n  // Struc to contain withdrawal infromation for a given redemptionId\n  struct Redeemer {\n    address user;\n    uint256 amountRwaTokenBurned;\n    uint256 priceId;\n  }\n\n  function requestSubscription(uint256 amount) external;\n\n  function claimMint(bytes32[] calldata depositIds) external;\n\n  function requestRedemption(uint256 amount) external;\n\n  function claimRedemption(bytes32[] calldata redemptionIds) external;\n\n  function addProof(\n    bytes32 txHash,\n    address user,\n    uint256 depositAmountAfterFee,\n    uint256 feeAmount,\n    uint256 timestamp\n  ) external;\n\n  function setPriceIdForDeposits(\n    bytes32[] calldata depositIds,\n    uint256[] calldata priceIds\n  ) external;\n\n  function setPriceIdForRedemptions(\n    bytes32[] calldata redemptionIds,\n    uint256[] calldata priceIds\n  ) external;\n\n  function setPricer(address newPricer) external;\n\n  function overwriteDepositor(\n    bytes32 depositIdToOverride,\n    address user,\n    uint256 depositAmountAfterFee,\n    uint256 priceId\n  ) external;\n\n  function overwriteRedeemer(\n    bytes32 redemptionIdToOverride,\n    address user,\n    uint256 rwaTokenAmountBurned,\n    uint256 priceId\n  ) external;\n\n  /**\n   * @notice Event emitted when fee recipient is set\n   *\n   * @param oldFeeRecipient Old fee recipient\n   * @param newFeeRecipient New fee recipient\n   */\n  event FeeRecipientSet(address oldFeeRecipient, address newFeeRecipient);\n\n  /**\n   * @notice Event emitted when the assetSender is changed\n   *\n   * @param oldAssetSender The address of the old assetSender\n   * @param newAssetSender The address of the new assetSender\n   */\n  event AssetSenderSet(address oldAssetSender, address newAssetSender);\n\n  /**\n   * @notice Event emitted when minimum deposit amount is set\n   *\n   * @param oldMinimum Old minimum\n   * @param newMinimum New minimum\n   *\n   * @dev See inheriting contract for decimals representation\n   */\n  event MinimumDepositAmountSet(uint256 oldMinimum, uint256 newMinimum);\n\n  /**\n   * @notice Event emitted when a new redeem minimum is set.\n   *         All units are in 1e18\n   *\n   * @param oldRedemptionMin The old redeem minimum value\n   * @param newRedemptionMin The new redeem minimum value\n   */\n  event MinimumRedemptionAmountSet(\n    uint256 oldRedemptionMin,\n    uint256 newRedemptionMin\n  );\n\n  /**\n   * @notice Event emitted when mint fee is set\n   *\n   * @param oldFee Old fee\n   * @param newFee New fee\n   *\n   * @dev See inheriting contract for decimals representation\n   */\n  event MintFeeSet(uint256 oldFee, uint256 newFee);\n\n  /**\n   * @notice Event emitted when redeem fee is set\n   *\n   * @param oldFee Old fee\n   * @param newFee New fee\n   *\n   * @dev see inheriting contract for decimal representation\n   */\n  event RedemptionFeeSet(uint256 oldFee, uint256 newFee);\n\n  /**\n   * @notice Event emitted when redemption request is submitted\n   *\n   * @param user         The user submitting the redemption request\n   * @param redemptionId The id corresponding to a given redemption\n   * @param rwaAmountIn  The amount of cash being burned\n   */\n  event RedemptionRequested(\n    address indexed user,\n    bytes32 indexed redemptionId,\n    uint256 rwaAmountIn\n  );\n\n  /**\n   * @notice Event emitted when a mint request is submitted\n   *\n   * @param user                      The user requesting to mint\n   * @param depositId                 The depositId of the request\n   * @param collateralAmountDeposited The total amount deposited\n   * @param depositAmountAfterFee     The value deposited - fee\n   * @param feeAmount                 The fee amount taken\n   *                                  (units of collateral)\n   */\n  event MintRequested(\n    address indexed user,\n    bytes32 indexed depositId,\n    uint256 collateralAmountDeposited,\n    uint256 depositAmountAfterFee,\n    uint256 feeAmount\n  );\n\n  /**\n   * @notice Event emitted when a redemption request is completed\n   *\n   * @param user                     The address of the user getting the funds\n   * @param redemptionId             The id corresponding to a given redemption\n   *                                 requested\n   * @param rwaAmountRequested       Amount of RWA originally requested by the user\n   * @param collateralAmountReturned Amount of collateral received by the user\n   * @param feeAmount                Amount of fees taken\n   * @param price                    The price at which the redemption was\n   *                                 serviced at\n   * @param priceId                  The priceId of the used redemption price\n   */\n  event RedemptionCompleted(\n    address indexed user,\n    bytes32 indexed redemptionId,\n    uint256 rwaAmountRequested,\n    uint256 collateralAmountReturned,\n    uint256 feeAmount,\n    uint256 price,\n    uint256 priceId\n  );\n\n  /**\n   * @notice Event emitted when a Mint request is completed\n   *\n   * @param user                      The address of the user getting the funds\n   * @param depositId                 The depositId of the mint request\n   * @param rwaAmountOut              The amount of RWA token minted to the\n   *                                  user\n   * @param collateralAmountDeposited The amount of collateral deposited\n   * @param price                     The price set for the given\n   *                                  deposit id\n   * @param priceId                   The priceId used to determine price\n   */\n  event MintCompleted(\n    address indexed user,\n    bytes32 indexed depositId,\n    uint256 rwaAmountOut,\n    uint256 collateralAmountDeposited,\n    uint256 price,\n    uint256 priceId\n  );\n\n  /**\n   * @notice Event emitted when a deposit has its corresponding priceId set\n   *\n   * @param depositIdSet The Deposit Id for which the price Id is being set\n   * @param priceIdSet   The price Id being associate with a deposit Id\n   */\n  event PriceIdSetForDeposit(\n    bytes32 indexed depositIdSet,\n    uint256 indexed priceIdSet\n  );\n\n  /**\n   * @notice Event Emitted when a redemption has its corresponding priceId set\n   *\n   * @param redemptionIdSet The Redemption Id for which the price Id is being\n   *                        set\n   * @param priceIdSet      The Price Id being associated with a redemption Id\n   */\n  event PriceIdSetForRedemption(\n    bytes32 indexed redemptionIdSet,\n    uint256 indexed priceIdSet\n  );\n\n  /**\n   * @notice Event emitted when a new Pricer contract is set\n   *\n   * @param oldPricer The address of the old pricer contract\n   * @param newPricer The address of the new pricer contract\n   */\n  event NewPricerSet(address oldPricer, address newPricer);\n\n  /**\n   * @notice Event emitted when deposit proof has been added\n   *\n   * @param txHash                Tx hash of the deposit\n   * @param user                  Address of the user who made the deposit\n   * @param depositAmountAfterFee Amount of the deposit after fees\n   * @param feeAmount             Amount of fees taken\n   * @param timestamp             Timestamp of the deposit\n   */\n  event DepositProofAdded(\n    bytes32 indexed txHash,\n    address indexed user,\n    uint256 depositAmountAfterFee,\n    uint256 feeAmount,\n    uint256 timestamp\n  );\n\n  /**\n   * @notice Event emitted when subscriptions are paused\n   *\n   * @param caller Address which initiated the pause\n   */\n  event SubscriptionPaused(address caller);\n\n  /**\n   * @notice Event emitted when redemptions are paused\n   *\n   * @param caller Address which initiated the pause\n   */\n  event RedemptionPaused(address caller);\n\n  /**\n   * @notice Event emitted when subscriptions are unpaused\n   *\n   * @param caller Address which initiated the unpause\n   */\n  event SubscriptionUnpaused(address caller);\n\n  /**\n   * @notice Event emitted when redemptions are unpaused\n   *\n   * @param caller Address which initiated the unpause\n   */\n  event RedemptionUnpaused(address caller);\n\n  event DepositorOverwritten(\n    bytes32 indexed depositId,\n    address oldDepositor,\n    address newDepositor,\n    uint256 oldPriceId,\n    uint256 newPriceId,\n    uint256 oldDepositAmount,\n    uint256 newDepositAmount\n  );\n\n  event RedeemerOverwritten(\n    bytes32 indexed redemptionId,\n    address oldRedeemer,\n    address newRedeemer,\n    uint256 oldPriceId,\n    uint256 newPriceId,\n    uint256 oldRWATokenAmountBurned,\n    uint256 newRWATokenAmountBurned\n  );\n\n  /// ERRORS ///\n  error PriceIdNotSet();\n  error ArraySizeMismatch();\n  error DepositTooSmall();\n  error RedemptionTooSmall();\n  error TxnAlreadyValidated();\n  error CollateralCannotBeZero();\n  error RWACannotBeZero();\n  error AssetSenderCannotBeZero();\n  error FeeRecipientCannotBeZero();\n  error FeeTooLarge();\n  error AmountTooSmall();\n  error DepositorNull();\n  error RedeemerNull();\n  error DepositProofAlreadyExists();\n  error RedemptionProofAlreadyExists();\n  error FeaturePaused();\n  error PriceIdAlreadySet();\n}\n"
    },
    "contracts/external/openzeppelin/contracts/token/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the decimals places of the token.\n   */\n  function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/external/openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts/access/IAccessControlEnumerable.sol\";\nimport \"contracts/external/openzeppelin/contracts/access/AccessControl.sol\";\nimport \"contracts/external/openzeppelin/contracts/utils/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is\n  IAccessControlEnumerable,\n  AccessControl\n{\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return\n      interfaceId == type(IAccessControlEnumerable).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev Returns one of the accounts that have `role`. `index` must be a\n   * value between 0 and {getRoleMemberCount}, non-inclusive.\n   *\n   * Role bearers are not sorted in any particular way, and their ordering may\n   * change at any point.\n   *\n   * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n   * you perform all queries on the same block. See the following\n   * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n   * for more information.\n   */\n  function getRoleMember(bytes32 role, uint256 index)\n    public\n    view\n    virtual\n    override\n    returns (address)\n  {\n    return _roleMembers[role].at(index);\n  }\n\n  /**\n   * @dev Returns the number of accounts that have `role`. Can be used\n   * together with {getRoleMember} to enumerate all bearers of a role.\n   */\n  function getRoleMemberCount(bytes32 role)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _roleMembers[role].length();\n  }\n\n  /**\n   * @dev Overload {_grantRole} to track enumerable memberships\n   */\n  function _grantRole(bytes32 role, address account) internal virtual override {\n    super._grantRole(role, account);\n    _roleMembers[role].add(account);\n  }\n\n  /**\n   * @dev Overload {_revokeRole} to track enumerable memberships\n   */\n  function _revokeRole(bytes32 role, address account)\n    internal\n    virtual\n    override\n  {\n    super._revokeRole(role, account);\n    _roleMembers[role].remove(account);\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n  // Booleans are more expensive than uint256 or any type that takes up a full\n  // word because each write operation emits an extra SLOAD to first read the\n  // slot's contents, replace the bits taken up by the boolean, and then write\n  // back. This is the compiler's defense against contract upgrades and\n  // pointer aliasing, and it cannot be disabled.\n\n  // The values being non-zero value makes deployment a bit more expensive,\n  // but in exchange the refund on every call to nonReentrant will be lower in\n  // amount. Since refunds are capped to a percentage of the total\n  // transaction's gas, it is best to keep them low in cases like this one, to\n  // increase the likelihood of the full refund coming into effect.\n  uint256 private constant _NOT_ENTERED = 1;\n  uint256 private constant _ENTERED = 2;\n\n  uint256 private _status;\n\n  constructor() {\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   *\n   * [IMPORTANT]\n   * ====\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\n   *\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n   * constructor.\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(\n      success,\n      \"Address: unable to send value, recipient may have reverted\"\n    );\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n   * plain `call` is an unsafe replacement for a function call: use this\n   * function instead.\n   *\n   * If `target` reverts with a revert reason, it is bubbled up by this\n   * function (like regular Solidity function calls).\n   *\n   * Returns the raw returned data. To convert to the expected return value,\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n   *\n   * Requirements:\n   *\n   * - `target` must be a contract.\n   * - calling `target` with `data` must not revert.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(address target, bytes memory data)\n    internal\n    returns (bytes memory)\n  {\n    return functionCall(target, data, \"Address: low-level call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n   * `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but also transferring `value` wei to `target`.\n   *\n   * Requirements:\n   *\n   * - the calling contract must have an ETH balance of at least `value`.\n   * - the called Solidity function must be `payable`.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return\n      functionCallWithValue(\n        target,\n        data,\n        value,\n        \"Address: low-level call with value failed\"\n      );\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(\n      address(this).balance >= value,\n      \"Address: insufficient balance for call\"\n    );\n    require(isContract(target), \"Address: call to non-contract\");\n\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(address target, bytes memory data)\n    internal\n    view\n    returns (bytes memory)\n  {\n    return\n      functionStaticCall(target, data, \"Address: low-level static call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    require(isContract(target), \"Address: static call to non-contract\");\n\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(address target, bytes memory data)\n    internal\n    returns (bytes memory)\n  {\n    return\n      functionDelegateCall(\n        target,\n        data,\n        \"Address: low-level delegate call failed\"\n      );\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(isContract(target), \"Address: delegate call to non-contract\");\n\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n   * revert reason using the provided one.\n   *\n   * _Available since v4.3._\n   */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts/access/IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n  /**\n   * @dev Returns one of the accounts that have `role`. `index` must be a\n   * value between 0 and {getRoleMemberCount}, non-inclusive.\n   *\n   * Role bearers are not sorted in any particular way, and their ordering may\n   * change at any point.\n   *\n   * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n   * you perform all queries on the same block. See the following\n   * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n   * for more information.\n   */\n  function getRoleMember(bytes32 role, uint256 index)\n    external\n    view\n    returns (address);\n\n  /**\n   * @dev Returns the number of accounts that have `role`. Can be used\n   * together with {getRoleMember} to enumerate all bearers of a role.\n   */\n  function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "contracts/external/openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"contracts/external/openzeppelin/contracts/utils/Context.sol\";\nimport \"contracts/external/openzeppelin/contracts/utils/Strings.sol\";\nimport \"contracts/external/openzeppelin/contracts/utils/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n  struct RoleData {\n    mapping(address => bool) members;\n    bytes32 adminRole;\n  }\n\n  mapping(bytes32 => RoleData) private _roles;\n\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n  /**\n   * @dev Modifier that checks that an account has a specific role. Reverts\n   * with a standardized message including the required role.\n   *\n   * The format of the revert reason is given by the following regular expression:\n   *\n   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n   *\n   * _Available since v4.1._\n   */\n  modifier onlyRole(bytes32 role) {\n    _checkRole(role, _msgSender());\n    _;\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return\n      interfaceId == type(IAccessControl).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev Returns `true` if `account` has been granted `role`.\n   */\n  function hasRole(bytes32 role, address account)\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return _roles[role].members[account];\n  }\n\n  /**\n   * @dev Revert with a standard message if `account` is missing `role`.\n   *\n   * The format of the revert reason is given by the following regular expression:\n   *\n   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n   */\n  function _checkRole(bytes32 role, address account) internal view virtual {\n    if (!hasRole(role, account)) {\n      revert(\n        string(\n          abi.encodePacked(\n            \"AccessControl: account \",\n            Strings.toHexString(uint160(account), 20),\n            \" is missing role \",\n            Strings.toHexString(uint256(role), 32)\n          )\n        )\n      );\n    }\n  }\n\n  /**\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\n   * {revokeRole}.\n   *\n   * To change a role's admin, use {_setRoleAdmin}.\n   */\n  function getRoleAdmin(bytes32 role)\n    public\n    view\n    virtual\n    override\n    returns (bytes32)\n  {\n    return _roles[role].adminRole;\n  }\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function grantRole(bytes32 role, address account)\n    public\n    virtual\n    override\n    onlyRole(getRoleAdmin(role))\n  {\n    _grantRole(role, account);\n  }\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function revokeRole(bytes32 role, address account)\n    public\n    virtual\n    override\n    onlyRole(getRoleAdmin(role))\n  {\n    _revokeRole(role, account);\n  }\n\n  /**\n   * @dev Revokes `role` from the calling account.\n   *\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\n   * purpose is to provide a mechanism for accounts to lose their privileges\n   * if they are compromised (such as when a trusted device is misplaced).\n   *\n   * If the calling account had been revoked `role`, emits a {RoleRevoked}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must be `account`.\n   */\n  function renounceRole(bytes32 role, address account) public virtual override {\n    require(\n      account == _msgSender(),\n      \"AccessControl: can only renounce roles for self\"\n    );\n\n    _revokeRole(role, account);\n  }\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event. Note that unlike {grantRole}, this function doesn't perform any\n   * checks on the calling account.\n   *\n   * [WARNING]\n   * ====\n   * This function should only be called from the constructor when setting\n   * up the initial roles for the system.\n   *\n   * Using this function in any other way is effectively circumventing the admin\n   * system imposed by {AccessControl}.\n   * ====\n   *\n   * NOTE: This function is deprecated in favor of {_grantRole}.\n   */\n  function _setupRole(bytes32 role, address account) internal virtual {\n    _grantRole(role, account);\n  }\n\n  /**\n   * @dev Sets `adminRole` as ``role``'s admin role.\n   *\n   * Emits a {RoleAdminChanged} event.\n   */\n  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n    bytes32 previousAdminRole = getRoleAdmin(role);\n    _roles[role].adminRole = adminRole;\n    emit RoleAdminChanged(role, previousAdminRole, adminRole);\n  }\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * Internal function without access restriction.\n   */\n  function _grantRole(bytes32 role, address account) internal virtual {\n    if (!hasRole(role, account)) {\n      _roles[role].members[account] = true;\n      emit RoleGranted(role, account, _msgSender());\n    }\n  }\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * Internal function without access restriction.\n   */\n  function _revokeRole(bytes32 role, address account) internal virtual {\n    if (hasRole(role, account)) {\n      _roles[role].members[account] = false;\n      emit RoleRevoked(role, account, _msgSender());\n    }\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n  // To implement this library for multiple types with as little code\n  // repetition as possible, we write it in terms of a generic Set type with\n  // bytes32 values.\n  // The Set implementation uses private functions, and user-facing\n  // implementations (such as AddressSet) are just wrappers around the\n  // underlying Set.\n  // This means that we can only create new EnumerableSets for types that fit\n  // in bytes32.\n\n  struct Set {\n    // Storage of set values\n    bytes32[] _values;\n    // Position of the value in the `values` array, plus 1 because index 0\n    // means a value is not in the set.\n    mapping(bytes32 => uint256) _indexes;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function _add(Set storage set, bytes32 value) private returns (bool) {\n    if (!_contains(set, value)) {\n      set._values.push(value);\n      // The value is stored at length-1, but we add 1 to all indexes\n      // and use 0 as a sentinel value\n      set._indexes[value] = set._values.length;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\n    // We read and store the value's index to prevent multiple reads from the same storage slot\n    uint256 valueIndex = set._indexes[value];\n\n    if (valueIndex != 0) {\n      // Equivalent to contains(set, value)\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\n      // This modifies the order of the array, as noted in {at}.\n\n      uint256 toDeleteIndex = valueIndex - 1;\n      uint256 lastIndex = set._values.length - 1;\n\n      if (lastIndex != toDeleteIndex) {\n        bytes32 lastvalue = set._values[lastIndex];\n\n        // Move the last value to the index where the value to delete is\n        set._values[toDeleteIndex] = lastvalue;\n        // Update the index for the moved value\n        set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n      }\n\n      // Delete the slot where the moved value was stored\n      set._values.pop();\n\n      // Delete the index for the deleted slot\n      delete set._indexes[value];\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function _contains(Set storage set, bytes32 value)\n    private\n    view\n    returns (bool)\n  {\n    return set._indexes[value] != 0;\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n   */\n  function _length(Set storage set) private view returns (uint256) {\n    return set._values.length;\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\n    return set._values[index];\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function _values(Set storage set) private view returns (bytes32[] memory) {\n    return set._values;\n  }\n\n  // Bytes32Set\n\n  struct Bytes32Set {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _add(set._inner, value);\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(Bytes32Set storage set, bytes32 value)\n    internal\n    returns (bool)\n  {\n    return _remove(set._inner, value);\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(Bytes32Set storage set, bytes32 value)\n    internal\n    view\n    returns (bool)\n  {\n    return _contains(set._inner, value);\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(Bytes32Set storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(Bytes32Set storage set, uint256 index)\n    internal\n    view\n    returns (bytes32)\n  {\n    return _at(set._inner, index);\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(Bytes32Set storage set)\n    internal\n    view\n    returns (bytes32[] memory)\n  {\n    return _values(set._inner);\n  }\n\n  // AddressSet\n\n  struct AddressSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(AddressSet storage set, address value) internal returns (bool) {\n    return _add(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(AddressSet storage set, address value)\n    internal\n    returns (bool)\n  {\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(AddressSet storage set, address value)\n    internal\n    view\n    returns (bool)\n  {\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(AddressSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(AddressSet storage set, uint256 index)\n    internal\n    view\n    returns (address)\n  {\n    return address(uint160(uint256(_at(set._inner, index))));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(AddressSet storage set)\n    internal\n    view\n    returns (address[] memory)\n  {\n    bytes32[] memory store = _values(set._inner);\n    address[] memory result;\n\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // UintSet\n\n  struct UintSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\n    return _add(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\n    return _remove(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(UintSet storage set, uint256 value)\n    internal\n    view\n    returns (bool)\n  {\n    return _contains(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n   */\n  function length(UintSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(UintSet storage set, uint256 index)\n    internal\n    view\n    returns (uint256)\n  {\n    return uint256(_at(set._inner, index));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(UintSet storage set)\n    internal\n    view\n    returns (uint256[] memory)\n  {\n    bytes32[] memory store = _values(set._inner);\n    uint256[] memory result;\n\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n  /**\n   * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n   *\n   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n   * {RoleAdminChanged} not being emitted signaling this.\n   *\n   * _Available since v3.1._\n   */\n  event RoleAdminChanged(\n    bytes32 indexed role,\n    bytes32 indexed previousAdminRole,\n    bytes32 indexed newAdminRole\n  );\n\n  /**\n   * @dev Emitted when `account` is granted `role`.\n   *\n   * `sender` is the account that originated the contract call, an admin role\n   * bearer except when using {AccessControl-_setupRole}.\n   */\n  event RoleGranted(\n    bytes32 indexed role,\n    address indexed account,\n    address indexed sender\n  );\n\n  /**\n   * @dev Emitted when `account` is revoked `role`.\n   *\n   * `sender` is the account that originated the contract call:\n   *   - if using `revokeRole`, it is the admin role bearer\n   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n   */\n  event RoleRevoked(\n    bytes32 indexed role,\n    address indexed account,\n    address indexed sender\n  );\n\n  /**\n   * @dev Returns `true` if `account` has been granted `role`.\n   */\n  function hasRole(bytes32 role, address account) external view returns (bool);\n\n  /**\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\n   * {revokeRole}.\n   *\n   * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n   */\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function grantRole(bytes32 role, address account) external;\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function revokeRole(bytes32 role, address account) external;\n\n  /**\n   * @dev Revokes `role` from the calling account.\n   *\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\n   * purpose is to provide a mechanism for accounts to lose their privileges\n   * if they are compromised (such as when a trusted device is misplaced).\n   *\n   * If the calling account had been granted `role`, emits a {RoleRevoked}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must be `account`.\n   */\n  function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/external/openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n  bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n   */\n  function toString(uint256 value) internal pure returns (string memory) {\n    // Inspired by OraclizeAPI's implementation - MIT licence\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n    if (value == 0) {\n      return \"0\";\n    }\n    uint256 temp = value;\n    uint256 digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n   */\n  function toHexString(uint256 value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0x00\";\n    }\n    uint256 temp = value;\n    uint256 length = 0;\n    while (temp != 0) {\n      length++;\n      temp >>= 8;\n    }\n    return toHexString(value, length);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n   */\n  function toHexString(uint256 value, uint256 length)\n    internal\n    pure\n    returns (string memory)\n  {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = \"0\";\n    buffer[1] = \"x\";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = _HEX_SYMBOLS[value & 0xf];\n      value >>= 4;\n    }\n    require(value == 0, \"Strings: hex length insufficient\");\n    return string(buffer);\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts/utils/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts/utils/IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return interfaceId == type(IERC165).interfaceId;\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts/utils/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30 000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/usdy/USDYManager.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\n\npragma solidity 0.8.16;\n\nimport \"contracts/RWAHubOffChainRedemptions.sol\";\nimport \"contracts/usdy/blocklist/BlocklistClient.sol\";\nimport \"contracts/sanctions/SanctionsListClient.sol\";\nimport \"contracts/interfaces/IUSDYManager.sol\";\n\ncontract USDYManager is\n  RWAHubOffChainRedemptions,\n  BlocklistClient,\n  SanctionsListClient,\n  IUSDYManager\n{\n  bytes32 public constant TIMESTAMP_SETTER_ROLE =\n    keccak256(\"TIMESTAMP_SETTER_ROLE\");\n\n  mapping(bytes32 => uint256) public depositIdToClaimableTimestamp;\n\n  constructor(\n    address _collateral,\n    address _rwa,\n    address managerAdmin,\n    address pauser,\n    address _assetSender,\n    address _feeRecipient,\n    uint256 _minimumDepositAmount,\n    uint256 _minimumRedemptionAmount,\n    address blocklist,\n    address sanctionsList\n  )\n    RWAHubOffChainRedemptions(\n      _collateral,\n      _rwa,\n      managerAdmin,\n      pauser,\n      _assetSender,\n      _feeRecipient,\n      _minimumDepositAmount,\n      _minimumRedemptionAmount\n    )\n    BlocklistClient(blocklist)\n    SanctionsListClient(sanctionsList)\n  {}\n\n  /**\n   * @notice Function to enforce blocklist and sanctionslist restrictions to be\n   *         implemented on calls to `requestSubscription` and\n   *         `claimRedemption`\n   *\n   * @param account The account to check blocklist and sanctions list status\n   *                for\n   */\n  function _checkRestrictions(address account) internal view override {\n    if (_isBlocked(account)) {\n      revert BlockedAccount();\n    }\n    if (_isSanctioned(account)) {\n      revert SanctionedAccount();\n    }\n  }\n\n  /**\n   * @notice Internal hook that is called by `claimMint` to enforce the time\n   *         at which a user can claim their USDY\n   *\n   * @param depositId The depositId to check the claimable timestamp for\n   *\n   * @dev This function will call the `_claimMint` function in the parent\n   *      once USDY-specific checks have been made\n   */\n  function _claimMint(bytes32 depositId) internal virtual override {\n    if (depositIdToClaimableTimestamp[depositId] == 0) {\n      revert ClaimableTimestampNotSet();\n    }\n\n    if (depositIdToClaimableTimestamp[depositId] > block.timestamp) {\n      revert MintNotYetClaimable();\n    }\n\n    super._claimMint(depositId);\n    delete depositIdToClaimableTimestamp[depositId];\n  }\n\n  /**\n   * @notice Update blocklist address\n   *\n   * @param blocklist The new blocklist address\n   */\n  function setBlocklist(\n    address blocklist\n  ) external override onlyRole(MANAGER_ADMIN) {\n    _setBlocklist(blocklist);\n  }\n\n  /**\n   * @notice Update sanctions list address\n   *\n   * @param sanctionsList The new sanctions list address\n   */\n  function setSanctionsList(\n    address sanctionsList\n  ) external override onlyRole(MANAGER_ADMIN) {\n    _setSanctionsList(sanctionsList);\n  }\n\n  /**\n   * @notice Set the claimable timestamp for a list of depositIds\n   *\n   * @param claimTimestamp The timestamp at which the deposit can be claimed\n   * @param depositIds The depositIds to set the claimable timestamp for\n   */\n  function setClaimableTimestamp(\n    uint256 claimTimestamp,\n    bytes32[] calldata depositIds\n  ) external onlyRole(TIMESTAMP_SETTER_ROLE) {\n    if (claimTimestamp < block.timestamp) {\n      revert ClaimableTimestampInPast();\n    }\n\n    uint256 depositsSize = depositIds.length;\n    for (uint256 i; i < depositsSize; ++i) {\n      depositIdToClaimableTimestamp[depositIds[i]] = claimTimestamp;\n      emit ClaimableTimestampSet(claimTimestamp, depositIds[i]);\n    }\n  }\n}\n"
    },
    "contracts/usdy/blocklist/BlocklistClient.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IBlocklist.sol\";\nimport \"contracts/interfaces/IBlocklistClient.sol\";\n\n/**\n * @title BlocklistClient\n * @author Ondo Finance\n * @notice This abstract contract manages state for blocklist clients\n */\nabstract contract BlocklistClient is IBlocklistClient {\n  // blocklist address\n  IBlocklist public override blocklist;\n\n  /**\n   * @notice Constructor\n   *\n   * @param _blocklist Address of the blocklist contract\n   */\n  constructor(address _blocklist) {\n    _setBlocklist(_blocklist);\n  }\n\n  /**\n   * @notice Sets the blocklist address for this client\n   *\n   * @param _blocklist The new blocklist address\n   */\n  function _setBlocklist(address _blocklist) internal {\n    if (_blocklist == address(0)) {\n      revert BlocklistZeroAddress();\n    }\n    address oldBlocklist = address(blocklist);\n    blocklist = IBlocklist(_blocklist);\n    emit BlocklistSet(oldBlocklist, _blocklist);\n  }\n\n  /**\n   * @notice Checks whether an address has been blocked\n   *\n   * @param account The account to check\n   */\n  function _isBlocked(address account) internal view returns (bool) {\n    return blocklist.isBlocked(account);\n  }\n}\n"
    },
    "contracts/sanctions/SanctionsListClient.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/external/chainalysis/ISanctionsList.sol\";\nimport \"contracts/sanctions/ISanctionsListClient.sol\";\n\n/**\n * @title SanctionsListClient\n * @author Ondo Finance\n * @notice This abstract contract manages state required for clients\n *         of the sanctions list\n */\nabstract contract SanctionsListClient is ISanctionsListClient {\n  // Sanctions list address\n  ISanctionsList public override sanctionsList;\n\n  /**\n   * @notice Constructor\n   *\n   * @param _sanctionsList Address of the sanctions list contract\n   */\n  constructor(address _sanctionsList) {\n    _setSanctionsList(_sanctionsList);\n  }\n\n  /**\n   * @notice Sets the sanctions list address for this client\n   *\n   * @param _sanctionsList The new sanctions list address\n   */\n  function _setSanctionsList(address _sanctionsList) internal {\n    if (_sanctionsList == address(0)) {\n      revert SanctionsListZeroAddress();\n    }\n    address oldSanctionsList = address(sanctionsList);\n    sanctionsList = ISanctionsList(_sanctionsList);\n    emit SanctionsListSet(oldSanctionsList, _sanctionsList);\n  }\n\n  /**\n   * @notice Checks whether an address has been sanctioned\n   *\n   * @param account The account to check\n   */\n  function _isSanctioned(address account) internal view returns (bool) {\n    return sanctionsList.isSanctioned(account);\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/interfaces/IUSDYManager.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n */\npragma solidity 0.8.16;\n\ninterface IUSDYManager {\n  function setClaimableTimestamp(\n    uint256 claimDate,\n    bytes32[] calldata depositIds\n  ) external;\n\n  /**\n   * @notice Event emitted when claimable timestamp is set\n   *\n   * @param claimTimestamp The timestamp at which the mint can be claimed\n   * @param depositId      The depositId that can claim at the given \n                           `claimTimestamp`\n   */\n  event ClaimableTimestampSet(\n    uint256 indexed claimTimestamp,\n    bytes32 indexed depositId\n  );\n\n  /// ERRORS ///\n  error MintNotYetClaimable();\n  error ClaimableTimestampInPast();\n  error ClaimableTimestampNotSet();\n}\n"
    },
    "contracts/interfaces/IBlocklist.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\ninterface IBlocklist {\n  function addToBlocklist(address[] calldata accounts) external;\n\n  function removeFromBlocklist(address[] calldata accounts) external;\n\n  function isBlocked(address account) external view returns (bool);\n\n  /**\n   * @notice Event emitted when addresses are added to the blocklist\n   *\n   * @param accounts The addresses that were added to the blocklist\n   */\n  event BlockedAddressesAdded(address[] accounts);\n\n  /**\n   * @notice Event emitted when addresses are removed from the blocklist\n   *\n   * @param accounts The addresses that were removed from the blocklist\n   */\n  event BlockedAddressesRemoved(address[] accounts);\n}\n"
    },
    "contracts/interfaces/IBlocklistClient.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IBlocklist.sol\";\n\n/**\n * @title IBlocklistClient\n * @author Ondo Finance\n * @notice The client interface for the Blocklist contract.\n */\ninterface IBlocklistClient {\n  /// @notice Returns reference to the blocklist that this client queries\n  function blocklist() external view returns (IBlocklist);\n\n  /// @notice Sets the blocklist reference\n  function setBlocklist(address registry) external;\n\n  /// @notice Error for when caller attempts to set the blocklist reference\n  ///         to the zero address\n  error BlocklistZeroAddress();\n\n  /// @notice Error for when caller attempts to perform action on a blocked\n  ///         account\n  error BlockedAccount();\n\n  /**\n   * @dev Event for when the blocklist reference is set\n   *\n   * @param oldBlocklist The old blocklist\n   * @param newBlocklist The new blocklist\n   */\n  event BlocklistSet(address oldBlocklist, address newBlocklist);\n}\n"
    },
    "contracts/external/chainalysis/ISanctionsList.sol": {
      "content": "/// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.16;\n\ninterface ISanctionsList {\n  function isSanctioned(address addr) external view returns (bool);\n}\n"
    },
    "contracts/sanctions/ISanctionsListClient.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/external/chainalysis/ISanctionsList.sol\";\n\n/**\n * @title ISanctionsListClient\n * @author Ondo Finance\n * @notice The client interface for sanctions contract.\n */\ninterface ISanctionsListClient {\n  /// @notice Returns reference to the sanctions list that this client queries\n  function sanctionsList() external view returns (ISanctionsList);\n\n  /// @notice Sets the sanctions list reference\n  function setSanctionsList(address sanctionsList) external;\n\n  /// @notice Error for when caller attempts to set the `sanctionsList`\n  ///         reference to the zero address\n  error SanctionsListZeroAddress();\n\n  /// @notice Error for when caller attempts to perform an action on a\n  ///         sanctioned account\n  error SanctionedAccount();\n\n  /**\n   * @dev Event for when the sanctions list reference is set\n   *\n   * @param oldSanctionsList The old list\n   * @param newSanctionsList The new list\n   */\n  event SanctionsListSet(address oldSanctionsList, address newSanctionsList);\n}\n"
    },
    "contracts/ommf/ommfManager.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\n\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IWommf.sol\";\nimport \"contracts/kyc/KYCRegistryClient.sol\";\nimport \"contracts/RWAHubInstantMints.sol\";\n\ncontract OMMFManager is RWAHubInstantMints, KYCRegistryClient {\n  /// @notice `rwa` variable is OMMF token contract\n  IWOMMF public immutable wommf;\n  bytes32 public constant REDEMPTION_PROVER_ROLE =\n    keccak256(\"REDEMPTION_PROVER_ROLE\");\n\n  constructor(\n    address _collateral,\n    address _rwa,\n    address managerAdmin,\n    address pauser,\n    address _assetSender,\n    address _feeRecipient,\n    uint256 _minimumDepositAmount,\n    uint256 _minimumRedemptionAmount,\n    address _instantMintAssetManager,\n    address _kycRegistry,\n    uint256 _kycRequirementGroup,\n    address _wommf\n  )\n    RWAHubInstantMints(\n      _collateral,\n      _rwa,\n      managerAdmin,\n      pauser,\n      _assetSender,\n      _feeRecipient,\n      _minimumDepositAmount,\n      _minimumRedemptionAmount,\n      _instantMintAssetManager\n    )\n  {\n    _setKYCRegistry(_kycRegistry);\n    _setKYCRequirementGroup(_kycRequirementGroup);\n    wommf = IWOMMF(_wommf);\n    _setRoleAdmin(REDEMPTION_PROVER_ROLE, MANAGER_ADMIN);\n  }\n\n  /**\n   * @notice Function to add a redemption proof to the contract\n   *\n   * @param txHash           The tx hash (redemption Id) of the redemption\n   * @param user             The address of the user who made the redemption\n   * @param rwaAmountToBurn  The amount of OMMF burned\n   * @param timestamp        The timestamp of the redemption request\n   */\n  function addRedemptionProof(\n    bytes32 txHash,\n    address user,\n    uint256 rwaAmountToBurn,\n    uint256 timestamp\n  ) external onlyRole(REDEMPTION_PROVER_ROLE) checkRestrictions(user) {\n    if (redemptionIdToRedeemer[txHash].user != address(0)) {\n      revert RedemptionProofAlreadyExists();\n    }\n    if (rwaAmountToBurn == 0) {\n      revert RedemptionTooSmall();\n    }\n    if (user == address(0)) {\n      revert RedeemerNull();\n    }\n    rwa.burnFrom(msg.sender, rwaAmountToBurn);\n    redemptionIdToRedeemer[txHash] = Redeemer(user, rwaAmountToBurn, 0);\n\n    emit RedemptionProofAdded(txHash, user, rwaAmountToBurn, timestamp);\n  }\n\n  /**\n   * @notice Function to claim a subscription request in wrapped rwa\n   *         token\n   *\n   * @param depositIds The depositIds to be claimed\n   */\n  function claimMint_wOMMF(\n    bytes32[] memory depositIds\n  ) external nonReentrant ifNotPaused(subscriptionPaused) {\n    uint256 cacheLength = depositIds.length;\n    for (uint256 i; i < cacheLength; ++i) {\n      // Get depositor\n      Depositor memory depositor = depositIdToDepositor[depositIds[i]];\n\n      // Check if the depositor is valid\n      if (depositor.priceId == 0) {\n        revert PriceIdNotSet();\n      }\n\n      // Get price and rwaOwed based on priceId\n      uint256 price = pricer.getPrice(depositor.priceId);\n      uint256 rwaOwed = _getMintAmountForPrice(\n        depositor.amountDepositedMinusFees,\n        price\n      );\n\n      // Clean up storage and mint\n      delete depositIdToDepositor[depositIds[i]];\n      rwa.mint(address(this), rwaOwed);\n\n      // Wrap and transfer wOMMF\n      rwa.approve(address(wommf), rwaOwed);\n      wommf.wrap(rwaOwed);\n      uint256 wRwaOwed = wommf.getwOMMFByOMMF(rwaOwed);\n      wommf.transfer(depositor.user, wRwaOwed);\n\n      emit WrappedMintCompleted(\n        depositor.user,\n        depositIds[i],\n        rwaOwed,\n        wRwaOwed,\n        depositor.amountDepositedMinusFees,\n        price\n      );\n    }\n  }\n\n  /**\n   * @notice Function to request a redemption in instances when the user would\n   *         like to burn the wrapped rwa token\n   *\n   * @param amount The amount of wrapped rwa that the user would like to burn\n   */\n  function requestRedemption_wOMMF(\n    uint256 amount\n  ) external nonReentrant ifNotPaused(redemptionPaused) {\n    uint256 ommfAmount = wommf.getOMMFbywOMMF(amount);\n    if (ommfAmount < minimumRedemptionAmount) {\n      revert RedemptionTooSmall();\n    }\n\n    // Transfer and unwrap\n    wommf.transferFrom(msg.sender, address(this), amount);\n    wommf.unwrap(amount);\n\n    bytes32 redemptionId = bytes32(redemptionRequestCounter++);\n    redemptionIdToRedeemer[redemptionId] = Redeemer(msg.sender, amount, 0);\n\n    rwa.burn(ommfAmount);\n\n    emit WrappedRedemptionRequested(\n      msg.sender,\n      redemptionId,\n      ommfAmount,\n      amount\n    );\n  }\n\n  /**\n   * @notice Function to enforce KYC/AML requirements that will\n   *         be implemented on calls to `requestSubscription` and\n   *         `claimRedemption`\n   *\n   * @param account The account that we would like to check the KYC\n   *                status for\n   */\n  function _checkRestrictions(address account) internal view override {\n    // Check Basic KYC requirements for OMMF\n    if (!_getKYCStatus(account)) {\n      revert KYCCheckFailed();\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        KYC Registry Utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Update KYC group of the contract for which\n   *         accounts are checked against\n   *\n   * @param _kycRequirementGroup The new KYC requirement group\n   */\n  function setKYCRequirementGroup(\n    uint256 _kycRequirementGroup\n  ) external onlyRole(MANAGER_ADMIN) {\n    _setKYCRequirementGroup(_kycRequirementGroup);\n  }\n\n  /**\n   * @notice Update KYC registry address\n   *\n   * @param _kycRegistry The new KYC registry address\n   */\n  function setKYCRegistry(\n    address _kycRegistry\n  ) external onlyRole(MANAGER_ADMIN) {\n    _setKYCRegistry(_kycRegistry);\n  }\n\n  /**\n   * @notice Event emitted when a Mint request is completed\n   *\n   * @param user                      The address of the user getting the funds\n   * @param depositId                 The deposit Id for the subscription request\n   * @param rwaAmountOut              The amount of RWA token minted to the\n   *                                  user\n   * @param wRWAAmountOut             The amount of wrapped RWA token minted\n   * @param collateralAmountDeposited The amount of collateral deposited\n   * @param price                     The price set for the depositId\n   */\n  event WrappedMintCompleted(\n    address indexed user,\n    bytes32 indexed depositId,\n    uint256 rwaAmountOut,\n    uint256 wRWAAmountOut,\n    uint256 collateralAmountDeposited,\n    uint256 price\n  );\n\n  /**\n   * @notice Event emitted when a Redemption request is completed\n   *\n   * @param user               The address of the user\n   * @param redemptionId       The redemption Id for a given redemption\n   *                           request\n   * @param rwaAmountIn        The amount of rwa being redeemed\n   * @param wrappedRwaAmountIn The amount of wrapped rwa to convert to rwa\n   */\n  event WrappedRedemptionRequested(\n    address indexed user,\n    bytes32 indexed redemptionId,\n    uint256 rwaAmountIn,\n    uint256 wrappedRwaAmountIn\n  );\n\n  /**\n   * @notice Event emitted when redemption proof has been added\n   *\n   * @param txHash                Tx hash (redemption id) of the redemption transfer\n   * @param user                  Address of the user who made the redemption\n   * @param rwaAmountBurned       Amount of OMMF burned\n   * @param timestamp             Timestamp of the redemption\n   */\n  event RedemptionProofAdded(\n    bytes32 indexed txHash,\n    address indexed user,\n    uint256 rwaAmountBurned,\n    uint256 timestamp\n  );\n\n  error KYCCheckFailed();\n}\n"
    },
    "contracts/interfaces/IWommf.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\n\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\n\npragma solidity 0.8.16; // latest available for using OZ\n\ninterface IWOMMF is IERC20 {\n  function wrap(uint256 _OMMFAmount) external;\n\n  function unwrap(uint256 _wOMMFAmount) external;\n\n  function getwOMMFByOMMF(uint256 _OMMFAmount) external view returns (uint256);\n\n  function getOMMFbywOMMF(uint256 _wOMMFAmount) external view returns (uint256);\n}\n"
    },
    "contracts/kyc/KYCRegistryClient.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/kyc/IKYCRegistry.sol\";\nimport \"contracts/kyc/IKYCRegistryClient.sol\";\n\n/**\n * @title KYCRegistryClient\n * @author Ondo Finance\n * @notice This abstract contract manages state required for clients\n *         of the KYC registry.\n */\nabstract contract KYCRegistryClient is IKYCRegistryClient {\n  // KYC Registry address\n  IKYCRegistry public override kycRegistry;\n  // KYC requirement group\n  uint256 public override kycRequirementGroup;\n\n  /**\n   * @notice Sets the KYC registry address for this client\n   *\n   * @param _kycRegistry The new KYC registry address\n   */\n  function _setKYCRegistry(address _kycRegistry) internal {\n    if (_kycRegistry == address(0)) {\n      revert RegistryZeroAddress();\n    }\n    address oldKYCRegistry = address(kycRegistry);\n    kycRegistry = IKYCRegistry(_kycRegistry);\n    emit KYCRegistrySet(oldKYCRegistry, _kycRegistry);\n  }\n\n  /**\n   * @notice Sets the KYC registry requirement group for this\n   *         client to check kyc status for\n   *\n   * @param _kycRequirementGroup The new KYC group\n   */\n  function _setKYCRequirementGroup(uint256 _kycRequirementGroup) internal {\n    uint256 oldKYCLevel = kycRequirementGroup;\n    kycRequirementGroup = _kycRequirementGroup;\n    emit KYCRequirementGroupSet(oldKYCLevel, _kycRequirementGroup);\n  }\n\n  /**\n   * @notice Checks whether an address has been KYC'd\n   *\n   * @param account The address to check\n   */\n  function _getKYCStatus(address account) internal view returns (bool) {\n    return kycRegistry.getKYCStatus(kycRequirementGroup, account);\n  }\n\n  function _getKYCStateDirect(address account) internal view returns (bool) {\n    return kycRegistry.kycState(kycRequirementGroup, account);\n  }\n}\n"
    },
    "contracts/RWAHubInstantMints.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\n\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IRWAHubInstantMints.sol\";\nimport \"contracts/RWAHubOffChainRedemptions.sol\";\nimport \"contracts/InstantMintTimeBasedRateLimiter.sol\";\n\nabstract contract RWAHubInstantMints is\n  IRWAHubInstantMints,\n  RWAHubOffChainRedemptions,\n  InstantMintTimeBasedRateLimiter\n{\n  using SafeERC20 for IERC20;\n\n  // Fee collected when instant minting OMMF (in basis points)\n  uint256 public instantMintFee = 10;\n\n  // Fee collected when instant redeeming OMMF (in basis points)\n  uint256 public instantRedemptionFee = 10;\n\n  // priceId associated with instantMints\n  uint256 public instantMintPriceId;\n\n  // priceId associated with instantRedemptions\n  uint256 public instantRedemptionPriceId;\n\n  // Flag whether instantMint is paused\n  bool public instantMintPaused = true;\n\n  // Flag whether instantRedemption is paused\n  bool public instantRedemptionPaused = true;\n\n  // Address to manage instant mints/redemptions\n  address public instantMintAssetManager;\n\n  constructor(\n    address _collateral,\n    address _rwa,\n    address managerAdmin,\n    address pauser,\n    address _assetSender,\n    address _feeRecipient,\n    uint256 _minimumDepositAmount,\n    uint256 _minimumRedemptionAmount,\n    address _instantMintAssetManager\n  )\n    RWAHubOffChainRedemptions(\n      _collateral,\n      _rwa,\n      managerAdmin,\n      pauser,\n      _assetSender,\n      _feeRecipient,\n      _minimumDepositAmount,\n      _minimumRedemptionAmount\n    )\n    InstantMintTimeBasedRateLimiter(0, 0, 0, 0)\n  {\n    instantMintAssetManager = _instantMintAssetManager;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                  Instant Mint/Redemption Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Instant mints `rwa` token to the caller in exchange for\n   *         `collateral`\n   *\n   * @param amount The amount of `collateral` to deposit\n   *\n   * @dev All fees are deducted from amount transferred by\n   *      `instantMintAssetManager`\n   */\n  function instantMint(\n    uint256 amount\n  ) external nonReentrant ifNotPaused(instantMintPaused) {\n    if (amount < minimumDepositAmount) {\n      revert DepositTooSmall();\n    }\n\n    if (instantMintPriceId == 0) {\n      revert PriceIdNotSet();\n    }\n\n    // Calculate fees\n    uint256 feesInCollateral = _getInstantMintFees(amount);\n    uint256 depositAmountAfterFee = amount - feesInCollateral;\n\n    // Transfer collateral\n    collateral.safeTransferFrom(msg.sender, instantMintAssetManager, amount);\n\n    // Calculate mint amount\n    uint256 price = pricer.getPrice(instantMintPriceId);\n    uint256 rwaOwed = _getMintAmountForPrice(depositAmountAfterFee, price);\n\n    // Check mint limit\n    _checkAndUpdateInstantMintLimit(rwaOwed);\n\n    // Mint RWA\n    rwa.mint(msg.sender, rwaOwed);\n\n    emit InstantMintCompleted(\n      msg.sender,\n      amount,\n      depositAmountAfterFee,\n      feesInCollateral,\n      rwaOwed,\n      price\n    );\n  }\n\n  /**\n   * @notice Instant mints `rwa` token to the caller in exchange for\n   *         `collateral`\n   *\n   * @param amount The amount of `collateral` to deposit\n   *\n   * @dev All fees are deducted from collateral transferred by\n   *      `instantMintAssetManager`\n   */\n  function instantRedemption(\n    uint256 amount\n  ) external nonReentrant ifNotPaused(instantRedemptionPaused) {\n    // Checks\n    if (amount < minimumRedemptionAmount) {\n      revert RedemptionTooSmall();\n    }\n\n    if (instantRedemptionPriceId == 0) {\n      revert PriceIdNotSet();\n    }\n\n    // Update instant redemption limit\n    _checkAndUpdateInstantRedemptionLimit(amount);\n\n    // Calculate collateralDue and fees\n    uint256 price = pricer.getPrice(instantRedemptionPriceId);\n    uint256 collateralDue = _getRedemptionAmountForRwa(amount, price);\n    uint256 feesInCollateral = _getinstantRedemptionFees(collateralDue);\n    uint256 collateralDuePostFees = collateralDue - feesInCollateral;\n\n    // Burn rwa and transfer collateral\n    rwa.burnFrom(msg.sender, amount);\n\n    collateral.safeTransferFrom(\n      instantMintAssetManager,\n      msg.sender,\n      collateralDuePostFees\n    );\n\n    emit InstantRedemptionCompleted(\n      msg.sender,\n      amount,\n      collateralDuePostFees,\n      feesInCollateral,\n      price,\n      instantRedemptionPriceId\n    );\n  }\n\n  /**\n   * @notice Guarded function to set the `instantMintAssetManager`\n   *\n   * @param _instantMintAssetManager The address to update\n   *                                 `instantMintAssetManager` to\n   */\n  function setInstantMintAssetManager(\n    address _instantMintAssetManager\n  ) external onlyRole(MANAGER_ADMIN) {\n    address oldInstantMintAssetManager = instantMintAssetManager;\n    instantMintAssetManager = _instantMintAssetManager;\n    emit InstantMintAssetManagerSet(\n      oldInstantMintAssetManager,\n      _instantMintAssetManager\n    );\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    Instant Mint/Redeem Fee Utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Sets the instant mint fee\n   *\n   * @param _instantMintFee new mint fee specified in basis points\n   *\n   * @dev `_instantMintFee` must not exceed 100% (or 10_000 bps)\n   */\n  function setInstantMintFee(\n    uint256 _instantMintFee\n  ) external onlyRole(MANAGER_ADMIN) {\n    if (_instantMintFee > BPS_DENOMINATOR) {\n      revert FeeTooLarge();\n    }\n    uint256 oldInstantMintFee = instantMintFee;\n    instantMintFee = _instantMintFee;\n    emit InstantMintFeeSet(oldInstantMintFee, _instantMintFee);\n  }\n\n  /**\n   * @notice Sets instant redemption fee.\n   *\n   * @param _instantRedemptionFee new redemption fee specified in basis points\n   *\n   * @dev `_instantRedemptionFee` must not exceed 100% (or 10_000 bps)\n   */\n  function setInstantRedemptionFee(\n    uint256 _instantRedemptionFee\n  ) external onlyRole(MANAGER_ADMIN) {\n    if (_instantRedemptionFee > BPS_DENOMINATOR) {\n      revert FeeTooLarge();\n    }\n    uint256 oldinstantRedemptionFee = instantRedemptionFee;\n    instantRedemptionFee = _instantRedemptionFee;\n    emit InstantRedemptionFeeSet(\n      oldinstantRedemptionFee,\n      _instantRedemptionFee\n    );\n  }\n\n  /**\n   * @notice Given amount of `collateral`, returns how much in fees\n   *         are owed\n   *\n   * @param collateralAmount Amount of `collateral` to calculate fees\n   *                         (in decimals of `collateral`)\n   */\n  function _getInstantMintFees(\n    uint256 collateralAmount\n  ) internal view returns (uint256) {\n    return (collateralAmount * instantMintFee) / BPS_DENOMINATOR;\n  }\n\n  /**\n   * @notice Given amount of `collateral`, returns how much in fees\n   *         are owed\n   *\n   * @param collateralAmount Amount `collateral` to calculate fees\n   *                         (in decimals of `collateral`)\n   */\n  function _getinstantRedemptionFees(\n    uint256 collateralAmount\n  ) internal view returns (uint256) {\n    return (collateralAmount * instantRedemptionFee) / BPS_DENOMINATOR;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    Instant Mint/Redeem Setters\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Function to set priceId for instant mints\n   */\n  function setInstantMintPriceId(\n    uint256 _instantMintPriceId\n  ) external onlyRole(PRICE_ID_SETTER_ROLE) {\n    instantMintPriceId = _instantMintPriceId;\n    emit PriceIdSetForInstantMint(_instantMintPriceId);\n  }\n\n  /**\n   * @notice Function to set priceId for instant redemptions\n   */\n  function setInstantRedemptionPriceId(\n    uint256 _instantRedemptionPriceId\n  ) external onlyRole(PRICE_ID_SETTER_ROLE) {\n    instantRedemptionPriceId = _instantRedemptionPriceId;\n    emit PriceIdSetForInstantRedemption(_instantRedemptionPriceId);\n  }\n\n  /**\n   * @notice Function to pause instant mints\n   */\n  function pauseInstantMint() external onlyRole(PAUSER_ADMIN) {\n    instantMintPaused = true;\n    emit InstantMintPaused(msg.sender);\n  }\n\n  /**\n   * @notice Function to unpause instant mints\n   */\n  function unpauseInstantMint() external onlyRole(MANAGER_ADMIN) {\n    instantMintPaused = false;\n    emit InstantMintUnpaused(msg.sender);\n  }\n\n  /**\n   * @notice Function to pause instant redemptions\n   */\n  function pauseInstantRedemption() external onlyRole(PAUSER_ADMIN) {\n    instantRedemptionPaused = true;\n    emit InstantRedemptionPaused(msg.sender);\n  }\n\n  /**\n   * @notice Function to unpause instant redemptions\n   */\n  function unpauseInstantRedemption() external onlyRole(MANAGER_ADMIN) {\n    instantRedemptionPaused = false;\n    emit InstantRedemptionUnpaused(msg.sender);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                     Rate Limiter Configuration\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Set the mintLimit constraint inside the TimeBasedRateLimiter\n   *         base contract\n   *\n   * @param newMintLimit New limit that dictates how much RWA can be minted\n   *                     in a specified duration\n   *                     (in 18 decimals per the RWA contract)\n   */\n  function setInstantMintLimit(\n    uint256 newMintLimit\n  ) external onlyRole(MANAGER_ADMIN) {\n    _setInstantMintLimit(newMintLimit);\n  }\n\n  /**\n   * @notice Set the RedemptionLimit constraint inside the TimeBasedRateLimiter\n   *         base contract\n   *\n   * @param newRedemptionLimit New limit that dicates how much RWA\n   *                       can be redeemed in a specified duration\n   *                       (in 18 decimals per the RWA contract)\n   */\n  function setInstantRedemptionLimit(\n    uint256 newRedemptionLimit\n  ) external onlyRole(MANAGER_ADMIN) {\n    _setInstantRedemptionLimit(newRedemptionLimit);\n  }\n\n  /**\n   * @notice Sets mintLimitDuration constraint inside the TimeBasedRateLimiter\n   *         base contract\n   *\n   * @param newMintLimitDuration New limit that specifies the interval\n   *                             (in seconds) in which only mintLimit RWA\n   *                             can be minted within\n   */\n  function setInstantMintLimitDuration(\n    uint256 newMintLimitDuration\n  ) external onlyRole(MANAGER_ADMIN) {\n    _setInstantMintLimitDuration(newMintLimitDuration);\n  }\n\n  /**\n   * @notice Sets RedemptionLimitDuration inside the TimeBasedRateLimiter\n   *         base contract\n   *\n   * @param newRedemptionLimitDuration New limit that specifies the interval\n   *                               (in seconds) in which only RedemptionLimit RWA\n   *                               can be redeemed within\n   */\n  function setInstantRedemptionLimitDuration(\n    uint256 newRedemptionLimitDuration\n  ) external onlyRole(MANAGER_ADMIN) {\n    _setInstantRedemptionLimitDuration(newRedemptionLimitDuration);\n  }\n}\n"
    },
    "contracts/kyc/IKYCRegistry.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\n/**\n * @title IKYCRegistry\n * @author Ondo Finance\n * @notice The interface for Ondo's KYC Registry contract\n */\ninterface IKYCRegistry {\n  /**\n   * @notice Retrieves KYC status of an account\n   *\n   * @param kycRequirementGroup The KYC group for which we wish to check\n   * @param account             The account we wish to retrieve KYC status for\n   *\n   * @return bool Whether the `account` is KYC'd\n   */\n  function getKYCStatus(\n    uint256 kycRequirementGroup,\n    address account\n  ) external view returns (bool);\n\n  /**\n   * @notice View function for the public nested mapping of kycState\n   *\n   * @param kycRequirementGroup The KYC group to view\n   * @param account             The account to check if KYC'd\n   */\n  function kycState(\n    uint256 kycRequirementGroup,\n    address account\n  ) external view returns (bool);\n}\n"
    },
    "contracts/kyc/IKYCRegistryClient.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/kyc/IKYCRegistry.sol\";\n\n/**\n * @title IKYCRegistryClient\n * @author Ondo Finance\n * @notice The client interface Ondo's KYC Registry contract.\n */\ninterface IKYCRegistryClient {\n  /// @notice Returns what KYC group this client checks accounts for\n  function kycRequirementGroup() external view returns (uint256);\n\n  /// @notice Returns reference to the KYC registry that this client queries\n  function kycRegistry() external view returns (IKYCRegistry);\n\n  /// @notice Sets the KYC group\n  function setKYCRequirementGroup(uint256 group) external;\n\n  /// @notice Sets the KYC registry reference\n  function setKYCRegistry(address registry) external;\n\n  /// @notice Error for when caller attempts to set the KYC registry refernce\n  ///         to the zero address.\n  error RegistryZeroAddress();\n\n  /**\n   * @dev Event for when the KYC registry reference is set\n   *\n   * @param oldRegistry The old registry\n   * @param newRegistry The new registry\n   */\n  event KYCRegistrySet(address oldRegistry, address newRegistry);\n\n  /**\n   * @dev Event for when the KYC group for this client is set\n   *\n   * @param oldRequirementGroup The old KYC group\n   * @param newRequirementGroup The new KYC group\n   */\n  event KYCRequirementGroupSet(\n    uint256 oldRequirementGroup,\n    uint256 newRequirementGroup\n  );\n}\n"
    },
    "contracts/interfaces/IRWAHubInstantMints.sol": {
      "content": "pragma solidity 0.8.16;\n\ninterface IRWAHubInstantMints {\n  function instantMint(uint256 amount) external;\n\n  function instantRedemption(uint256 amount) external;\n\n  function setInstantMintFee(uint256 _instantMintFee) external;\n\n  function setInstantRedemptionFee(uint256 _instantRedemptionFee) external;\n\n  function setInstantMintPriceId(uint256 _instantMintPriceId) external;\n\n  function setInstantRedemptionPriceId(\n    uint256 _instantRedemptionPriceId\n  ) external;\n\n  function pauseInstantMint() external;\n\n  function unpauseInstantMint() external;\n\n  function pauseInstantRedemption() external;\n\n  function unpauseInstantRedemption() external;\n\n  function setInstantMintLimit(uint256 newMintLimit) external;\n\n  function setInstantRedemptionLimit(uint256 newRedemptionLimit) external;\n\n  function setInstantMintLimitDuration(uint256 newMintLimitDuration) external;\n\n  function setInstantRedemptionLimitDuration(\n    uint256 newRedemptionLimitDuration\n  ) external;\n\n  /**\n   * @notice Event emitted when instant mint fee is set\n   *\n   * @param oldFee Old fee\n   * @param newFee New fee\n   *\n   * @dev See inheriting contract for decimals representation\n   */\n  event InstantMintFeeSet(uint256 oldFee, uint256 newFee);\n\n  /**\n   * @notice Event emitted when instant redeem fee is set\n   *\n   * @param oldFee Old fee\n   * @param newFee New fee\n   *\n   * @dev See inheriting contract for decimals representation\n   */\n  event InstantRedemptionFeeSet(uint256 oldFee, uint256 newFee);\n\n  /**\n   * @notice Event emitted when an instant mint is completed\n   *\n   * @param user                      The address of the user\n   * @param collateralAmountDeposited The amount of collateral deposited\n   * @param collateralAmountAfterFees The amount of collateral after fees\n   * @param feesInCollateral          The amount of fees in collateral\n   * @param rwaOwed                   The amount of rwa minted to the user\n   * @param price                     The price at which the rwa was minted at\n   */\n  event InstantMintCompleted(\n    address indexed user,\n    uint256 collateralAmountDeposited,\n    uint256 collateralAmountAfterFees,\n    uint256 feesInCollateral,\n    uint256 rwaOwed,\n    uint256 price\n  );\n\n  /**\n   * @notice Event emitted when an instant redeem is completed\n   *\n   * @param user                      The address of the user\n   * @param rwaAmountBurned           The amount of RWA burned by the user\n   * @param collateralAmountAfterFees The amount of collateral after fees returned\n   * @param feesInCollateral          The amount of fees in collateral\n   * @param price                     The price at which the rwa was redeemed at\n   * @param priceId                   The priceId of the used redemption price\n   */\n  event InstantRedemptionCompleted(\n    address indexed user,\n    uint256 rwaAmountBurned,\n    uint256 collateralAmountAfterFees,\n    uint256 feesInCollateral,\n    uint256 price,\n    uint256 priceId\n  );\n\n  /**\n   * @notice Event emitted when instant mints are paused\n   *\n   * @param caller Address which initiated the pause\n   */\n  event InstantMintPaused(address caller);\n\n  /**\n   * @notice Event emitted when instant mints are unpaused\n   *\n   * @param caller Address which initiated the unpause\n   */\n  event InstantMintUnpaused(address caller);\n\n  /**\n   * @notice Event emitted when instant redeems are paused\n   *\n   * @param caller Address which initiated the pause\n   */\n  event InstantRedemptionPaused(address caller);\n\n  /**\n   * @notice Event emitted when instant redeems are unpaused\n   *\n   * @param caller Address which initiated the unpause\n   */\n  event InstantRedemptionUnpaused(address caller);\n\n  /**\n   * @notice Event emitted when instant mint priceId is set\n   *\n   * @param priceId Price Id\n   */\n  event PriceIdSetForInstantMint(uint256 priceId);\n\n  /**\n   * @notice Event emitted when instant redeem priceId is set\n   *\n   * @param priceId Price Id\n   */\n  event PriceIdSetForInstantRedemption(uint256 priceId);\n\n  /**\n   * @notice Event emitted when instant mint asset manager is set\n   *\n   * @param oldInstantMintAssetManager Old instant mint asset manager\n   * @param newInstantMintAssetManager New instant mint asset manager\n   */\n  event InstantMintAssetManagerSet(\n    address oldInstantMintAssetManager,\n    address newInstantMintAssetManager\n  );\n}\n"
    },
    "contracts/ousg/ousgManager.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\n\npragma solidity 0.8.16;\n\nimport \"contracts/RWAHubOffChainRedemptions.sol\";\nimport \"contracts/kyc/KYCRegistryClient.sol\";\nimport \"contracts/interfaces/IPricerWithOracle.sol\";\n\ncontract OUSGManager is RWAHubOffChainRedemptions, KYCRegistryClient {\n  bytes32 public constant REDEMPTION_PROVER_ROLE =\n    keccak256(\"REDEMPTION_PROVER_ROLE\");\n\n  constructor(\n    address _collateral,\n    address _rwa,\n    address managerAdmin,\n    address pauser,\n    address _assetSender,\n    address _feeRecipient,\n    uint256 _minimumDepositAmount,\n    uint256 _minimumRedemptionAmount,\n    address _kycRegistry,\n    uint256 _kycRequirementGroup\n  )\n    RWAHubOffChainRedemptions(\n      _collateral,\n      _rwa,\n      managerAdmin,\n      pauser,\n      _assetSender,\n      _feeRecipient,\n      _minimumDepositAmount,\n      _minimumRedemptionAmount\n    )\n  {\n    _setKYCRegistry(_kycRegistry);\n    _setKYCRequirementGroup(_kycRequirementGroup);\n  }\n\n  /**\n   * @notice Function to enforce KYC/AML requirements that will\n   *         be implemented on calls to `requestSubscription` and\n   *         `claimRedemption`\n   *\n   * @param account The account that we would like to check the KYC\n   *                status for\n   */\n  function _checkRestrictions(address account) internal view override {\n    // Check Basic KYC requirements for OMMF\n    if (!_getKYCStatus(account)) {\n      revert KYCCheckFailed();\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        KYC Registry Utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Update KYC group of the contract for which\n   *         accounts are checked against\n   *\n   * @param _kycRequirementGroup The new KYC requirement group\n   */\n  function setKYCRequirementGroup(\n    uint256 _kycRequirementGroup\n  ) external onlyRole(MANAGER_ADMIN) {\n    _setKYCRequirementGroup(_kycRequirementGroup);\n  }\n\n  /**\n   * @notice Function to add a redemption proof to the contract\n   *\n   * @param txHash           The tx hash (redemption Id) of the redemption\n   * @param user             The address of the user who made the redemption\n   * @param rwaAmountToBurn  The amount of OMMF burned\n   * @param timestamp        The timestamp of the redemption request\n   */\n  function addRedemptionProof(\n    bytes32 txHash,\n    address user,\n    uint256 rwaAmountToBurn,\n    uint256 timestamp\n  ) external onlyRole(REDEMPTION_PROVER_ROLE) checkRestrictions(user) {\n    if (redemptionIdToRedeemer[txHash].user != address(0)) {\n      revert RedemptionProofAlreadyExists();\n    }\n    if (rwaAmountToBurn == 0) {\n      revert RedemptionTooSmall();\n    }\n    if (user == address(0)) {\n      revert RedeemerNull();\n    }\n    rwa.burnFrom(msg.sender, rwaAmountToBurn);\n    redemptionIdToRedeemer[txHash] = Redeemer(user, rwaAmountToBurn, 0);\n\n    emit RedemptionProofAdded(txHash, user, rwaAmountToBurn, timestamp);\n  }\n\n  /**\n   * @notice Update KYC registry address\n   *\n   * @param _kycRegistry The new KYC registry address\n   */\n  function setKYCRegistry(\n    address _kycRegistry\n  ) external onlyRole(MANAGER_ADMIN) {\n    _setKYCRegistry(_kycRegistry);\n  }\n\n  function setPriceIdForDeposits(\n    bytes32[] calldata depositIds,\n    uint256[] calldata priceIds\n  ) public virtual override onlyRole(PRICE_ID_SETTER_ROLE) {\n    if (!IPricerWithOracle(address(pricer)).isValid(priceIds)) {\n      revert InvalidPriceId();\n    }\n    super.setPriceIdForDeposits(depositIds, priceIds);\n  }\n\n  function setPriceIdForRedemptions(\n    bytes32[] calldata redemptionIds,\n    uint256[] calldata priceIds\n  ) public virtual override onlyRole(PRICE_ID_SETTER_ROLE) {\n    if (!IPricerWithOracle(address(pricer)).isValid(priceIds)) {\n      revert InvalidPriceId();\n    }\n    super.setPriceIdForRedemptions(redemptionIds, priceIds);\n  }\n\n  /**\n   * @notice Event emitted when redemption proof has been added\n   *\n   * @param txHash                Tx hash (redemption id) of the redemption transfer\n   * @param user                  Address of the user who made the redemption\n   * @param rwaAmountBurned       Amount of OMMF burned\n   * @param timestamp             Timestamp of the redemption\n   */\n  event RedemptionProofAdded(\n    bytes32 indexed txHash,\n    address indexed user,\n    uint256 rwaAmountBurned,\n    uint256 timestamp\n  );\n\n  error KYCCheckFailed();\n  error InvalidPriceId();\n}\n"
    },
    "contracts/interfaces/IPricerWithOracle.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IPricer.sol\";\n\ninterface IPricerWithOracle is IPricer {\n  /**\n   * @dev Deletes a price from the contract.\n   * @param priceId The ID of the price to be deleted.\n   * Emits a {PriceDeleted} event.\n   * Requirements:\n   * - The caller must have the `DEFAULT_ADMIN_ROLE`.\n   * - The price ID must exist.\n   */\n  function deletePrice(uint256 priceId) external;\n\n  /**\n   * @dev Checks if the given priceIds are valid by verifying that their corresponding prices were updated\n   * within the last `maxTimestampDiff` seconds.\n   * @param priceIds An array of priceIds to check validity for.\n   * @return A boolean indicating whether all the given priceIds are valid or not.\n   */\n  function isValid(uint256[] calldata priceIds) external view returns (bool);\n\n  /**\n   * @dev Adds a new price and timestamp to the price history, subject to certain conditions.\n   * Only callable by an account with the `ADD_PRICE_OPS_ROLE` role.\n   * @param price The new price to add.\n   * @param timestamp The timestamp at which the price was recorded.\n   * Emits a {PriceChangeTooLarge}, {TimeStampInFuture}, {TimeStampTooOld}, or {StaleOraclePrice} error if the conditions are not met.\n   */\n  function addPriceOps(uint256 price, uint256 timestamp) external;\n}\n"
    },
    "contracts/interfaces/IPricer.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\ninterface IPricer {\n  /**\n   * @notice Gets the latest price of the asset\n   *\n   * @return uint256 The latest price of the asset\n   */\n  function getLatestPrice() external view returns (uint256);\n\n  /**\n   * @notice Gets the price of the asset at a specific priceId\n   *\n   * @param priceId The priceId at which to get the price\n   *\n   * @return uint256 The price of the asset with the given priceId\n   */\n  function getPrice(uint256 priceId) external view returns (uint256);\n\n  /**\n   * @notice Adds a price to the pricer\n   *\n   * @param price     The price to add\n   * @param timestamp The timestamp associated with the price\n   *\n   * @dev Updates the oracle price if price is the latest\n   */\n  function addPrice(uint256 price, uint256 timestamp) external;\n\n  /**\n   * @notice Updates a price in the pricer\n   *\n   * @param priceId The priceId to update\n   * @param price   The price to set\n   */\n  function updatePrice(uint256 priceId, uint256 price) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}