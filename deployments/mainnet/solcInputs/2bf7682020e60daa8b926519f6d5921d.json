{
  "language": "Solidity",
  "sources": {
    "contracts/InstantMintTimeBasedRateLimiter.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\n/**\n * @title InstantMintTimeBasedRateLimiter\n *\n * @notice This abstract contract implements two rate limiters: one for minting\n *         and one for redeeming. Each limit is completely independent: mints\n *         and redemption don't offset each other. Each limit is associated\n *         with a duration, after which the tracked amount is reset. The\n *         amounts tracked are agnostic to a specific token; the usage is\n *         determined by the inheriting contracts.\n *\n * @dev Although this contract has all of its functions implemented, this\n *      contract is marked abstract to prevent an accidental deployment and to\n *      signify that we would never deploy this contract standalone.\n *\n */\nabstract contract InstantMintTimeBasedRateLimiter {\n  // `currentInstantMintAmount` resets after this interval (in seconds)\n  uint256 public resetInstantMintDuration;\n  // timestamp when `currentInstantMintAmount` was last reset\n  uint256 public lastResetInstantMintTime;\n\n  // maximum amount that can be minted during a `resetInstantMintDuration` window\n  uint256 public instantMintLimit;\n  // amount already minted during the current `resetInstantMintDuration` window\n  uint256 public currentInstantMintAmount;\n\n  // `currentInstantRedemptionAmount` resets after this interval (in seconds)\n  uint256 public resetInstantRedemptionDuration;\n  // timestamp when the `currentInstantRedemptionAmount` was last reset\n  uint256 public lastResetInstantRedemptionTime;\n\n  // maximum amount that can be redeemed during a `resetInstantRedemptionDuration` window\n  uint256 public instantRedemptionLimit;\n  // amount already redeemed during the current `resetInstantRedemptionDuration` window\n  uint256 public currentInstantRedemptionAmount;\n\n  /**\n   * @notice In the constructor, we initialize the variables for the mint and\n   *         redemption rate limiters.\n   *\n   * @param _instantMintResetDuration   `currentInstantMintAmount` resets after this interval\n   *                                    (in seconds)\n   * @param _instantRedemptionResetDuration `currentInstantRedemptionAmount` resets after this\n   *                                    interval (in seconds)\n   * @param _instantMintLimit           maximum amount that can be minted during a\n   *                                    `resetInstantMintDuration` window\n   * @param _instantRedemptionLimit     maximum amount that can be redeemed during a\n   *                                    `resetInstantRedemptionDuration` window\n   *\n   * @dev If a duration is zero, the limit resets before each mint/redemption.\n   * @dev If a limit is zero, the relevant check always fails.\n   */\n  constructor(\n    uint256 _instantMintResetDuration,\n    uint256 _instantRedemptionResetDuration,\n    uint256 _instantMintLimit,\n    uint256 _instantRedemptionLimit\n  ) {\n    resetInstantMintDuration = _instantMintResetDuration; // can be zero for per-block limit\n    resetInstantRedemptionDuration = _instantRedemptionResetDuration; // can be zero for per-block limit\n    instantMintLimit = _instantMintLimit; // can be zero to disable minting\n    instantRedemptionLimit = _instantRedemptionLimit; // can be zero to disable redemptions\n\n    lastResetInstantMintTime = block.timestamp;\n    lastResetInstantRedemptionTime = block.timestamp;\n  }\n\n  /**\n   * @notice Checks the requested mint amount against the rate limiter (and\n   *         updates the remaining amount)\n   *\n   * @param amount The requested mint amount\n   *\n   * @dev Reverts if the requested mint amount exceeds the current limit\n   */\n  function _checkAndUpdateInstantMintLimit(uint256 amount) internal {\n    require(amount > 0, \"RateLimit: mint amount can't be zero\");\n\n    if (\n      block.timestamp >= lastResetInstantMintTime + resetInstantMintDuration\n    ) {\n      // time has passed, reset\n      currentInstantMintAmount = 0;\n      lastResetInstantMintTime = block.timestamp;\n    }\n    require(\n      amount <= instantMintLimit - currentInstantMintAmount,\n      \"RateLimit: Mint exceeds rate limit\"\n    );\n\n    currentInstantMintAmount += amount;\n  }\n\n  /**\n   * @notice Checks the requested redemption amount against the rate limiter\n   *         (and updates the remaining amount)\n   *\n   * @param amount The requested redemption amount\n   *\n   * @dev Reverts if the requested redemption amount exceeds the current\n   *      limit\n   */\n  function _checkAndUpdateInstantRedemptionLimit(uint256 amount) internal {\n    require(amount > 0, \"RateLimit: redemption amount can't be zero\");\n\n    if (\n      block.timestamp >=\n      lastResetInstantRedemptionTime + resetInstantRedemptionDuration\n    ) {\n      // time has passed, reset\n      currentInstantRedemptionAmount = 0;\n      lastResetInstantRedemptionTime = block.timestamp;\n    }\n    require(\n      amount <= instantRedemptionLimit - currentInstantRedemptionAmount,\n      \"RateLimit: Redemption exceeds rate limit\"\n    );\n    currentInstantRedemptionAmount += amount;\n  }\n\n  /**\n   * @notice Update the amount of token that can be minted during one duration\n   *\n   * @param _instantMintLimit The token amount\n   *\n   * @dev If a limit is zero, the relevant check always fails.\n   */\n  function _setInstantMintLimit(uint256 _instantMintLimit) internal {\n    instantMintLimit = _instantMintLimit;\n    emit InstantMintLimitSet(_instantMintLimit);\n  }\n\n  /**\n   * @notice Update the amount of token that can be redeemed during one duration\n   *\n   * @param _redemptionLimit The token amount\n   *\n   * @dev If a limit is zero, the relevant check always fails.\n   */\n  function _setInstantRedemptionLimit(uint256 _redemptionLimit) internal {\n    instantRedemptionLimit = _redemptionLimit;\n    emit InstantRedemptionLimitSet(_redemptionLimit);\n  }\n\n  /**\n   * @notice Update the duration for the mint rate limiter\n   *\n   * @param _instantMintResetDuration The duration in seconds\n   *\n   * @dev If a duration is zero, the limit resets before each mint/redemption\n   */\n  function _setInstantMintLimitDuration(\n    uint256 _instantMintResetDuration\n  ) internal {\n    resetInstantMintDuration = _instantMintResetDuration;\n    emit InstantMintLimitDurationSet(_instantMintResetDuration);\n  }\n\n  /**\n   * @notice Update the duration for the redemption rate limiter\n   *\n   * @param _instantRedemptionResetDuration The duration in seconds\n   *\n   * @dev If a duration is zero, the limit resets before each mint/redemption\n   */\n  function _setInstantRedemptionLimitDuration(\n    uint256 _instantRedemptionResetDuration\n  ) internal {\n    resetInstantRedemptionDuration = _instantRedemptionResetDuration;\n    emit InstantRedemptionLimitDurationSet(_instantRedemptionResetDuration);\n  }\n\n  /**\n   * @notice Event emitted when instant mint limit is set\n   *\n   * @param instantMintLimit How much of some token can be minted within\n   *                  an interval of length `resetInstantMintDuration`\n   *\n   * @dev See inheriting contract for representation\n   */\n  event InstantMintLimitSet(uint256 instantMintLimit);\n\n  /**\n   * @notice Event emitted when instant redemption limit is set\n   *\n   * @param instantRedemptionLimit How much of some token can be redeemed within\n   *                    an interval of length `resetInstantRedemptionDuration`\n   *\n   * @dev See inheriting contract for representation\n   */\n  event InstantRedemptionLimitSet(uint256 instantRedemptionLimit);\n\n  /**\n   * @notice Event emitted when mint limit duration is set\n   *\n   * @param instantMintLimitDuration The time window in which `instantMintLimit`\n   *                          of some token can be minted\n   *\n   * @dev instantMintLimitDuration is specified in seconds\n   */\n  event InstantMintLimitDurationSet(uint256 instantMintLimitDuration);\n\n  /**\n   * @notice Event emitted when redemption limit duration is set\n   *\n   * @param redemptionLimitDuration The time window in which `instantRedemptionLimit`\n   *                            of some token can be redeemed\n   *\n   * @dev redemptionLimitDuration is specified in seconds.\n   */\n  event InstantRedemptionLimitDurationSet(uint256 redemptionLimitDuration);\n}\n"
    },
    "contracts/RWAHubNonStableInstantMints.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\n\npragma solidity 0.8.16;\n\nimport \"contracts/RWAHub.sol\";\nimport \"contracts/InstantMintTimeBasedRateLimiter.sol\";\nimport \"contracts/interfaces/IRWAHubNonStableInstantMint.sol\";\n\nabstract contract RWAHubNonStableInstantMints is\n  RWAHub,\n  InstantMintTimeBasedRateLimiter,\n  IRWAHubNonStableInstantMint\n{\n  using SafeERC20 for IERC20;\n\n  // Fee collected when instant minting RWA-nonStable (in basis points)\n  uint256 public instantMintFee = 10;\n\n  // The % (in bps) of rwa to instantly give to the user\n  uint256 public instantMintAmountBps = 9_000;\n\n  // Flag whether instantMint is paused\n  bool public instantMintPaused = true;\n  bool public claimExcessPaused = true;\n\n  // Address to manage instant mints/redeems\n  address public instantMintAssetManager;\n\n  // Mapping used to store the instantMint amount for a given deposit Id\n  mapping(bytes32 => uint256) public depositIdToInstantMintAmount;\n\n  constructor(\n    address _collateral,\n    address _rwa,\n    address managerAdmin,\n    address pauser,\n    address _assetSender,\n    address _feeRecipient,\n    uint256 _minimumDepositAmount,\n    uint256 _minimumRedeemAmount,\n    address _instantMintAssetManager\n  )\n    RWAHub(\n      _collateral,\n      _rwa,\n      managerAdmin,\n      pauser,\n      _assetSender,\n      _feeRecipient,\n      _minimumDepositAmount,\n      _minimumRedeemAmount\n    )\n    InstantMintTimeBasedRateLimiter(0, 0, 0, 0)\n  {\n    instantMintAssetManager = _instantMintAssetManager;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                     Instant Mint Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Function to allow for investors to instantly mint a fraction of\n   *         their total deposited amount.\n   *\n   * @param amount The amount of collateral to `instantMint`\n   *\n   *\n   * @dev The daily ∆ price for the rwa Asset must not exceed:\n   *      10_000 - `instantMintAmountBps`\n   *      eg: 10_000 - 9_000 -> 1_000 (in bps) -> 10% ∆ in price\n   *      If this condition is violated there will be problems!\n   */\n  function instantMint(\n    uint256 amount\n  )\n    external\n    nonReentrant\n    ifNotPaused(instantMintPaused)\n    checkRestrictions(msg.sender)\n  {\n    if (amount < minimumDepositAmount) {\n      revert DepositTooSmall();\n    }\n\n    // Calculate fees\n    uint256 instantMintFeesInCollateral = _getInstantMintFees(amount);\n    uint256 depositAmountAfterFees = amount - instantMintFeesInCollateral;\n\n    // Transfer collateral\n    collateral.safeTransferFrom(msg.sender, instantMintAssetManager, amount);\n\n    // Calculate mint amount\n    uint256 price = pricer.getLatestPrice();\n    uint256 rwaGiven = _getInstantMintAmount(depositAmountAfterFees, price);\n\n    // Check mint limit\n    _checkAndUpdateInstantMintLimit(rwaGiven);\n\n    bytes32 depositId = bytes32(subscriptionRequestCounter++);\n    depositIdToDepositor[depositId] = Depositor(\n      msg.sender,\n      depositAmountAfterFees,\n      0\n    );\n\n    depositIdToInstantMintAmount[depositId] = rwaGiven;\n\n    rwa.mint(msg.sender, rwaGiven);\n\n    emit InstantMint(\n      msg.sender,\n      amount,\n      depositAmountAfterFees,\n      instantMintFeesInCollateral,\n      rwaGiven,\n      price,\n      depositId\n    );\n  }\n\n  /**\n   * @notice Function for users to claim their remain excess after their priceId\n   *         has been set.\n   *\n   * @param instantMintIds The DepositIds corresponding to instant mint\n   *                       requests\n   *\n   * @dev Function will revert if a deposit Id was not generated through\n   *      `instantMint`\n   */\n  function claimExcess(\n    bytes32[] calldata instantMintIds\n  )\n    external\n    nonReentrant\n    ifNotPaused(claimExcessPaused)\n    checkRestrictions(msg.sender)\n  {\n    uint256 excessSize = instantMintIds.length;\n    for (uint256 i; i < excessSize; ++i) {\n      _claimExcess(instantMintIds[i]);\n    }\n  }\n\n  /**\n   * @notice Internal function used to claim excess for a given depositId\n   *\n   * @param instantMintId The depositId correspond to an instant mint\n   *                      request\n   */\n  function _claimExcess(bytes32 instantMintId) internal virtual {\n    // Get depositor info and instant mint amount\n    Depositor memory depositor = depositIdToDepositor[instantMintId];\n    uint256 rwaGiven = depositIdToInstantMintAmount[instantMintId];\n\n    if (depositor.priceId == 0) {\n      revert PriceIdNotSet();\n    }\n    if (rwaGiven == 0) {\n      revert CannotClaimExcess();\n    }\n\n    // Get price and rwaOwed\n    uint256 price = pricer.getPrice(depositor.priceId);\n    uint256 rwaOwed = _getMintAmountForPrice(\n      depositor.amountDepositedMinusFees,\n      price\n    );\n\n    uint256 rwaDue = rwaOwed - rwaGiven;\n\n    delete depositIdToDepositor[instantMintId];\n    delete depositIdToInstantMintAmount[instantMintId];\n\n    rwa.mint(msg.sender, rwaDue);\n\n    emit ExcessMintClaimed(\n      depositor.user,\n      rwaOwed,\n      rwaDue,\n      depositor.amountDepositedMinusFees,\n      price,\n      instantMintId\n    );\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                 Override base for new accounting\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Overriden function from rwaHub, checks that a depositId does not\n   *         correspond to an instant mint\n   *\n   * @param depositIds Array for depositIds to claim\n   */\n  function claimMint(\n    bytes32[] calldata depositIds\n  ) external override nonReentrant ifNotPaused(subscriptionPaused) {\n    uint256 depositsSize = depositIds.length;\n    for (uint256 i; i < depositsSize; ++i) {\n      if (depositIdToInstantMintAmount[depositIds[i]] != 0) {\n        revert CannotClaimMint();\n      }\n      _claimMint(depositIds[i]);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        Pause Utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Guarded function to pause instant mints\n   */\n  function pauseInstantMint() external onlyRole(PAUSER_ADMIN) {\n    instantMintPaused = true;\n    emit InstantMintPaused(msg.sender);\n  }\n\n  /**\n   * @notice Guarded function to unpause instant mints\n   */\n  function unpauseInstantMint() external onlyRole(MANAGER_ADMIN) {\n    instantMintPaused = false;\n    emit InstantMintUnpaused(msg.sender);\n  }\n\n  /**\n   * @notice Guarded function to pause claims of excess resulting from\n   *         instant mints\n   */\n  function pauseClaimExcess() external onlyRole(PAUSER_ADMIN) {\n    claimExcessPaused = true;\n    emit ClaimExcessPaused(msg.sender);\n  }\n\n  /**\n   * @notice Gurarded function to unpause claims of excess resulting from\n   *         instant mints\n   */\n  function unpauseClaimExcess() external onlyRole(MANAGER_ADMIN) {\n    claimExcessPaused = false;\n    emit ClaimExcessUnpaused(msg.sender);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      Rate limiting utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Set the mintLimit constraint inside the TimeBasedRateLimiter\n   *         base contract\n   *\n   * @param newMintLimit New limit that dictates how much RWA can be minted\n   *                     in a specified duration\n   *                     (in 18 decimals per the RWA contract)\n   */\n  function setInstantMintLimit(\n    uint256 newMintLimit\n  ) external onlyRole(MANAGER_ADMIN) {\n    _setInstantMintLimit(newMintLimit);\n  }\n\n  /**\n   * @notice Sets mintLimitDuration constraint inside the TimeBasedRateLimiter\n   *         base contract\n   *\n   * @param newMintLimitDuration New limit that specifies the interval\n   *                             (in seconds) in which only mintLimit RWA\n   *                             can be minted within\n   */\n  function setInstantMintLimitDuration(\n    uint256 newMintLimitDuration\n  ) external onlyRole(MANAGER_ADMIN) {\n    _setInstantMintLimitDuration(newMintLimitDuration);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                           Admin Utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Admin function to overwrite entries in the `depositIdToInstantMintAmount`\n   *         mapping\n   *\n   * @param depositId   The depositId of the entry we wish to overwrite\n   * @param amountGiven The new amount of rwa instantly minted\n   */\n  function overwriteInstantMintAmountGiven(\n    bytes32 depositId,\n    uint256 amountGiven\n  ) external onlyRole(MANAGER_ADMIN) {\n    uint256 oldGiven = depositIdToInstantMintAmount[depositId];\n    depositIdToInstantMintAmount[depositId] = amountGiven;\n    emit InstantMintGivenOverriden(depositId, oldGiven, amountGiven);\n  }\n\n  /**\n   * @notice Guarded function to set the `instantMintAssetManager`\n   *\n   * @param _instantMintAssetManager The address to update\n   *                                 `instantMintAssetManager` to\n   */\n  function setInstantMintAssetManager(\n    address _instantMintAssetManager\n  ) external onlyRole(MANAGER_ADMIN) {\n    address oldInstantMintAssetManager = instantMintAssetManager;\n    instantMintAssetManager = _instantMintAssetManager;\n    emit InstantMintAssetManagerSet(\n      oldInstantMintAssetManager,\n      instantMintAssetManager\n    );\n  }\n\n  /**\n   * @notice Sets the instant mint fee\n   *\n   * @param _instantMintFee new mint fee specified in basis points\n   *\n   * @dev `_instantMintFee` must not exceed 100% (or 10_000 bps)\n   */\n  function setInstantMintFee(\n    uint256 _instantMintFee\n  ) external onlyRole(MANAGER_ADMIN) {\n    if (_instantMintFee > BPS_DENOMINATOR) {\n      revert FeeTooLarge();\n    }\n    uint256 oldInstantMintFee = instantMintFee;\n    instantMintFee = _instantMintFee;\n    emit InstantMintFeeSet(oldInstantMintFee, _instantMintFee);\n  }\n\n  /**\n   * @notice Sets the % (in bps) for the portion of a deposit amount\n   *         that is to be instantly minted\n   *\n   * @dev This value really should not be above 90% -> 9_000 bps\n   */\n  function setInstantMintAmount(\n    uint256 bpsToInstantMint\n  ) external onlyRole(MANAGER_ADMIN) {\n    if (bpsToInstantMint > BPS_DENOMINATOR) {\n      revert FeeTooLarge();\n    }\n    uint256 oldInstantMintAmt = instantMintAmountBps;\n    instantMintAmountBps = bpsToInstantMint;\n    emit InstantMintAmountSet(oldInstantMintAmt, instantMintAmountBps);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        Calculation utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Internal function to get the fees corresponding to\n   *          instantly minting\n   */\n  function _getInstantMintFees(\n    uint256 collateralAmount\n  ) internal view returns (uint256) {\n    return (collateralAmount * instantMintFee) / BPS_DENOMINATOR;\n  }\n\n  /**\n   * @notice Internal function to calculate the amount due given the latest price\n   *         and the `instantMintAmountBps` (Fraction of deposits to instantly mint)\n   */\n  function _getInstantMintAmount(\n    uint256 collateralAmountIn,\n    uint256 price\n  ) internal view returns (uint256 rwaInstantMint) {\n    uint256 amountE36 = _scaleUp(collateralAmountIn) * 1e18;\n    uint256 rwaOwedLatestRate = amountE36 / price;\n    rwaInstantMint =\n      (rwaOwedLatestRate * instantMintAmountBps) /\n      BPS_DENOMINATOR;\n  }\n}\n"
    },
    "contracts/RWAHub.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IPricerReader.sol\";\nimport \"contracts/interfaces/IRWALike.sol\";\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\nimport \"contracts/external/openzeppelin/contracts/token/SafeERC20.sol\";\nimport \"contracts/interfaces/IRWAHub.sol\";\n\n// Additional Dependencies\nimport \"contracts/external/openzeppelin/contracts/token/IERC20Metadata.sol\";\nimport \"contracts/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"contracts/external/openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nabstract contract RWAHub is IRWAHub, ReentrancyGuard, AccessControlEnumerable {\n  using SafeERC20 for IERC20;\n  // RWA Token contract\n  IRWALike public immutable rwa;\n  // Pointer to Pricer\n  IPricerReader public pricer;\n  // Address to receive deposits\n  address public constant assetRecipient =\n    0xF67416a2C49f6A46FEe1c47681C5a3832cf8856c;\n  // Address to send redemptions\n  address public assetSender;\n  // Address fee recipient\n  address public feeRecipient;\n  // Mapping from deposit Id -> Depositor\n  mapping(bytes32 => Depositor) public depositIdToDepositor;\n  // Mapping from redemptionId -> Redeemer\n  mapping(bytes32 => Redeemer) public redemptionIdToRedeemer;\n\n  /// @dev Mint/Redeem Parameters\n  // Minimum amount that must be deposited to mint the RWA token\n  // Denoted in decimals of `collateral`\n  uint256 public minimumDepositAmount;\n\n  // Minimum amount that must be redeemed for a withdraw request\n  uint256 public minimumRedemptionAmount;\n\n  // Minting fee specified in basis points\n  uint256 public mintFee = 0;\n\n  // Redemption fee specified in basis points\n  uint256 public redemptionFee = 0;\n\n  // The asset accepted by the RWAHub\n  IERC20 public immutable collateral;\n\n  // Decimal multiplier representing the difference between `rwa` decimals\n  // In `collateral` token decimals\n  uint256 public immutable decimalsMultiplier;\n\n  // Deposit counter to map subscription requests to\n  uint256 public subscriptionRequestCounter = 1;\n\n  // Redemption Id to map from\n  uint256 public redemptionRequestCounter = 1;\n\n  // Helper constant that allows us to specify basis points in calculations\n  uint256 public constant BPS_DENOMINATOR = 10_000;\n\n  // Pause variables\n  bool public redemptionPaused;\n  bool public subscriptionPaused;\n\n  /// @dev Role based access control roles\n  bytes32 public constant MANAGER_ADMIN = keccak256(\"MANAGER_ADMIN\");\n  bytes32 public constant PAUSER_ADMIN = keccak256(\"PAUSER_ADMIN\");\n  bytes32 public constant PRICE_ID_SETTER_ROLE =\n    keccak256(\"PRICE_ID_SETTER_ROLE\");\n  bytes32 public constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\n\n  /// @notice constructor\n  constructor(\n    address _collateral,\n    address _rwa,\n    address managerAdmin,\n    address pauser,\n    address _assetSender,\n    address _feeRecipient,\n    uint256 _minimumDepositAmount,\n    uint256 _minimumRedemptionAmount\n  ) {\n    if (_collateral == address(0)) {\n      revert CollateralCannotBeZero();\n    }\n    if (_rwa == address(0)) {\n      revert RWACannotBeZero();\n    }\n    if (_assetSender == address(0)) {\n      revert AssetSenderCannotBeZero();\n    }\n    if (_feeRecipient == address(0)) {\n      revert FeeRecipientCannotBeZero();\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, managerAdmin);\n    _grantRole(MANAGER_ADMIN, managerAdmin);\n    _grantRole(PAUSER_ADMIN, pauser);\n    _setRoleAdmin(PAUSER_ADMIN, MANAGER_ADMIN);\n    _setRoleAdmin(PRICE_ID_SETTER_ROLE, MANAGER_ADMIN);\n    _setRoleAdmin(RELAYER_ROLE, MANAGER_ADMIN);\n\n    collateral = IERC20(_collateral);\n    rwa = IRWALike(_rwa);\n    feeRecipient = _feeRecipient;\n    assetSender = _assetSender;\n    minimumDepositAmount = _minimumDepositAmount;\n    minimumRedemptionAmount = _minimumRedemptionAmount;\n\n    decimalsMultiplier =\n      10 **\n        (IERC20Metadata(_rwa).decimals() -\n          IERC20Metadata(_collateral).decimals());\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                  Subscription/Redemption Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Function used by users to request subscription to the fund\n   *\n   * @param amount The amount of collateral one wished to deposit\n   */\n  function requestSubscription(\n    uint256 amount\n  )\n    external\n    virtual\n    nonReentrant\n    ifNotPaused(subscriptionPaused)\n    checkRestrictions(msg.sender)\n  {\n    if (amount < minimumDepositAmount) {\n      revert DepositTooSmall();\n    }\n\n    uint256 feesInCollateral = _getMintFees(amount);\n    uint256 depositAmountAfterFee = amount - feesInCollateral;\n\n    // Link the depositor to their deposit ID\n    bytes32 depositId = bytes32(subscriptionRequestCounter++);\n    depositIdToDepositor[depositId] = Depositor(\n      msg.sender,\n      depositAmountAfterFee,\n      0\n    );\n\n    if (feesInCollateral > 0) {\n      collateral.safeTransferFrom(msg.sender, feeRecipient, feesInCollateral);\n    }\n\n    collateral.safeTransferFrom(\n      msg.sender,\n      assetRecipient,\n      depositAmountAfterFee\n    );\n\n    emit MintRequested(\n      msg.sender,\n      depositId,\n      amount,\n      depositAmountAfterFee,\n      feesInCollateral\n    );\n  }\n\n  /**\n   * @notice Function used to claim tokens corresponding to a deposit request\n   *\n   * @param depositIds An array containing the deposit Ids one wishes to claim\n   *\n   * @dev Implicitly does all transfer checks present in underlying `rwa`\n   * @dev The priceId corresponding to a given depositId must be set prior to\n   *      claiming a mint\n   */\n  function claimMint(\n    bytes32[] calldata depositIds\n  ) external virtual nonReentrant ifNotPaused(subscriptionPaused) {\n    uint256 depositsSize = depositIds.length;\n    for (uint256 i = 0; i < depositsSize; ++i) {\n      _claimMint(depositIds[i]);\n    }\n  }\n\n  /**\n   * @notice Internal claim mint helper\n   *\n   * @dev This function can be overriden to implement custom claiming logic\n   */\n  function _claimMint(bytes32 depositId) internal virtual {\n    Depositor memory depositor = depositIdToDepositor[depositId];\n    // Revert if priceId is not set\n    if (depositor.priceId == 0) {\n      revert PriceIdNotSet();\n    }\n\n    uint256 price = pricer.getPrice(depositor.priceId);\n    uint256 rwaOwed = _getMintAmountForPrice(\n      depositor.amountDepositedMinusFees,\n      price\n    );\n\n    delete depositIdToDepositor[depositId];\n    rwa.mint(depositor.user, rwaOwed);\n\n    emit MintCompleted(\n      depositor.user,\n      depositId,\n      rwaOwed,\n      depositor.amountDepositedMinusFees,\n      price,\n      depositor.priceId\n    );\n  }\n\n  /**\n   * @notice Function used by users to request a redemption from the fund\n   *\n   * @param amount The amount (in units of `rwa`) that a user wishes to redeem\n   *               from the fund\n   */\n  function requestRedemption(\n    uint256 amount\n  ) external virtual nonReentrant ifNotPaused(redemptionPaused) {\n    if (amount < minimumRedemptionAmount) {\n      revert RedemptionTooSmall();\n    }\n    bytes32 redemptionId = bytes32(redemptionRequestCounter++);\n    redemptionIdToRedeemer[redemptionId] = Redeemer(msg.sender, amount, 0);\n\n    rwa.burnFrom(msg.sender, amount);\n\n    emit RedemptionRequested(msg.sender, redemptionId, amount);\n  }\n\n  /**\n   * @notice Function to claim collateral corresponding to a redemption request\n   *\n   * @param redemptionIds an Array of redemption Id's which ought to fulfilled\n   *\n   * @dev Implicitly does all checks present in underlying `rwa`\n   * @dev The price Id corresponding to a redemptionId must be set prior to\n   *      claiming a redemption\n   */\n  function claimRedemption(\n    bytes32[] calldata redemptionIds\n  ) external virtual nonReentrant ifNotPaused(redemptionPaused) {\n    uint256 fees;\n    uint256 redemptionsSize = redemptionIds.length;\n    for (uint256 i = 0; i < redemptionsSize; ++i) {\n      Redeemer memory member = redemptionIdToRedeemer[redemptionIds[i]];\n      _checkRestrictions(member.user);\n      if (member.priceId == 0) {\n        // Then the price for this redemption has not been set\n        revert PriceIdNotSet();\n      }\n\n      // Calculate collateral due and fees\n      uint256 price = pricer.getPrice(member.priceId);\n      uint256 collateralDue = _getRedemptionAmountForRwa(\n        member.amountRwaTokenBurned,\n        price\n      );\n      uint256 fee = _getRedemptionFees(collateralDue);\n      uint256 collateralDuePostFees = collateralDue - fee;\n      fees += fee;\n\n      delete redemptionIdToRedeemer[redemptionIds[i]];\n\n      collateral.safeTransferFrom(\n        assetSender,\n        member.user,\n        collateralDuePostFees\n      );\n\n      emit RedemptionCompleted(\n        member.user,\n        redemptionIds[i],\n        member.amountRwaTokenBurned,\n        collateralDuePostFees,\n        price\n      );\n    }\n    if (fees > 0) {\n      collateral.safeTransferFrom(assetSender, feeRecipient, fees);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                         Relayer Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Adds a deposit proof to the contract\n   *\n   * @param txHash                The transaction hash of the deposit\n   * @param user                  The address of the user who made the deposit\n   * @param depositAmountAfterFee The amount of the deposit after fees\n   * @param feeAmount             The amount of the fees taken\n   * @param timestamp             The timestamp of the deposit\n   *\n   * @dev txHash is used as the depositId in storage\n   * @dev All amounts are in decimals of `collateral`\n   */\n  function addProof(\n    bytes32 txHash,\n    address user,\n    uint256 depositAmountAfterFee,\n    uint256 feeAmount,\n    uint256 timestamp\n  ) external override onlyRole(RELAYER_ROLE) checkRestrictions(user) {\n    if (depositIdToDepositor[txHash].user != address(0)) {\n      revert DepositProofAlreadyExists();\n    }\n    depositIdToDepositor[txHash] = Depositor(user, depositAmountAfterFee, 0);\n    emit DepositProofAdded(\n      txHash,\n      user,\n      depositAmountAfterFee,\n      feeAmount,\n      timestamp\n    );\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                           PriceId Setters\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Admin function to associate a depositId with a given Price Id\n   *\n   * @param depositIds an Array of deposit Ids to be associated\n   * @param priceIds   an Array of price Ids to be associated\n   *\n   * @dev Array size must match\n   */\n  function setPriceIdForDeposits(\n    bytes32[] calldata depositIds,\n    uint256[] calldata priceIds\n  ) external virtual onlyRole(PRICE_ID_SETTER_ROLE) {\n    uint256 depositsSize = depositIds.length;\n    if (depositsSize != priceIds.length) {\n      revert ArraySizeMismatch();\n    }\n    for (uint256 i = 0; i < depositsSize; ++i) {\n      if (depositIdToDepositor[depositIds[i]].user == address(0)) {\n        revert DepositorNull();\n      }\n      if (depositIdToDepositor[depositIds[i]].priceId != 0) {\n        revert PriceIdAlreadySet();\n      }\n      depositIdToDepositor[depositIds[i]].priceId = priceIds[i];\n      emit PriceIdSetForDeposit(depositIds[i], priceIds[i]);\n    }\n  }\n\n  /**\n   * @notice Admin function to associate redemptionId with a given priceId\n   *\n   * @param redemptionIds an Array of redemptionIds to associate\n   * @param priceIds  an Array of priceIds to associate\n   */\n  function setPriceIdForRedemptions(\n    bytes32[] calldata redemptionIds,\n    uint256[] calldata priceIds\n  ) external virtual onlyRole(PRICE_ID_SETTER_ROLE) {\n    uint256 redemptionsSize = redemptionIds.length;\n    if (redemptionsSize != priceIds.length) {\n      revert ArraySizeMismatch();\n    }\n    for (uint256 i = 0; i < redemptionsSize; ++i) {\n      if (redemptionIdToRedeemer[redemptionIds[i]].priceId != 0) {\n        revert PriceIdAlreadySet();\n      }\n      redemptionIdToRedeemer[redemptionIds[i]].priceId = priceIds[i];\n      emit PriceIdSetForRedemption(redemptionIds[i], priceIds[i]);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                           Admin Setters\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Admin function to overwrite entries in the depoitIdToDepositor\n   *         mapping\n   *\n   * @param depositIdToOverwrite  The depositId of the entry we wish to\n   *                              overwrite\n   * @param user                  The user for the new entry\n   * @param depositAmountAfterFee The deposit value for the new entry\n   * @param priceId               The priceId to be associated with the new\n   *                              entry\n   */\n  function overwriteDepositor(\n    bytes32 depositIdToOverwrite,\n    address user,\n    uint256 depositAmountAfterFee,\n    uint256 priceId\n  ) external onlyRole(MANAGER_ADMIN) checkRestrictions(user) {\n    Depositor memory oldDepositor = depositIdToDepositor[depositIdToOverwrite];\n\n    depositIdToDepositor[depositIdToOverwrite] = Depositor(\n      user,\n      depositAmountAfterFee,\n      priceId\n    );\n\n    emit DepositorOverwritten(\n      depositIdToOverwrite,\n      oldDepositor.user,\n      user,\n      oldDepositor.priceId,\n      priceId,\n      oldDepositor.amountDepositedMinusFees,\n      depositAmountAfterFee\n    );\n  }\n\n  /**\n   * @notice Admin function to overwrite entries in the redemptionIdToRedeemer\n   *         mapping\n   *\n   * @param redemptionIdToOverwrite The redemptionId of the entry we wish to\n   *                                overwrite\n   * @param user                    The user for the new entry\n   * @param rwaTokenAmountBurned    The burn amount for the new entry\n   * @param priceId                 The priceID to be associated with the new\n   *                                entry\n   */\n  function overwriteRedeemer(\n    bytes32 redemptionIdToOverwrite,\n    address user,\n    uint256 rwaTokenAmountBurned,\n    uint256 priceId\n  ) external onlyRole(MANAGER_ADMIN) checkRestrictions(user) {\n    Redeemer memory oldRedeemer = redemptionIdToRedeemer[\n      redemptionIdToOverwrite\n    ];\n    redemptionIdToRedeemer[redemptionIdToOverwrite] = Redeemer(\n      user,\n      rwaTokenAmountBurned,\n      priceId\n    );\n    emit RedeemerOverwritten(\n      redemptionIdToOverwrite,\n      oldRedeemer.user,\n      user,\n      oldRedeemer.priceId,\n      priceId,\n      oldRedeemer.amountRwaTokenBurned,\n      rwaTokenAmountBurned\n    );\n  }\n\n  /**\n   * @notice Admin function to set the minimum amount to redeem\n   *\n   * @param _minimumRedemptionAmount The minimum amount required to submit a\n   *                                 redemption request\n   */\n  function setMinimumRedemptionAmount(\n    uint256 _minimumRedemptionAmount\n  ) external onlyRole(MANAGER_ADMIN) {\n    if (_minimumRedemptionAmount < BPS_DENOMINATOR) {\n      revert AmountTooSmall();\n    }\n    uint256 oldRedeemMinimum = minimumRedemptionAmount;\n    minimumRedemptionAmount = _minimumRedemptionAmount;\n    emit MinimumRedemptionAmountSet(oldRedeemMinimum, _minimumRedemptionAmount);\n  }\n\n  /**\n   * @notice Admin function to set the minimum amount required for a deposit\n   *\n   * @param minDepositAmount The minimum amount required to submit a deposit\n   *                         request\n   */\n  function setMinimumDepositAmount(\n    uint256 minDepositAmount\n  ) external onlyRole(MANAGER_ADMIN) {\n    if (minDepositAmount < BPS_DENOMINATOR) {\n      revert AmountTooSmall();\n    }\n    uint256 oldMinimumDepositAmount = minimumDepositAmount;\n    minimumDepositAmount = minDepositAmount;\n    emit MinimumDepositAmountSet(oldMinimumDepositAmount, minDepositAmount);\n  }\n\n  /**\n   * @notice Admin function to set the mint fee\n   *\n   * @param _mintFee The new mint fee specified in basis points\n   *\n   * @dev The maximum fee that can be set is 10_000 bps, or 100%\n   */\n  function setMintFee(uint256 _mintFee) external onlyRole(MANAGER_ADMIN) {\n    if (_mintFee > BPS_DENOMINATOR) {\n      revert FeeTooLarge();\n    }\n    uint256 oldMintFee = mintFee;\n    mintFee = _mintFee;\n    emit MintFeeSet(oldMintFee, _mintFee);\n  }\n\n  /**\n   * @notice Admin function to set the redeem fee\n   *\n   * @param _redemptionFee The new redeem fee specified in basis points\n   *\n   * @dev The maximum fee that can be set is 10_000 bps, or 100%\n   */\n  function setRedemptionFee(\n    uint256 _redemptionFee\n  ) external onlyRole(MANAGER_ADMIN) {\n    if (_redemptionFee > BPS_DENOMINATOR) {\n      revert FeeTooLarge();\n    }\n    uint256 oldRedeemFee = redemptionFee;\n    redemptionFee = _redemptionFee;\n    emit RedemptionFeeSet(oldRedeemFee, _redemptionFee);\n  }\n\n  /**\n   * @notice Admin function to set the address of the Pricer contract\n   *\n   * @param newPricer The address of the new pricer contract\n   */\n  function setPricer(address newPricer) external onlyRole(MANAGER_ADMIN) {\n    address oldPricer = address(pricer);\n    pricer = IPricerReader(newPricer);\n    emit NewPricerSet(oldPricer, newPricer);\n  }\n\n  /**\n   * @notice Admin function to set the address of `feeRecipient`\n   *\n   * @param newFeeRecipient The address of the new `feeRecipient`\n   */\n  function setFeeRecipient(\n    address newFeeRecipient\n  ) external onlyRole(MANAGER_ADMIN) {\n    address oldFeeRecipient = feeRecipient;\n    feeRecipient = newFeeRecipient;\n    emit FeeRecipientSet(oldFeeRecipient, feeRecipient);\n  }\n\n  /**\n   * @notice Admin function to set the address of `assetSender`\n   *\n   * @param newAssetSender The address of the new `assetSender`\n   */\n  function setAssetSender(\n    address newAssetSender\n  ) external onlyRole(MANAGER_ADMIN) {\n    address oldAssetSender = assetSender;\n    assetSender = newAssetSender;\n    emit AssetSenderSet(oldAssetSender, newAssetSender);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            Pause Utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Modifier to check if a feature is paused\n   *\n   * @param feature The feature to check if paused\n   */\n  modifier ifNotPaused(bool feature) {\n    if (feature) {\n      revert FeaturePaused();\n    }\n    _;\n  }\n\n  /**\n   * @notice Function to pause subscription to RWAHub\n   */\n  function pauseSubscription() external onlyRole(PAUSER_ADMIN) {\n    subscriptionPaused = true;\n    emit SubscriptionPaused(msg.sender);\n  }\n\n  /**\n   * @notice Function to pause redemptions to RWAHub\n   */\n  function pauseRedemption() external onlyRole(PAUSER_ADMIN) {\n    redemptionPaused = true;\n    emit RedemptionPaused(msg.sender);\n  }\n\n  /**\n   * @notice Function to unpause subscriptions to RWAHub\n   */\n  function unpauseSubscription() external onlyRole(MANAGER_ADMIN) {\n    subscriptionPaused = false;\n    emit SubscriptionUnpaused(msg.sender);\n  }\n\n  /**\n   * @notice Function to unpause redemptions to RWAHub\n   */\n  function unpauseRedemption() external onlyRole(MANAGER_ADMIN) {\n    redemptionPaused = false;\n    emit RedemptionUnpaused(msg.sender);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      Check Restriction Utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Modifier to check restrictions status of an account\n   *\n   * @param account The account to check\n   */\n  modifier checkRestrictions(address account) {\n    _checkRestrictions(account);\n    _;\n  }\n\n  /**\n   * @notice internal function to check restriction status\n   *         of an address\n   *\n   * @param account The account to check restriction status for\n   *\n   * @dev This function is virtual to be overridden by child contract\n   *      to check restrictions on a more granular level\n   */\n  function _checkRestrictions(address account) internal view virtual;\n\n  /*//////////////////////////////////////////////////////////////\n                           Math Utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Given amount of `collateral`, returns how much in fees\n   *         are owed\n   *\n   *\n   * @param collateralAmount Amount `collateral` to calculate fees\n   *                         (in decimals of `collateral`)\n   */\n  function _getMintFees(\n    uint256 collateralAmount\n  ) internal view returns (uint256) {\n    return (collateralAmount * mintFee) / BPS_DENOMINATOR;\n  }\n\n  /**\n   * @notice Given amount of `collateral`, returns how much in fees\n   *         are owed\n   *\n   * @param collateralAmount Amount of `collateral` to calculate fees\n   *                         (in decimals of `collateral`)\n   */\n  function _getRedemptionFees(\n    uint256 collateralAmount\n  ) internal view returns (uint256) {\n    return (collateralAmount * redemptionFee) / BPS_DENOMINATOR;\n  }\n\n  /**\n   * @notice Given a deposit amount and priceId, returns the amount\n   *         of `rwa` due\n   *\n   * @param depositAmt The amount deposited in units of `collateral`\n   * @param price      The price associated with this deposit\n   */\n  function _getMintAmountForPrice(\n    uint256 depositAmt,\n    uint256 price\n  ) internal view returns (uint256 rwaAmountOut) {\n    uint256 amountE36 = _scaleUp(depositAmt) * 1e18;\n    // Will revert with div by 0 if price not defined for a priceId\n    rwaAmountOut = amountE36 / price;\n  }\n\n  /**\n   * @notice Given a redemption amount and a priceId, returns the amount\n   *         of `collateral` due\n   *\n   * @param rwaTokenAmountBurned The amount of `rwa` burned for a redemption\n   * @param price                The price associated with this redemption\n   */\n  function _getRedemptionAmountForRwa(\n    uint256 rwaTokenAmountBurned,\n    uint256 price\n  ) internal view returns (uint256 collateralOwed) {\n    uint256 amountE36 = rwaTokenAmountBurned * price;\n    collateralOwed = _scaleDown(amountE36 / 1e18);\n  }\n\n  /**\n   * @notice Scale provided amount up by `decimalsMultiplier`\n   *\n   * @dev This helper is used for converting the collateral's decimals\n   *      representation to the RWA amount decimals representation.\n   */\n  function _scaleUp(uint256 amount) internal view returns (uint256) {\n    return amount * decimalsMultiplier;\n  }\n\n  /**\n   * @notice Scale provided amount down by `decimalsMultiplier`\n   *\n   * @dev This helper is used for converting `rwa`'s decimal\n   *      representation to the `collateral`'s decimal representation\n   */\n  function _scaleDown(uint256 amount) internal view returns (uint256) {\n    return amount / decimalsMultiplier;\n  }\n}\n"
    },
    "contracts/interfaces/IRWAHubNonStableInstantMint.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IRWAHub.sol\";\n\ninterface IRWAHubNonStableInstantMint {\n  /**\n   * @notice Event emitted when an instant mint is completed\n   *\n   * @param user                      The address of the user\n   * @param collateralAmountDeposited The amount of collateral deposited\n   * @param collateralAmountAfterFees The amount of collateral after fees\n   * @param feesInCollateral          The amount of fees in collateral\n   * @param rwaGiven                  The amount of rwa minted to the user\n   * @param priceMinted               The price at which the rwa was minted at\n   * @param depositId                 The id of the deposit in RWAHub\n   */\n  event InstantMint(\n    address indexed user,\n    uint256 collateralAmountDeposited,\n    uint256 collateralAmountAfterFees,\n    uint256 feesInCollateral,\n    uint256 rwaGiven,\n    uint256 priceMinted,\n    bytes32 depositId\n  );\n\n  /**\n   * @notice Event emitted when the excess of the instant mint is claimed\n   *\n   * @param user           The address of the user\n   * @param totalRWAOwed   The total amount of rwa owed (instant mint + excess)\n   * @param rwaExcessDue   The amount of excess rwa owed\n   * @param rwaExcessGiven The amount of rwa excess given in this claim\n   * @param priceClaimed   The price at which the excess rwa was claimed at\n   * @param depositId      The id of the deposit in RWAHub\n   */\n  event ExcessMintClaimed(\n    address indexed user,\n    uint256 totalRWAOwed,\n    uint256 rwaExcessDue,\n    uint256 rwaExcessGiven,\n    uint256 priceClaimed,\n    bytes32 depositId\n  );\n\n  /**\n   * @notice Event emitted when instant mint given is overriden\n   *\n   * @param depositId   The id of the deposit in RWAHub\n   * @param oldGivenAmt The old amount of rwa given\n   * @param newGivenAmt The new amount of rwa given\n   */\n  event InstantMintGivenOverriden(\n    bytes32 indexed depositId,\n    uint256 oldGivenAmt,\n    uint256 newGivenAmt\n  );\n\n  /**\n   * @notice Event emitted when instant mint asset manager is set\n   *\n   * @param oldInstantMintAssetManager Old instant mint asset manager\n   * @param newInstantMintAssetManager New instant mint asset manager\n   */\n  event InstantMintAssetManagerSet(\n    address oldInstantMintAssetManager,\n    address newInstantMintAssetManager\n  );\n\n  /**\n   * @notice Event emitted when instant mint amount % (in bps) is set\n   *\n   * @param oldInstantMintBps Old instant mint amount in bps\n   * @param newInstantMintBps New instant mint amount in bps\n   */\n  event InstantMintAmountSet(\n    uint256 oldInstantMintBps,\n    uint256 newInstantMintBps\n  );\n\n  /**\n   * @notice Event emitted when instant mints are paused\n   *\n   * @param caller Address which initiated the pause\n   */\n  event InstantMintPaused(address caller);\n\n  /**\n   * @notice Event emitted when instant mints are unpaused\n   *\n   * @param caller Address which initiated the unpause\n   */\n  event InstantMintUnpaused(address caller);\n\n  /**\n   * @notice Event emitted when claiming excess is paused\n   *\n   * @param caller Address which initiated the pause\n   */\n  event ClaimExcessPaused(address caller);\n\n  /**\n   * @notice Event emitted when claiming excess is unpaused\n   *\n   * @param caller Address which initiated the unpause\n   */\n  event ClaimExcessUnpaused(address caller);\n\n  /**\n   * @notice Event emitted when instant mint fee is set\n   *\n   * @param oldFee Old fee\n   * @param newFee New fee\n   *\n   * @dev See inheriting contract for decimals representation\n   */\n  event InstantMintFeeSet(uint256 oldFee, uint256 newFee);\n\n  // Errors\n  error CannotClaimExcess();\n  error CannotClaimMint();\n}\n"
    },
    "contracts/interfaces/IPricerReader.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\ninterface IPricerReader {\n  /**\n   * @notice Gets the latest price of the asset\n   *\n   * @return uint256 The latest price of the asset\n   */\n  function getLatestPrice() external view returns (uint256);\n\n  /**\n   * @notice Gets the price of the asset at a specific priceId\n   *\n   * @param priceId The priceId at which to get the price\n   *\n   * @return uint256 The price of the asset with the given priceId\n   */\n  function getPrice(uint256 priceId) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IRWALike.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n */\npragma solidity 0.8.16;\n\n// This interface is not inherited directly by RWA, instead, it is a\n// subset of functions provided by all RWA tokens that the RWA Hub\n// Client uses.\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\n\ninterface IRWALike is IERC20 {\n  function mint(address to, uint256 amount) external;\n\n  function burn(address from, uint256 amount) external;\n\n  function burn(uint256 amount) external;\n\n  function burnFrom(address from, uint256 amount) external;\n\n  function grantRole(bytes32, address) external;\n}\n"
    },
    "contracts/external/openzeppelin/contracts/token/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `to`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `from` to `to` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/external/openzeppelin/contracts/token/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\nimport \"contracts/external/openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  using Address for address;\n\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.transfer.selector, to, value)\n    );\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n    );\n  }\n\n  /**\n   * @dev Deprecated. This function has issues similar to the ones found in\n   * {IERC20-approve}, and its usage is discouraged.\n   *\n   * Whenever possible, use {safeIncreaseAllowance} and\n   * {safeDecreaseAllowance} instead.\n   */\n  function safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.approve.selector, spender, value)\n    );\n  }\n\n  function safeIncreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n    );\n  }\n\n  function safeDecreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    unchecked {\n      uint256 oldAllowance = token.allowance(address(this), spender);\n      require(\n        oldAllowance >= value,\n        \"SafeERC20: decreased allowance below zero\"\n      );\n      uint256 newAllowance = oldAllowance - value;\n      _callOptionalReturn(\n        token,\n        abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n      );\n    }\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\n   * @param token The token targeted by the call.\n   * @param data The call data (encoded using abi.encode or one of its variants).\n   */\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n    // the target address contains contract code and also asserts for success in the low-level call.\n\n    bytes memory returndata =\n      address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n    if (returndata.length > 0) {\n      // Return data is optional\n      require(\n        abi.decode(returndata, (bool)),\n        \"SafeERC20: ERC20 operation did not succeed\"\n      );\n    }\n  }\n}\n"
    },
    "contracts/interfaces/IRWAHub.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n */\npragma solidity 0.8.16;\n\ninterface IRWAHub {\n  // Struct to contain the deposit information for a given depositId\n  struct Depositor {\n    address user;\n    uint256 amountDepositedMinusFees;\n    uint256 priceId;\n  }\n\n  // Struc to contain withdrawal infromation for a given redemptionId\n  struct Redeemer {\n    address user;\n    uint256 amountRwaTokenBurned;\n    uint256 priceId;\n  }\n\n  function requestSubscription(uint256 amount) external;\n\n  function claimMint(bytes32[] calldata depositIds) external;\n\n  function requestRedemption(uint256 amount) external;\n\n  function claimRedemption(bytes32[] calldata redemptionIds) external;\n\n  function addProof(\n    bytes32 txHash,\n    address user,\n    uint256 depositAmountAfterFee,\n    uint256 feeAmount,\n    uint256 timestamp\n  ) external;\n\n  function setPriceIdForDeposits(\n    bytes32[] calldata depositIds,\n    uint256[] calldata priceIds\n  ) external;\n\n  function setPriceIdForRedemptions(\n    bytes32[] calldata redemptionIds,\n    uint256[] calldata priceIds\n  ) external;\n\n  function setPricer(address newPricer) external;\n\n  function overwriteDepositor(\n    bytes32 depositIdToOverride,\n    address user,\n    uint256 depositAmountAfterFee,\n    uint256 priceId\n  ) external;\n\n  function overwriteRedeemer(\n    bytes32 redemptionIdToOverride,\n    address user,\n    uint256 rwaTokenAmountBurned,\n    uint256 priceId\n  ) external;\n\n  /**\n   * @notice Event emitted when fee recipient is set\n   *\n   * @param oldFeeRecipient Old fee recipient\n   * @param newFeeRecipient New fee recipient\n   */\n  event FeeRecipientSet(address oldFeeRecipient, address newFeeRecipient);\n\n  /**\n   * @notice Event emitted when the assetSender is changed\n   *\n   * @param oldAssetSender The address of the old assetSender\n   * @param newAssetSender The address of the new assetSender\n   */\n  event AssetSenderSet(address oldAssetSender, address newAssetSender);\n\n  /**\n   * @notice Event emitted when minimum deposit amount is set\n   *\n   * @param oldMinimum Old minimum\n   * @param newMinimum New minimum\n   *\n   * @dev See inheriting contract for decimals representation\n   */\n  event MinimumDepositAmountSet(uint256 oldMinimum, uint256 newMinimum);\n\n  /**\n   * @notice Event emitted when a new redeem minimum is set.\n   *         All units are in 1e18\n   *\n   * @param oldRedemptionMin The old redeem minimum value\n   * @param newRedemptionMin The new redeem minimum value\n   */\n  event MinimumRedemptionAmountSet(\n    uint256 oldRedemptionMin,\n    uint256 newRedemptionMin\n  );\n\n  /**\n   * @notice Event emitted when mint fee is set\n   *\n   * @param oldFee Old fee\n   * @param newFee New fee\n   *\n   * @dev See inheriting contract for decimals representation\n   */\n  event MintFeeSet(uint256 oldFee, uint256 newFee);\n\n  /**\n   * @notice Event emitted when redeem fee is set\n   *\n   * @param oldFee Old fee\n   * @param newFee New fee\n   *\n   * @dev see inheriting contract for decimal representation\n   */\n  event RedemptionFeeSet(uint256 oldFee, uint256 newFee);\n\n  /**\n   * @notice Event emitted when redemption request is submitted\n   *\n   * @param user         The user submitting the redemption request\n   * @param redemptionId The id corresponding to a given redemption\n   * @param rwaAmountIn The amount of cash being burned\n   */\n  event RedemptionRequested(\n    address indexed user,\n    bytes32 indexed redemptionId,\n    uint256 rwaAmountIn\n  );\n\n  /**\n   * @notice Event emitted when a mint request is submitted\n   *\n   * @param user                      The user requesting to mint\n   * @param depositId                 The depositId of the request\n   * @param collateralAmountDeposited The total amount deposited\n   * @param depositAmountAfterFee     The value deposited - fee\n   * @param feeAmount                 The fee amount taken\n   *                                  (units of collateral)\n   */\n  event MintRequested(\n    address indexed user,\n    bytes32 indexed depositId,\n    uint256 collateralAmountDeposited,\n    uint256 depositAmountAfterFee,\n    uint256 feeAmount\n  );\n\n  /**\n   * @notice Event emitted when a redemption request is completed\n   *\n   * @param user                     The address of the user getting the funds\n   * @param redemptionId             The id corresponding to a given redemption\n   *                                 requested\n   * @param rwaAmountRequested       Amount of RWA originally requested by the user\n   * @param collateralAmountReturned Amount of collateral received by the user\n   * @param price                    The price at which the redemption was\n   *                                 serviced at\n   */\n  event RedemptionCompleted(\n    address indexed user,\n    bytes32 indexed redemptionId,\n    uint256 rwaAmountRequested,\n    uint256 collateralAmountReturned,\n    uint256 price\n  );\n\n  /**\n   * @notice Event emitted when a Mint request is completed\n   *\n   * @param user                      The address of the user getting the funds\n   * @param depositId                 The depositId of the mint request\n   * @param rwaAmountOut              The amount of RWA token minted to the\n   *                                  user\n   * @param collateralAmountDeposited The amount of collateral deposited\n   * @param price                     The price set for the given\n   *                                  deposit id\n   * @param priceId                   The priceId used to determine price\n   */\n  event MintCompleted(\n    address indexed user,\n    bytes32 indexed depositId,\n    uint256 rwaAmountOut,\n    uint256 collateralAmountDeposited,\n    uint256 price,\n    uint256 priceId\n  );\n\n  /**\n   * @notice Event emitted when a deposit has its corresponding priceId set\n   *\n   * @param depositIdSet The Deposit Id for which the price Id is being set\n   * @param priceIdSet   The price Id being associate with a deposit Id\n   */\n  event PriceIdSetForDeposit(\n    bytes32 indexed depositIdSet,\n    uint256 indexed priceIdSet\n  );\n\n  /**\n   * @notice Event Emitted when a redemption has its corresponding priceId set\n   *\n   * @param redemptionIdSet The Redemption Id for which the price Id is being\n   *                        set\n   * @param priceIdSet      The Price Id being associated with a redemption Id\n   */\n  event PriceIdSetForRedemption(\n    bytes32 indexed redemptionIdSet,\n    uint256 indexed priceIdSet\n  );\n\n  /**\n   * @notice Event emitted when a new Pricer contract is set\n   *\n   * @param oldPricer The address of the old pricer contract\n   * @param newPricer The address of the new pricer contract\n   */\n  event NewPricerSet(address oldPricer, address newPricer);\n\n  /**\n   * @notice Event emitted when deposit proof has been added\n   *\n   * @param txHash                Tx hash of the deposit\n   * @param user                  Address of the user who made the deposit\n   * @param depositAmountAfterFee Amount of the deposit after fees\n   * @param feeAmount             Amount of fees taken\n   * @param timestamp             Timestamp of the deposit\n   */\n  event DepositProofAdded(\n    bytes32 indexed txHash,\n    address indexed user,\n    uint256 depositAmountAfterFee,\n    uint256 feeAmount,\n    uint256 timestamp\n  );\n\n  /**\n   * @notice Event emitted when subscriptions are paused\n   *\n   * @param caller Address which initiated the pause\n   */\n  event SubscriptionPaused(address caller);\n\n  /**\n   * @notice Event emitted when redemptions are paused\n   *\n   * @param caller Address which initiated the pause\n   */\n  event RedemptionPaused(address caller);\n\n  /**\n   * @notice Event emitted when subscriptions are unpaused\n   *\n   * @param caller Address which initiated the unpause\n   */\n  event SubscriptionUnpaused(address caller);\n\n  /**\n   * @notice Event emitted when redemptions are unpaused\n   *\n   * @param caller Address which initiated the unpause\n   */\n  event RedemptionUnpaused(address caller);\n\n  event DepositorOverwritten(\n    bytes32 indexed depositId,\n    address oldDepositor,\n    address newDepositor,\n    uint256 oldPriceId,\n    uint256 newPriceId,\n    uint256 oldDepositAmount,\n    uint256 newDepositAmount\n  );\n\n  event RedeemerOverwritten(\n    bytes32 indexed redemptionId,\n    address oldRedeemer,\n    address newRedeemer,\n    uint256 oldPriceId,\n    uint256 newPriceId,\n    uint256 oldRWATokenAmountBurned,\n    uint256 newRWATokenAmountBurned\n  );\n\n  /// ERRORS ///\n  error PriceIdNotSet();\n  error ArraySizeMismatch();\n  error DepositTooSmall();\n  error RedemptionTooSmall();\n  error TxnAlreadyValidated();\n  error CollateralCannotBeZero();\n  error RWACannotBeZero();\n  error AssetSenderCannotBeZero();\n  error FeeRecipientCannotBeZero();\n  error FeeTooLarge();\n  error AmountTooSmall();\n  error DepositorNull();\n  error RedeemerNull();\n  error DepositProofAlreadyExists();\n  error FeaturePaused();\n  error PriceIdAlreadySet();\n}\n"
    },
    "contracts/external/openzeppelin/contracts/token/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the decimals places of the token.\n   */\n  function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/external/openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts/access/IAccessControlEnumerable.sol\";\nimport \"contracts/external/openzeppelin/contracts/access/AccessControl.sol\";\nimport \"contracts/external/openzeppelin/contracts/utils/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is\n  IAccessControlEnumerable,\n  AccessControl\n{\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return\n      interfaceId == type(IAccessControlEnumerable).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev Returns one of the accounts that have `role`. `index` must be a\n   * value between 0 and {getRoleMemberCount}, non-inclusive.\n   *\n   * Role bearers are not sorted in any particular way, and their ordering may\n   * change at any point.\n   *\n   * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n   * you perform all queries on the same block. See the following\n   * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n   * for more information.\n   */\n  function getRoleMember(bytes32 role, uint256 index)\n    public\n    view\n    virtual\n    override\n    returns (address)\n  {\n    return _roleMembers[role].at(index);\n  }\n\n  /**\n   * @dev Returns the number of accounts that have `role`. Can be used\n   * together with {getRoleMember} to enumerate all bearers of a role.\n   */\n  function getRoleMemberCount(bytes32 role)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _roleMembers[role].length();\n  }\n\n  /**\n   * @dev Overload {_grantRole} to track enumerable memberships\n   */\n  function _grantRole(bytes32 role, address account) internal virtual override {\n    super._grantRole(role, account);\n    _roleMembers[role].add(account);\n  }\n\n  /**\n   * @dev Overload {_revokeRole} to track enumerable memberships\n   */\n  function _revokeRole(bytes32 role, address account)\n    internal\n    virtual\n    override\n  {\n    super._revokeRole(role, account);\n    _roleMembers[role].remove(account);\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n  // Booleans are more expensive than uint256 or any type that takes up a full\n  // word because each write operation emits an extra SLOAD to first read the\n  // slot's contents, replace the bits taken up by the boolean, and then write\n  // back. This is the compiler's defense against contract upgrades and\n  // pointer aliasing, and it cannot be disabled.\n\n  // The values being non-zero value makes deployment a bit more expensive,\n  // but in exchange the refund on every call to nonReentrant will be lower in\n  // amount. Since refunds are capped to a percentage of the total\n  // transaction's gas, it is best to keep them low in cases like this one, to\n  // increase the likelihood of the full refund coming into effect.\n  uint256 private constant _NOT_ENTERED = 1;\n  uint256 private constant _ENTERED = 2;\n\n  uint256 private _status;\n\n  constructor() {\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   *\n   * [IMPORTANT]\n   * ====\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\n   *\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n   * constructor.\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(\n      success,\n      \"Address: unable to send value, recipient may have reverted\"\n    );\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n   * plain `call` is an unsafe replacement for a function call: use this\n   * function instead.\n   *\n   * If `target` reverts with a revert reason, it is bubbled up by this\n   * function (like regular Solidity function calls).\n   *\n   * Returns the raw returned data. To convert to the expected return value,\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n   *\n   * Requirements:\n   *\n   * - `target` must be a contract.\n   * - calling `target` with `data` must not revert.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(address target, bytes memory data)\n    internal\n    returns (bytes memory)\n  {\n    return functionCall(target, data, \"Address: low-level call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n   * `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but also transferring `value` wei to `target`.\n   *\n   * Requirements:\n   *\n   * - the calling contract must have an ETH balance of at least `value`.\n   * - the called Solidity function must be `payable`.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return\n      functionCallWithValue(\n        target,\n        data,\n        value,\n        \"Address: low-level call with value failed\"\n      );\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(\n      address(this).balance >= value,\n      \"Address: insufficient balance for call\"\n    );\n    require(isContract(target), \"Address: call to non-contract\");\n\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(address target, bytes memory data)\n    internal\n    view\n    returns (bytes memory)\n  {\n    return\n      functionStaticCall(target, data, \"Address: low-level static call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    require(isContract(target), \"Address: static call to non-contract\");\n\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(address target, bytes memory data)\n    internal\n    returns (bytes memory)\n  {\n    return\n      functionDelegateCall(\n        target,\n        data,\n        \"Address: low-level delegate call failed\"\n      );\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(isContract(target), \"Address: delegate call to non-contract\");\n\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n   * revert reason using the provided one.\n   *\n   * _Available since v4.3._\n   */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts/access/IAccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts/access/IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n  /**\n   * @dev Returns one of the accounts that have `role`. `index` must be a\n   * value between 0 and {getRoleMemberCount}, non-inclusive.\n   *\n   * Role bearers are not sorted in any particular way, and their ordering may\n   * change at any point.\n   *\n   * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n   * you perform all queries on the same block. See the following\n   * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n   * for more information.\n   */\n  function getRoleMember(bytes32 role, uint256 index)\n    external\n    view\n    returns (address);\n\n  /**\n   * @dev Returns the number of accounts that have `role`. Can be used\n   * together with {getRoleMember} to enumerate all bearers of a role.\n   */\n  function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "contracts/external/openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"contracts/external/openzeppelin/contracts/utils/Context.sol\";\nimport \"contracts/external/openzeppelin/contracts/utils/Strings.sol\";\nimport \"contracts/external/openzeppelin/contracts/utils/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n  struct RoleData {\n    mapping(address => bool) members;\n    bytes32 adminRole;\n  }\n\n  mapping(bytes32 => RoleData) private _roles;\n\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n  /**\n   * @dev Modifier that checks that an account has a specific role. Reverts\n   * with a standardized message including the required role.\n   *\n   * The format of the revert reason is given by the following regular expression:\n   *\n   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n   *\n   * _Available since v4.1._\n   */\n  modifier onlyRole(bytes32 role) {\n    _checkRole(role, _msgSender());\n    _;\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return\n      interfaceId == type(IAccessControl).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev Returns `true` if `account` has been granted `role`.\n   */\n  function hasRole(bytes32 role, address account)\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return _roles[role].members[account];\n  }\n\n  /**\n   * @dev Revert with a standard message if `account` is missing `role`.\n   *\n   * The format of the revert reason is given by the following regular expression:\n   *\n   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n   */\n  function _checkRole(bytes32 role, address account) internal view virtual {\n    if (!hasRole(role, account)) {\n      revert(\n        string(\n          abi.encodePacked(\n            \"AccessControl: account \",\n            Strings.toHexString(uint160(account), 20),\n            \" is missing role \",\n            Strings.toHexString(uint256(role), 32)\n          )\n        )\n      );\n    }\n  }\n\n  /**\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\n   * {revokeRole}.\n   *\n   * To change a role's admin, use {_setRoleAdmin}.\n   */\n  function getRoleAdmin(bytes32 role)\n    public\n    view\n    virtual\n    override\n    returns (bytes32)\n  {\n    return _roles[role].adminRole;\n  }\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function grantRole(bytes32 role, address account)\n    public\n    virtual\n    override\n    onlyRole(getRoleAdmin(role))\n  {\n    _grantRole(role, account);\n  }\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function revokeRole(bytes32 role, address account)\n    public\n    virtual\n    override\n    onlyRole(getRoleAdmin(role))\n  {\n    _revokeRole(role, account);\n  }\n\n  /**\n   * @dev Revokes `role` from the calling account.\n   *\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\n   * purpose is to provide a mechanism for accounts to lose their privileges\n   * if they are compromised (such as when a trusted device is misplaced).\n   *\n   * If the calling account had been revoked `role`, emits a {RoleRevoked}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must be `account`.\n   */\n  function renounceRole(bytes32 role, address account) public virtual override {\n    require(\n      account == _msgSender(),\n      \"AccessControl: can only renounce roles for self\"\n    );\n\n    _revokeRole(role, account);\n  }\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event. Note that unlike {grantRole}, this function doesn't perform any\n   * checks on the calling account.\n   *\n   * [WARNING]\n   * ====\n   * This function should only be called from the constructor when setting\n   * up the initial roles for the system.\n   *\n   * Using this function in any other way is effectively circumventing the admin\n   * system imposed by {AccessControl}.\n   * ====\n   *\n   * NOTE: This function is deprecated in favor of {_grantRole}.\n   */\n  function _setupRole(bytes32 role, address account) internal virtual {\n    _grantRole(role, account);\n  }\n\n  /**\n   * @dev Sets `adminRole` as ``role``'s admin role.\n   *\n   * Emits a {RoleAdminChanged} event.\n   */\n  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n    bytes32 previousAdminRole = getRoleAdmin(role);\n    _roles[role].adminRole = adminRole;\n    emit RoleAdminChanged(role, previousAdminRole, adminRole);\n  }\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * Internal function without access restriction.\n   */\n  function _grantRole(bytes32 role, address account) internal virtual {\n    if (!hasRole(role, account)) {\n      _roles[role].members[account] = true;\n      emit RoleGranted(role, account, _msgSender());\n    }\n  }\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * Internal function without access restriction.\n   */\n  function _revokeRole(bytes32 role, address account) internal virtual {\n    if (hasRole(role, account)) {\n      _roles[role].members[account] = false;\n      emit RoleRevoked(role, account, _msgSender());\n    }\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n  // To implement this library for multiple types with as little code\n  // repetition as possible, we write it in terms of a generic Set type with\n  // bytes32 values.\n  // The Set implementation uses private functions, and user-facing\n  // implementations (such as AddressSet) are just wrappers around the\n  // underlying Set.\n  // This means that we can only create new EnumerableSets for types that fit\n  // in bytes32.\n\n  struct Set {\n    // Storage of set values\n    bytes32[] _values;\n    // Position of the value in the `values` array, plus 1 because index 0\n    // means a value is not in the set.\n    mapping(bytes32 => uint256) _indexes;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function _add(Set storage set, bytes32 value) private returns (bool) {\n    if (!_contains(set, value)) {\n      set._values.push(value);\n      // The value is stored at length-1, but we add 1 to all indexes\n      // and use 0 as a sentinel value\n      set._indexes[value] = set._values.length;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\n    // We read and store the value's index to prevent multiple reads from the same storage slot\n    uint256 valueIndex = set._indexes[value];\n\n    if (valueIndex != 0) {\n      // Equivalent to contains(set, value)\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\n      // This modifies the order of the array, as noted in {at}.\n\n      uint256 toDeleteIndex = valueIndex - 1;\n      uint256 lastIndex = set._values.length - 1;\n\n      if (lastIndex != toDeleteIndex) {\n        bytes32 lastvalue = set._values[lastIndex];\n\n        // Move the last value to the index where the value to delete is\n        set._values[toDeleteIndex] = lastvalue;\n        // Update the index for the moved value\n        set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n      }\n\n      // Delete the slot where the moved value was stored\n      set._values.pop();\n\n      // Delete the index for the deleted slot\n      delete set._indexes[value];\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function _contains(Set storage set, bytes32 value)\n    private\n    view\n    returns (bool)\n  {\n    return set._indexes[value] != 0;\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n   */\n  function _length(Set storage set) private view returns (uint256) {\n    return set._values.length;\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\n    return set._values[index];\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function _values(Set storage set) private view returns (bytes32[] memory) {\n    return set._values;\n  }\n\n  // Bytes32Set\n\n  struct Bytes32Set {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _add(set._inner, value);\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(Bytes32Set storage set, bytes32 value)\n    internal\n    returns (bool)\n  {\n    return _remove(set._inner, value);\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(Bytes32Set storage set, bytes32 value)\n    internal\n    view\n    returns (bool)\n  {\n    return _contains(set._inner, value);\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(Bytes32Set storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(Bytes32Set storage set, uint256 index)\n    internal\n    view\n    returns (bytes32)\n  {\n    return _at(set._inner, index);\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(Bytes32Set storage set)\n    internal\n    view\n    returns (bytes32[] memory)\n  {\n    return _values(set._inner);\n  }\n\n  // AddressSet\n\n  struct AddressSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(AddressSet storage set, address value) internal returns (bool) {\n    return _add(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(AddressSet storage set, address value)\n    internal\n    returns (bool)\n  {\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(AddressSet storage set, address value)\n    internal\n    view\n    returns (bool)\n  {\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(AddressSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(AddressSet storage set, uint256 index)\n    internal\n    view\n    returns (address)\n  {\n    return address(uint160(uint256(_at(set._inner, index))));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(AddressSet storage set)\n    internal\n    view\n    returns (address[] memory)\n  {\n    bytes32[] memory store = _values(set._inner);\n    address[] memory result;\n\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // UintSet\n\n  struct UintSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\n    return _add(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\n    return _remove(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(UintSet storage set, uint256 value)\n    internal\n    view\n    returns (bool)\n  {\n    return _contains(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n   */\n  function length(UintSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(UintSet storage set, uint256 index)\n    internal\n    view\n    returns (uint256)\n  {\n    return uint256(_at(set._inner, index));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(UintSet storage set)\n    internal\n    view\n    returns (uint256[] memory)\n  {\n    bytes32[] memory store = _values(set._inner);\n    uint256[] memory result;\n\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n  /**\n   * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n   *\n   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n   * {RoleAdminChanged} not being emitted signaling this.\n   *\n   * _Available since v3.1._\n   */\n  event RoleAdminChanged(\n    bytes32 indexed role,\n    bytes32 indexed previousAdminRole,\n    bytes32 indexed newAdminRole\n  );\n\n  /**\n   * @dev Emitted when `account` is granted `role`.\n   *\n   * `sender` is the account that originated the contract call, an admin role\n   * bearer except when using {AccessControl-_setupRole}.\n   */\n  event RoleGranted(\n    bytes32 indexed role,\n    address indexed account,\n    address indexed sender\n  );\n\n  /**\n   * @dev Emitted when `account` is revoked `role`.\n   *\n   * `sender` is the account that originated the contract call:\n   *   - if using `revokeRole`, it is the admin role bearer\n   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n   */\n  event RoleRevoked(\n    bytes32 indexed role,\n    address indexed account,\n    address indexed sender\n  );\n\n  /**\n   * @dev Returns `true` if `account` has been granted `role`.\n   */\n  function hasRole(bytes32 role, address account) external view returns (bool);\n\n  /**\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\n   * {revokeRole}.\n   *\n   * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n   */\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function grantRole(bytes32 role, address account) external;\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function revokeRole(bytes32 role, address account) external;\n\n  /**\n   * @dev Revokes `role` from the calling account.\n   *\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\n   * purpose is to provide a mechanism for accounts to lose their privileges\n   * if they are compromised (such as when a trusted device is misplaced).\n   *\n   * If the calling account had been granted `role`, emits a {RoleRevoked}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must be `account`.\n   */\n  function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/external/openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n  bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n   */\n  function toString(uint256 value) internal pure returns (string memory) {\n    // Inspired by OraclizeAPI's implementation - MIT licence\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n    if (value == 0) {\n      return \"0\";\n    }\n    uint256 temp = value;\n    uint256 digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n   */\n  function toHexString(uint256 value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0x00\";\n    }\n    uint256 temp = value;\n    uint256 length = 0;\n    while (temp != 0) {\n      length++;\n      temp >>= 8;\n    }\n    return toHexString(value, length);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n   */\n  function toHexString(uint256 value, uint256 length)\n    internal\n    pure\n    returns (string memory)\n  {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = \"0\";\n    buffer[1] = \"x\";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = _HEX_SYMBOLS[value & 0xf];\n      value >>= 4;\n    }\n    require(value == 0, \"Strings: hex length insufficient\");\n    return string(buffer);\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts/utils/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts/utils/IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return interfaceId == type(IERC165).interfaceId;\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts/utils/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30 000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/ousg/ousgManager.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\n\npragma solidity 0.8.16;\n\nimport \"contracts/RWAHubNonStableInstantMints.sol\";\nimport \"contracts/kyc/KYCRegistryClient.sol\";\n\ncontract OUSGManager is RWAHubNonStableInstantMints, KYCRegistryClient {\n  constructor(\n    address _collateral,\n    address _rwa,\n    address managerAdmin,\n    address pauser,\n    address _assetSender,\n    address _feeRecipient,\n    uint256 _minimumDepositAmount,\n    uint256 _minimumRedemptionAmount,\n    address _instantMintAssetManager,\n    address _kycRegistry,\n    uint256 _kycRequirementGroup\n  )\n    RWAHubNonStableInstantMints(\n      _collateral,\n      _rwa,\n      managerAdmin,\n      pauser,\n      _assetSender,\n      _feeRecipient,\n      _minimumDepositAmount,\n      _minimumRedemptionAmount,\n      _instantMintAssetManager\n    )\n  {\n    _setKYCRegistry(_kycRegistry);\n    _setKYCRequirementGroup(_kycRequirementGroup);\n  }\n\n  /**\n   * @notice Function to enforce KYC/AML requirements that will\n   *         be implemented on calls to `requestSubscription` and\n   *         `claimRedemption`\n   *\n   * @param account The account that we would like to check the KYC\n   *                status for\n   */\n  function _checkRestrictions(address account) internal view override {\n    // Check Basic KYC requirements for OMMF\n    if (!_getKYCStatus(account)) {\n      revert KYCCheckFailed();\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        KYC Registry Utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Update KYC group of the contract for which\n   *         accounts are checked against\n   *\n   * @param _kycRequirementGroup The new KYC requirement group\n   */\n  function setKYCRequirementGroup(\n    uint256 _kycRequirementGroup\n  ) external onlyRole(MANAGER_ADMIN) {\n    _setKYCRequirementGroup(_kycRequirementGroup);\n  }\n\n  /**\n   * @notice Update KYC registry address\n   *\n   * @param _kycRegistry The new KYC registry address\n   */\n  function setKYCRegistry(\n    address _kycRegistry\n  ) external onlyRole(MANAGER_ADMIN) {\n    _setKYCRegistry(_kycRegistry);\n  }\n\n  error KYCCheckFailed();\n}\n"
    },
    "contracts/kyc/KYCRegistryClient.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/kyc/IKYCRegistry.sol\";\nimport \"contracts/kyc/IKYCRegistryClient.sol\";\n\n/**\n * @title KYCRegistryClient\n * @author Ondo Finance\n * @notice This abstract contract manages state required for clients\n *         of the KYC registry.\n */\nabstract contract KYCRegistryClient is IKYCRegistryClient {\n  // KYC Registry address\n  IKYCRegistry public override kycRegistry;\n  // KYC requirement group\n  uint256 public override kycRequirementGroup;\n\n  /**\n   * @notice Sets the KYC registry address for this client\n   *\n   * @param _kycRegistry The new KYC registry address\n   */\n  function _setKYCRegistry(address _kycRegistry) internal {\n    if (_kycRegistry == address(0)) {\n      revert RegistryZeroAddress();\n    }\n    address oldKYCRegistry = address(kycRegistry);\n    kycRegistry = IKYCRegistry(_kycRegistry);\n    emit KYCRegistrySet(oldKYCRegistry, _kycRegistry);\n  }\n\n  /**\n   * @notice Sets the KYC registry requirement group for this\n   *         client to check kyc status for\n   *\n   * @param _kycRequirementGroup The new KYC group\n   */\n  function _setKYCRequirementGroup(uint256 _kycRequirementGroup) internal {\n    uint256 oldKYCLevel = kycRequirementGroup;\n    kycRequirementGroup = _kycRequirementGroup;\n    emit KYCRequirementGroupSet(oldKYCLevel, _kycRequirementGroup);\n  }\n\n  /**\n   * @notice Checks whether an address has been KYC'd\n   *\n   * @param account The address to check\n   */\n  function _getKYCStatus(address account) internal view returns (bool) {\n    return kycRegistry.getKYCStatus(kycRequirementGroup, account);\n  }\n\n  function _getKYCStateDirect(address account) internal view returns (bool) {\n    return kycRegistry.kycState(kycRequirementGroup, account);\n  }\n}\n"
    },
    "contracts/kyc/IKYCRegistry.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\n/**\n * @title IKYCRegistry\n * @author Ondo Finance\n * @notice The interface for Ondo's KYC Registry contract\n */\ninterface IKYCRegistry {\n  /**\n   * @notice Retrieves KYC status of an account\n   *\n   * @param kycRequirementGroup The KYC group for which we wish to check\n   * @param account             The account we wish to retrieve KYC status for\n   *\n   * @return bool Whether the `account` is KYC'd\n   */\n  function getKYCStatus(\n    uint256 kycRequirementGroup,\n    address account\n  ) external view returns (bool);\n\n  /**\n   * @notice View function for the public nested mapping of kycState\n   *\n   * @param kycRequirementGroup The KYC group to view\n   * @param account             The account to check if KYC'd\n   */\n  function kycState(\n    uint256 kycRequirementGroup,\n    address account\n  ) external view returns (bool);\n}\n"
    },
    "contracts/kyc/IKYCRegistryClient.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/kyc/IKYCRegistry.sol\";\n\n/**\n * @title IKYCRegistryClient\n * @author Ondo Finance\n * @notice The client interface Ondo's KYC Registry contract.\n */\ninterface IKYCRegistryClient {\n  /// @notice Returns what KYC group this client checks accounts for\n  function kycRequirementGroup() external view returns (uint256);\n\n  /// @notice Returns reference to the KYC registry that this client queries\n  function kycRegistry() external view returns (IKYCRegistry);\n\n  /// @notice Sets the KYC group\n  function setKYCRequirementGroup(uint256 group) external;\n\n  /// @notice Sets the KYC registry reference\n  function setKYCRegistry(address registry) external;\n\n  /// @notice Error for when caller attempts to set the KYC registry refernce\n  ///         to the zero address.\n  error RegistryZeroAddress();\n\n  /**\n   * @dev Event for when the KYC registry reference is set\n   *\n   * @param oldRegistry The old registry\n   * @param newRegistry The new registry\n   */\n  event KYCRegistrySet(address oldRegistry, address newRegistry);\n\n  /**\n   * @dev Event for when the KYC group for this client is set\n   *\n   * @param oldRequirementGroup The old KYC group\n   * @param newRequirementGroup The new KYC group\n   */\n  event KYCRequirementGroupSet(\n    uint256 oldRequirementGroup,\n    uint256 newRequirementGroup\n  );\n}\n"
    },
    "contracts/ommf/ommfManager.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\n\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IWommf.sol\";\nimport \"contracts/kyc/KYCRegistryClient.sol\";\nimport \"contracts/RWAHubInstantMints.sol\";\n\ncontract OMMFManager is RWAHubInstantMints, KYCRegistryClient {\n  /// @notice `rwa` variable is OMMF token contract\n  IWOMMF public immutable wommf;\n\n  constructor(\n    address _collateral,\n    address _rwa,\n    address managerAdmin,\n    address pauser,\n    address _assetSender,\n    address _feeRecipient,\n    uint256 _minimumDepositAmount,\n    uint256 _minimumRedemptionAmount,\n    address _instantMintAssetManager,\n    address _kycRegistry,\n    uint256 _kycRequirementGroup,\n    address _wommf\n  )\n    RWAHubInstantMints(\n      _collateral,\n      _rwa,\n      managerAdmin,\n      pauser,\n      _assetSender,\n      _feeRecipient,\n      _minimumDepositAmount,\n      _minimumRedemptionAmount,\n      _instantMintAssetManager\n    )\n  {\n    _setKYCRegistry(_kycRegistry);\n    _setKYCRequirementGroup(_kycRequirementGroup);\n    wommf = IWOMMF(_wommf);\n  }\n\n  /**\n   * @notice Function to claim a subscription request in wrapped rwa\n   *         token\n   *\n   * @param depositIds The depositIds to be claimed\n   */\n  function claimMint_wOMMF(\n    bytes32[] memory depositIds\n  ) external nonReentrant ifNotPaused(subscriptionPaused) {\n    uint256 cacheLength = depositIds.length;\n    for (uint256 i; i < cacheLength; ++i) {\n      // Get depositor\n      Depositor memory depositor = depositIdToDepositor[depositIds[i]];\n\n      // Check if the depositor is valid\n      if (depositor.priceId == 0) {\n        revert PriceIdNotSet();\n      }\n\n      // Get price and rwaOwed based on priceId\n      uint256 price = pricer.getPrice(depositor.priceId);\n      uint256 rwaOwed = _getMintAmountForPrice(\n        depositor.amountDepositedMinusFees,\n        price\n      );\n\n      // Clean up storage and mint\n      delete depositIdToDepositor[depositIds[i]];\n      rwa.mint(address(this), rwaOwed);\n\n      // Wrap and transfer wOMMF\n      rwa.approve(address(wommf), rwaOwed);\n      wommf.wrap(rwaOwed);\n      uint256 wRwaOwed = wommf.getwOMMFByOMMF(rwaOwed);\n      wommf.transfer(depositor.user, wRwaOwed);\n\n      emit WrappedMintCompleted(\n        depositor.user,\n        depositIds[i],\n        rwaOwed,\n        wRwaOwed,\n        depositor.amountDepositedMinusFees,\n        price\n      );\n    }\n  }\n\n  /**\n   * @notice Function to request a redemption in instances when the user would\n   *         like to burn the wrapped rwa token\n   *\n   * @param amount The amount of wrapped rwa that the user would like to burn\n   */\n  function requestRedemption_wOMMF(\n    uint256 amount\n  ) external nonReentrant ifNotPaused(redemptionPaused) {\n    uint256 ommfAmount = wommf.getOMMFbywOMMF(amount);\n    if (ommfAmount < minimumRedemptionAmount) {\n      revert RedemptionTooSmall();\n    }\n\n    // Transfer and unwrap\n    wommf.transferFrom(msg.sender, address(this), amount);\n    wommf.unwrap(amount);\n\n    bytes32 redemptionId = bytes32(redemptionRequestCounter++);\n    redemptionIdToRedeemer[redemptionId] = Redeemer(msg.sender, amount, 0);\n\n    rwa.burn(ommfAmount);\n\n    emit WrappedRedemptionRequested(\n      msg.sender,\n      redemptionId,\n      ommfAmount,\n      amount\n    );\n  }\n\n  /**\n   * @notice Function to enforce KYC/AML requirements that will\n   *         be implemented on calls to `requestSubscription` and\n   *         `claimRedemption`\n   *\n   * @param account The account that we would like to check the KYC\n   *                status for\n   */\n  function _checkRestrictions(address account) internal view override {\n    // Check Basic KYC requirements for OMMF\n    if (!_getKYCStatus(account)) {\n      revert KYCCheckFailed();\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        KYC Registry Utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Update KYC group of the contract for which\n   *         accounts are checked against\n   *\n   * @param _kycRequirementGroup The new KYC requirement group\n   */\n  function setKYCRequirementGroup(\n    uint256 _kycRequirementGroup\n  ) external onlyRole(MANAGER_ADMIN) {\n    _setKYCRequirementGroup(_kycRequirementGroup);\n  }\n\n  /**\n   * @notice Update KYC registry address\n   *\n   * @param _kycRegistry The new KYC registry address\n   */\n  function setKYCRegistry(\n    address _kycRegistry\n  ) external onlyRole(MANAGER_ADMIN) {\n    _setKYCRegistry(_kycRegistry);\n  }\n\n  /**\n   * @notice Event emitted when a Mint request is completed\n   *\n   * @param user                      The address of the user getting the funds\n   * @param depositId                 The deposit Id for the subscription request\n   * @param rwaAmountOut              The amount of RWA token minted to the\n   *                                  user\n   * @param wRWAAmountOut             The amount of wrapped RWA token minted\n   * @param collateralAmountDeposited The amount of collateral deposited\n   * @param price                     The price set for the depositId\n   */\n  event WrappedMintCompleted(\n    address indexed user,\n    bytes32 indexed depositId,\n    uint256 rwaAmountOut,\n    uint256 wRWAAmountOut,\n    uint256 collateralAmountDeposited,\n    uint256 price\n  );\n\n  /**\n   * @notice Event emitted when a Redemption request is completed\n   *\n   * @param user               The address of the user\n   * @param redemptionId       The redemption Id for a given redemption\n   *                           request\n   * @param rwaAmountIn        The amount of rwa being redeemed\n   * @param wrappedRwaAmountIn The amount of wrapped rwa to convert to rwa\n   */\n  event WrappedRedemptionRequested(\n    address indexed user,\n    bytes32 indexed redemptionId,\n    uint256 rwaAmountIn,\n    uint256 wrappedRwaAmountIn\n  );\n\n  error KYCCheckFailed();\n}\n"
    },
    "contracts/interfaces/IWommf.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\n\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\n\npragma solidity 0.8.16; // latest available for using OZ\n\ninterface IWOMMF is IERC20 {\n  function getPooledCashByShares(uint256) external view returns (uint256);\n\n  function getSharesByPooledCash(uint256) external view returns (uint256);\n\n  function initialize(\n    address,\n    string memory,\n    string memory,\n    address,\n    address,\n    uint256\n  ) external;\n\n  function wrap(uint256) external;\n\n  function unwrap(uint256) external;\n\n  function getwOMMFByOMMF(uint256) external view returns (uint256);\n\n  function getOMMFbywOMMF(uint256) external view returns (uint256);\n}\n"
    },
    "contracts/RWAHubInstantMints.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\n\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IRWAHubInstantMints.sol\";\nimport \"contracts/RWAHub.sol\";\nimport \"contracts/InstantMintTimeBasedRateLimiter.sol\";\n\nabstract contract RWAHubInstantMints is\n  IRWAHubInstantMints,\n  RWAHub,\n  InstantMintTimeBasedRateLimiter\n{\n  using SafeERC20 for IERC20;\n\n  // Fee collected when instant minting OMMF (in basis points)\n  uint256 public instantMintFee = 10;\n\n  // Fee collected when instant redeeming OMMF (in basis points)\n  uint256 public instantRedemptionFee = 10;\n\n  // priceId associated with instantMints\n  uint256 public instantMintPriceId;\n\n  // priceId associated with instantRedemptions\n  uint256 public instantRedemptionPriceId;\n\n  // Flag whether instantMint is paused\n  bool public instantMintPaused = true;\n\n  // Flag whether instantRedemption is paused\n  bool public instantRedemptionPaused = true;\n\n  // Address to manage instant mints/redemptions\n  address public instantMintAssetManager;\n\n  constructor(\n    address _collateral,\n    address _rwa,\n    address managerAdmin,\n    address pauser,\n    address _assetSender,\n    address _feeRecipient,\n    uint256 _minimumDepositAmount,\n    uint256 _minimumRedemptionAmount,\n    address _instantMintAssetManager\n  )\n    RWAHub(\n      _collateral,\n      _rwa,\n      managerAdmin,\n      pauser,\n      _assetSender,\n      _feeRecipient,\n      _minimumDepositAmount,\n      _minimumRedemptionAmount\n    )\n    InstantMintTimeBasedRateLimiter(0, 0, 0, 0)\n  {\n    instantMintAssetManager = _instantMintAssetManager;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                  Instant Mint/Redemption Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Instant mints `rwa` token to the caller in exchange for\n   *         `collateral`\n   *\n   * @param amount The amount of `collateral` to deposit\n   *\n   * @dev All fees are deducted from amount transferred by\n   *      `instantMintAssetManager`\n   */\n  function instantMint(\n    uint256 amount\n  ) external nonReentrant ifNotPaused(instantMintPaused) {\n    if (amount < minimumDepositAmount) {\n      revert DepositTooSmall();\n    }\n\n    if (instantMintPriceId == 0) {\n      revert PriceIdNotSet();\n    }\n\n    // Calculate fees\n    uint256 feesInCollateral = _getInstantMintFees(amount);\n    uint256 depositAmountAfterFee = amount - feesInCollateral;\n\n    // Transfer collateral\n    collateral.safeTransferFrom(msg.sender, instantMintAssetManager, amount);\n\n    // Calculate mint amount\n    uint256 price = pricer.getPrice(instantMintPriceId);\n    uint256 rwaOwed = _getMintAmountForPrice(depositAmountAfterFee, price);\n\n    // Check mint limit\n    _checkAndUpdateInstantMintLimit(rwaOwed);\n\n    // Mint RWA\n    rwa.mint(msg.sender, rwaOwed);\n\n    emit InstantMintCompleted(\n      msg.sender,\n      amount,\n      depositAmountAfterFee,\n      feesInCollateral,\n      rwaOwed,\n      price\n    );\n  }\n\n  /**\n   * @notice Instant mints `rwa` token to the caller in exchange for\n   *         `collateral`\n   *\n   * @param amount The amount of `collateral` to deposit\n   *\n   * @dev All fees are deducted from collateral transferred by\n   *      `instantMintAssetManager`\n   */\n  function instantRedemption(\n    uint256 amount\n  ) external nonReentrant ifNotPaused(instantRedemptionPaused) {\n    // Checks\n    if (amount < minimumRedemptionAmount) {\n      revert RedemptionTooSmall();\n    }\n\n    if (instantRedemptionPriceId == 0) {\n      revert PriceIdNotSet();\n    }\n\n    // Update instant redemption limit\n    _checkAndUpdateInstantRedemptionLimit(amount);\n\n    // Calculate collateralDue and fees\n    uint256 price = pricer.getPrice(instantRedemptionPriceId);\n    uint256 collateralDue = _getRedemptionAmountForRwa(amount, price);\n    uint256 feesInCollateral = _getinstantRedemptionFees(collateralDue);\n    uint256 collateralDuePostFees = collateralDue - feesInCollateral;\n\n    // Burn rwa and transfer collateral\n    rwa.burnFrom(msg.sender, amount);\n\n    collateral.safeTransferFrom(\n      instantMintAssetManager,\n      msg.sender,\n      collateralDuePostFees\n    );\n\n    emit InstantRedemptionCompleted(\n      msg.sender,\n      amount,\n      collateralDuePostFees,\n      feesInCollateral,\n      price\n    );\n  }\n\n  /**\n   * @notice Guarded function to set the `instantMintAssetManager`\n   *\n   * @param _instantMintAssetManager The address to update\n   *                                 `instantMintAssetManager` to\n   */\n  function setInstantMintAssetManager(\n    address _instantMintAssetManager\n  ) external onlyRole(MANAGER_ADMIN) {\n    address oldInstantMintAssetManager = instantMintAssetManager;\n    instantMintAssetManager = _instantMintAssetManager;\n    emit InstantMintAssetManagerSet(\n      oldInstantMintAssetManager,\n      _instantMintAssetManager\n    );\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    Instant Mint/Redeem Fee Utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Sets the instant mint fee\n   *\n   * @param _instantMintFee new mint fee specified in basis points\n   *\n   * @dev `_instantMintFee` must not exceed 100% (or 10_000 bps)\n   */\n  function setInstantMintFee(\n    uint256 _instantMintFee\n  ) external onlyRole(MANAGER_ADMIN) {\n    if (_instantMintFee > BPS_DENOMINATOR) {\n      revert FeeTooLarge();\n    }\n    uint256 oldInstantMintFee = instantMintFee;\n    instantMintFee = _instantMintFee;\n    emit InstantMintFeeSet(oldInstantMintFee, _instantMintFee);\n  }\n\n  /**\n   * @notice Sets instant redemption fee.\n   *\n   * @param _instantRedemptionFee new redemption fee specified in basis points\n   *\n   * @dev `_instantRedemptionFee` must not exceed 100% (or 10_000 bps)\n   */\n  function setInstantRedemptionFee(\n    uint256 _instantRedemptionFee\n  ) external onlyRole(MANAGER_ADMIN) {\n    if (_instantRedemptionFee > BPS_DENOMINATOR) {\n      revert FeeTooLarge();\n    }\n    uint256 oldinstantRedemptionFee = instantRedemptionFee;\n    instantRedemptionFee = _instantRedemptionFee;\n    emit InstantRedemptionFeeSet(\n      oldinstantRedemptionFee,\n      _instantRedemptionFee\n    );\n  }\n\n  /**\n   * @notice Given amount of `collateral`, returns how much in fees\n   *         are owed\n   *\n   * @param collateralAmount Amount of `collateral` to calculate fees\n   *                         (in decimals of `collateral`)\n   */\n  function _getInstantMintFees(\n    uint256 collateralAmount\n  ) internal view returns (uint256) {\n    return (collateralAmount * instantMintFee) / BPS_DENOMINATOR;\n  }\n\n  /**\n   * @notice Given amount of `collateral`, returns how much in fees\n   *         are owed\n   *\n   * @param collateralAmount Amount `collateral` to calculate fees\n   *                         (in decimals of `collateral`)\n   */\n  function _getinstantRedemptionFees(\n    uint256 collateralAmount\n  ) internal view returns (uint256) {\n    return (collateralAmount * instantRedemptionFee) / BPS_DENOMINATOR;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    Instant Mint/Redeem Setters\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Function to set priceId for instant mints\n   */\n  function setInstantMintPriceId(\n    uint256 _instantMintPriceId\n  ) external onlyRole(PRICE_ID_SETTER_ROLE) {\n    instantMintPriceId = _instantMintPriceId;\n    emit PriceIdSetForInstantMint(_instantMintPriceId);\n  }\n\n  /**\n   * @notice Function to set priceId for instant redemptions\n   */\n  function setInstantRedemptionPriceId(\n    uint256 _instantRedemptionPriceId\n  ) external onlyRole(PRICE_ID_SETTER_ROLE) {\n    instantRedemptionPriceId = _instantRedemptionPriceId;\n    emit PriceIdSetForInstantRedemption(_instantRedemptionPriceId);\n  }\n\n  /**\n   * @notice Function to pause instant mints\n   */\n  function pauseInstantMint() external onlyRole(PAUSER_ADMIN) {\n    instantMintPaused = true;\n    emit InstantMintPaused(msg.sender);\n  }\n\n  /**\n   * @notice Function to unpause instant mints\n   */\n  function unpauseInstantMint() external onlyRole(MANAGER_ADMIN) {\n    instantMintPaused = false;\n    emit InstantMintUnpaused(msg.sender);\n  }\n\n  /**\n   * @notice Function to pause instant redemptions\n   */\n  function pauseInstantRedemption() external onlyRole(PAUSER_ADMIN) {\n    instantRedemptionPaused = true;\n    emit InstantRedemptionPaused(msg.sender);\n  }\n\n  /**\n   * @notice Function to unpause instant redemptions\n   */\n  function unpauseInstantRedemption() external onlyRole(MANAGER_ADMIN) {\n    instantRedemptionPaused = false;\n    emit InstantRedemptionUnpaused(msg.sender);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                     Rate Limiter Configuration\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Set the mintLimit constraint inside the TimeBasedRateLimiter\n   *         base contract\n   *\n   * @param newMintLimit New limit that dictates how much RWA can be minted\n   *                     in a specified duration\n   *                     (in 18 decimals per the RWA contract)\n   */\n  function setInstantMintLimit(\n    uint256 newMintLimit\n  ) external onlyRole(MANAGER_ADMIN) {\n    _setInstantMintLimit(newMintLimit);\n  }\n\n  /**\n   * @notice Set the RedemptionLimit constraint inside the TimeBasedRateLimiter\n   *         base contract\n   *\n   * @param newRedemptionLimit New limit that dicates how much RWA\n   *                       can be redeemed in a specified duration\n   *                       (in 18 decimals per the RWA contract)\n   */\n  function setInstantRedemptionLimit(\n    uint256 newRedemptionLimit\n  ) external onlyRole(MANAGER_ADMIN) {\n    _setInstantRedemptionLimit(newRedemptionLimit);\n  }\n\n  /**\n   * @notice Sets mintLimitDuration constraint inside the TimeBasedRateLimiter\n   *         base contract\n   *\n   * @param newMintLimitDuration New limit that specifies the interval\n   *                             (in seconds) in which only mintLimit RWA\n   *                             can be minted within\n   */\n  function setInstantMintLimitDuration(\n    uint256 newMintLimitDuration\n  ) external onlyRole(MANAGER_ADMIN) {\n    _setInstantMintLimitDuration(newMintLimitDuration);\n  }\n\n  /**\n   * @notice Sets RedemptionLimitDuration inside the TimeBasedRateLimiter\n   *         base contract\n   *\n   * @param newRedemptionLimitDuration New limit that specifies the interval\n   *                               (in seconds) in which only RedemptionLimit RWA\n   *                               can be redeemed within\n   */\n  function setInstantRedemptionLimitDuration(\n    uint256 newRedemptionLimitDuration\n  ) external onlyRole(MANAGER_ADMIN) {\n    _setInstantRedemptionLimitDuration(newRedemptionLimitDuration);\n  }\n}\n"
    },
    "contracts/interfaces/IRWAHubInstantMints.sol": {
      "content": "pragma solidity 0.8.16;\n\ninterface IRWAHubInstantMints {\n  function instantMint(uint256 amount) external;\n\n  function instantRedemption(uint256 amount) external;\n\n  function setInstantMintFee(uint256 _instantMintFee) external;\n\n  function setInstantRedemptionFee(uint256 _instantRedemptionFee) external;\n\n  function setInstantMintPriceId(uint256 _instantMintPriceId) external;\n\n  function setInstantRedemptionPriceId(\n    uint256 _InstantRedemptionPriceId\n  ) external;\n\n  function pauseInstantMint() external;\n\n  function unpauseInstantMint() external;\n\n  function pauseInstantRedemption() external;\n\n  function unpauseInstantRedemption() external;\n\n  function setInstantMintLimit(uint256 newMintLimit) external;\n\n  function setInstantRedemptionLimit(uint256 newRedemptionLimit) external;\n\n  function setInstantMintLimitDuration(uint256 newMintLimitDuration) external;\n\n  function setInstantRedemptionLimitDuration(\n    uint256 newRedemptionLimitDuration\n  ) external;\n\n  /**\n   * @notice Event emitted when instant mint fee is set\n   *\n   * @param oldFee Old fee\n   * @param newFee New fee\n   *\n   * @dev See inheriting contract for decimals representation\n   */\n  event InstantMintFeeSet(uint256 oldFee, uint256 newFee);\n\n  /**\n   * @notice Event emitted when instant redeem fee is set\n   *\n   * @param oldFee Old fee\n   * @param newFee New fee\n   *\n   * @dev See inheriting contract for decimals representation\n   */\n  event InstantRedemptionFeeSet(uint256 oldFee, uint256 newFee);\n\n  /**\n   * @notice Event emitted when an instant mint is completed\n   *\n   * @param user                      The address of the user\n   * @param collateralAmountDeposited The amount of collateral deposited\n   * @param collateralAmountAfterFees The amount of collateral after fees\n   * @param feesInCollateral          The amount of fees in collateral\n   * @param rwaOwed                   The amount of rwa minted to the user\n   * @param price                     The price at which the rwa was minted at\n   */\n  event InstantMintCompleted(\n    address indexed user,\n    uint256 collateralAmountDeposited,\n    uint256 collateralAmountAfterFees,\n    uint256 feesInCollateral,\n    uint256 rwaOwed,\n    uint256 price\n  );\n\n  /**\n   * @notice Event emitted when an instant redeem is completed\n   *\n   * @param user                      The address of the user\n   * @param rwaAmountBurned           The amount of RWA burned by the user\n   * @param collateralAmountAfterFees The amount of collateral after fees returned\n   * @param feesInCollateral          The amount of fees in collateral\n   * @param price                     The price at which the rwa was redeemed at\n   */\n  event InstantRedemptionCompleted(\n    address indexed user,\n    uint256 rwaAmountBurned,\n    uint256 collateralAmountAfterFees,\n    uint256 feesInCollateral,\n    uint256 price\n  );\n\n  /**\n   * @notice Event emitted when instant mints are paused\n   *\n   * @param caller Address which initiated the pause\n   */\n  event InstantMintPaused(address caller);\n\n  /**\n   * @notice Event emitted when instant mints are unpaused\n   *\n   * @param caller Address which initiated the unpause\n   */\n  event InstantMintUnpaused(address caller);\n\n  /**\n   * @notice Event emitted when instant redeems are paused\n   *\n   * @param caller Address which initiated the pause\n   */\n  event InstantRedemptionPaused(address caller);\n\n  /**\n   * @notice Event emitted when instant redeems are unpaused\n   *\n   * @param caller Address which initiated the unpause\n   */\n  event InstantRedemptionUnpaused(address caller);\n\n  /**\n   * @notice Event emitted when instant mint priceId is set\n   *\n   * @param priceId Price Id\n   */\n  event PriceIdSetForInstantMint(uint256 priceId);\n\n  /**\n   * @notice Event emitted when instant redeem priceId is set\n   *\n   * @param priceId Price Id\n   */\n  event PriceIdSetForInstantRedemption(uint256 priceId);\n\n  /**\n   * @notice Event emitted when instant mint asset manager is set\n   *\n   * @param oldInstantMintAssetManager Old instant mint asset manager\n   * @param newInstantMintAssetManager New instant mint asset manager\n   */\n  event InstantMintAssetManagerSet(\n    address oldInstantMintAssetManager,\n    address newInstantMintAssetManager\n  );\n}\n"
    },
    "contracts/RWAHubOffChainRedemptions.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\n\npragma solidity 0.8.16;\n\nimport \"contracts/RWAHub.sol\";\nimport \"contracts/interfaces/IRWAHubOffChainRedemptions.sol\";\n\nabstract contract RWAHubOffChainRedemptions is\n  RWAHub,\n  IRWAHubOffChainRedemptions\n{\n  // To enable and disable off chain redemptions\n  bool public offChainRedemptionPaused;\n\n  // Minimum off chain redemption amount\n  uint256 public minimumOffChainRedemptionAmount;\n\n  constructor(\n    address _collateral,\n    address _rwa,\n    address managerAdmin,\n    address pauser,\n    address _assetSender,\n    address _feeRecipient,\n    uint256 _minimumDepositAmount,\n    uint256 _minimumRedemptionAmount\n  )\n    RWAHub(\n      _collateral,\n      _rwa,\n      managerAdmin,\n      pauser,\n      _assetSender,\n      _feeRecipient,\n      _minimumDepositAmount,\n      _minimumRedemptionAmount\n    )\n  {\n    // Default to the same minimum redemption amount as for On-Chain\n    // redemptions.\n    minimumOffChainRedemptionAmount = _minimumRedemptionAmount;\n  }\n\n  /**\n   * @notice Request a redemption to be serviced off chain.\n   *\n   * @param amountRWATokenToRedeem The requested redemption amount\n   * @param offChainDestination    A hash of the destination to which\n   *                               the request should be serviced to.\n   */\n  function requestRedemptionServicedOffchain(\n    uint256 amountRWATokenToRedeem,\n    bytes32 offChainDestination\n  ) external nonReentrant ifNotPaused(offChainRedemptionPaused) {\n    if (amountRWATokenToRedeem < minimumRedemptionAmount) {\n      revert RedemptionTooSmall();\n    }\n\n    bytes32 redemptionId = bytes32(redemptionRequestCounter++);\n\n    rwa.burnFrom(msg.sender, amountRWATokenToRedeem);\n\n    emit RedemptionRequestedServicedOffChain(\n      redemptionId,\n      msg.sender,\n      amountRWATokenToRedeem,\n      offChainDestination\n    );\n  }\n\n  /**\n   * @notice Function to pause off chain redemptoins\n   */\n  function pauseOffChainRedemption() external onlyRole(PAUSER_ADMIN) {\n    offChainRedemptionPaused = true;\n    emit OffChainRedemptionPaused(msg.sender);\n  }\n\n  /**\n   * @notice Function to unpause off chain redemptoins\n   */\n  function unpauseOffChainRedemption() external onlyRole(MANAGER_ADMIN) {\n    offChainRedemptionPaused = false;\n    emit OffChainRedemptionUnpaused(msg.sender);\n  }\n\n  /**\n   * @notice Admin Function to set the minimum off chain redemption amount\n   *\n   * @param _minimumOffChainRedemptionAmount The new minimum off chain\n   *                                         redemption amount\n   */\n  function setOffChainRedemptionMinimum(\n    uint256 _minimumOffChainRedemptionAmount\n  ) external onlyRole(MANAGER_ADMIN) {\n    uint256 oldMinimum = minimumOffChainRedemptionAmount;\n    minimumOffChainRedemptionAmount = _minimumOffChainRedemptionAmount;\n    emit OffChainRedemptionMinimumSet(\n      oldMinimum,\n      _minimumOffChainRedemptionAmount\n    );\n  }\n}\n"
    },
    "contracts/interfaces/IRWAHubOffChainRedemptions.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n */\npragma solidity 0.8.16;\n\ninterface IRWAHubOffChainRedemptions {\n  function requestRedemptionServicedOffchain(\n    uint256 amountRWATokenToRedeem,\n    bytes32 offChainDestination\n  ) external;\n\n  function pauseOffChainRedemption() external;\n\n  function unpauseOffChainRedemption() external;\n\n  function setOffChainRedemptionMinimum(uint256 minimumAmount) external;\n\n  /**\n   * @notice Event emitted when redemption request is submitted\n   *\n   * @param redemptionId        The user submitting the redemption request\n   * @param user                The user submitting the redemption request\n   * @param rwaTokenAmountIn    The amount of cash being burned\n   * @param offChainDestination Hash of destination to which the request\n   *                            should be serviced to\n   */\n  event RedemptionRequestedServicedOffChain(\n    bytes32 indexed redemptionId,\n    address indexed user,\n    uint256 rwaTokenAmountIn,\n    bytes32 offChainDestination\n  );\n\n  /**\n   * @notice Event emitted when the off chain redemption feature is\n   *         paused\n   *\n   * @param caller Address which initiated the pause\n   */\n  event OffChainRedemptionPaused(address caller);\n\n  /**\n   * @notice Event emitted when the off chain redemption feature is\n   *         unpaused\n   *\n   * @param caller Address which initiated the unpause\n   */\n  event OffChainRedemptionUnpaused(address caller);\n\n  /**\n   * @notice Event emitted when the off chain redemption minimum is\n   *         updated\n   *\n   * @param oldMinimum the old minimum redemption amount\n   * @param newMinimum the new minimum redemption amount\n   */\n  event OffChainRedemptionMinimumSet(uint256 oldMinimum, uint256 newMinimum);\n}\n"
    },
    "contracts/usdy/USDYManager.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\n\npragma solidity 0.8.16;\n\nimport \"contracts/RWAHubOffChainRedemptions.sol\";\nimport \"contracts/usdy/blocklist/BlocklistClient.sol\";\nimport \"contracts/sanctions/SanctionsListClient.sol\";\nimport \"contracts/interfaces/IUSDYManager.sol\";\n\ncontract USDYManager is\n  RWAHubOffChainRedemptions,\n  BlocklistClient,\n  SanctionsListClient,\n  IUSDYManager\n{\n  bytes32 public constant TIMESTAMP_SETTER_ROLE =\n    keccak256(\"TIMESTAMP_SETTER_ROLE\");\n\n  mapping(bytes32 => uint256) public depositIdToClaimableTimestamp;\n\n  constructor(\n    address _collateral,\n    address _rwa,\n    address managerAdmin,\n    address pauser,\n    address _assetSender,\n    address _feeRecipient,\n    uint256 _minimumDepositAmount,\n    uint256 _minimumRedemptionAmount,\n    address blocklist,\n    address sanctionsList\n  )\n    RWAHubOffChainRedemptions(\n      _collateral,\n      _rwa,\n      managerAdmin,\n      pauser,\n      _assetSender,\n      _feeRecipient,\n      _minimumDepositAmount,\n      _minimumRedemptionAmount\n    )\n    BlocklistClient(blocklist)\n    SanctionsListClient(sanctionsList)\n  {}\n\n  /**\n   * @notice Function to enforce blocklist and sanctionslist restrictions to be\n   *         implemented on calls to `requestSubscription` and\n   *         `claimRedemption`\n   *\n   * @param account The account to check blocklist and sanctions list status\n   *                for\n   */\n  function _checkRestrictions(address account) internal view override {\n    if (_isBlocked(account)) {\n      revert BlockedAccount();\n    }\n    if (_isSanctioned(account)) {\n      revert SanctionedAccount();\n    }\n  }\n\n  /**\n   * @notice Internal hook that is called by `claimMint` to enforce the time\n   *         at which a user can claim their USDY\n   *\n   * @param depositId The depositId to check the claimable timestamp for\n   *\n   * @dev This function will call the `_claimMint` function in the parent\n   *      once USDY-specific checks have been made\n   */\n  function _claimMint(bytes32 depositId) internal virtual override {\n    if (depositIdToClaimableTimestamp[depositId] == 0) {\n      revert ClaimableTimestampNotSet();\n    }\n\n    if (depositIdToClaimableTimestamp[depositId] > block.timestamp) {\n      revert MintNotYetClaimable();\n    }\n\n    super._claimMint(depositId);\n    delete depositIdToClaimableTimestamp[depositId];\n  }\n\n  /**\n   * @notice Update blocklist address\n   *\n   * @param blocklist The new blocklist address\n   */\n  function setBlocklist(\n    address blocklist\n  ) external override onlyRole(MANAGER_ADMIN) {\n    _setBlocklist(blocklist);\n  }\n\n  /**\n   * @notice Update sanctions list address\n   *\n   * @param sanctionsList The new sanctions list address\n   */\n  function setSanctionsList(\n    address sanctionsList\n  ) external override onlyRole(MANAGER_ADMIN) {\n    _setSanctionsList(sanctionsList);\n  }\n\n  /**\n   * @notice Set the claimable timestamp for a list of depositIds\n   *\n   * @param claimTimestamp The timestamp at which the deposit can be claimed\n   * @param depositIds The depositIds to set the claimable timestamp for\n   */\n  function setClaimableTimestamp(\n    uint256 claimTimestamp,\n    bytes32[] calldata depositIds\n  ) external onlyRole(TIMESTAMP_SETTER_ROLE) {\n    if (claimTimestamp < block.timestamp) {\n      revert ClaimableTimestampInPast();\n    }\n\n    uint256 depositsSize = depositIds.length;\n    for (uint256 i; i < depositsSize; ++i) {\n      depositIdToClaimableTimestamp[depositIds[i]] = claimTimestamp;\n      emit ClaimableTimestampSet(claimTimestamp, depositIds[i]);\n    }\n  }\n}\n"
    },
    "contracts/usdy/blocklist/BlocklistClient.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IBlocklist.sol\";\nimport \"contracts/interfaces/IBlocklistClient.sol\";\n\n/**\n * @title BlocklistClient\n * @author Ondo Finance\n * @notice This abstract contract manages state for blocklist clients\n */\nabstract contract BlocklistClient is IBlocklistClient {\n  // blocklist address\n  IBlocklist public override blocklist;\n\n  /**\n   * @notice Constructor\n   *\n   * @param _blocklist Address of the blocklist contract\n   */\n  constructor(address _blocklist) {\n    _setBlocklist(_blocklist);\n  }\n\n  /**\n   * @notice Sets the blocklist address for this client\n   *\n   * @param _blocklist The new blocklist address\n   */\n  function _setBlocklist(address _blocklist) internal {\n    if (_blocklist == address(0)) {\n      revert BlocklistZeroAddress();\n    }\n    address oldBlocklist = address(blocklist);\n    blocklist = IBlocklist(_blocklist);\n    emit BlocklistSet(oldBlocklist, _blocklist);\n  }\n\n  /**\n   * @notice Checks whether an address has been blocked\n   *\n   * @param account The account to check\n   */\n  function _isBlocked(address account) internal view returns (bool) {\n    return blocklist.isBlocked(account);\n  }\n}\n"
    },
    "contracts/sanctions/SanctionsListClient.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/external/chainalysis/ISanctionsList.sol\";\nimport \"contracts/sanctions/ISanctionsListClient.sol\";\n\n/**\n * @title SanctionsListClient\n * @author Ondo Finance\n * @notice This abstract contract manages state required for clients\n *         of the sanctions list\n */\nabstract contract SanctionsListClient is ISanctionsListClient {\n  // Sanctions list address\n  ISanctionsList public override sanctionsList;\n\n  /**\n   * @notice Constructor\n   *\n   * @param _sanctionsList Address of the sanctions list contract\n   */\n  constructor(address _sanctionsList) {\n    _setSanctionsList(_sanctionsList);\n  }\n\n  /**\n   * @notice Sets the sanctions list address for this client\n   *\n   * @param _sanctionsList The new sanctions list address\n   */\n  function _setSanctionsList(address _sanctionsList) internal {\n    if (_sanctionsList == address(0)) {\n      revert SanctionsListZeroAddress();\n    }\n    address oldSanctionsList = address(sanctionsList);\n    sanctionsList = ISanctionsList(_sanctionsList);\n    emit SanctionsListSet(oldSanctionsList, _sanctionsList);\n  }\n\n  /**\n   * @notice Checks whether an address has been sanctioned\n   *\n   * @param account The account to check\n   */\n  function _isSanctioned(address account) internal view returns (bool) {\n    return sanctionsList.isSanctioned(account);\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/interfaces/IUSDYManager.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n */\npragma solidity 0.8.16;\n\ninterface IUSDYManager {\n  function setClaimableTimestamp(\n    uint256 claimDate,\n    bytes32[] calldata depositIds\n  ) external;\n\n  /**\n   * @notice Event emitted when claimable timestamp is set\n   *\n   * @param claimTimestamp The timestamp at which the mint can be claimed\n   * @param depositId      The depositId that can claim at the given \n                           `claimTimestamp`\n   */\n  event ClaimableTimestampSet(\n    uint256 indexed claimTimestamp,\n    bytes32 indexed depositId\n  );\n\n  /// ERRORS ///\n  error MintNotYetClaimable();\n  error ClaimableTimestampInPast();\n  error ClaimableTimestampNotSet();\n}\n"
    },
    "contracts/interfaces/IBlocklist.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\ninterface IBlocklist {\n  function addToBlocklist(address[] calldata accounts) external;\n\n  function removeFromBlocklist(address[] calldata accounts) external;\n\n  function isBlocked(address account) external view returns (bool);\n\n  /**\n   * @notice Event emitted when addresses are added to the blocklist\n   *\n   * @param accounts The addresses that were added to the blocklist\n   */\n  event BlockedAddressesAdded(address[] accounts);\n\n  /**\n   * @notice Event emitted when addresses are removed from the blocklist\n   *\n   * @param accounts The addresses that were removed from the blocklist\n   */\n  event BlockedAddressesRemoved(address[] accounts);\n}\n"
    },
    "contracts/interfaces/IBlocklistClient.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IBlocklist.sol\";\n\n/**\n * @title IBlocklistClient\n * @author Ondo Finance\n * @notice The client interface for the Blocklist contract.\n */\ninterface IBlocklistClient {\n  /// @notice Returns reference to the blocklist that this client queries\n  function blocklist() external view returns (IBlocklist);\n\n  /// @notice Sets the blocklist reference\n  function setBlocklist(address registry) external;\n\n  /// @notice Error for when caller attempts to set the blocklist reference\n  ///         to the zero address\n  error BlocklistZeroAddress();\n\n  /// @notice Error for when caller attempts to perform action on a blocked\n  ///         account\n  error BlockedAccount();\n\n  /**\n   * @dev Event for when the blocklist reference is set\n   *\n   * @param oldBlocklist The old blocklist\n   * @param newBlocklist The new blocklist\n   */\n  event BlocklistSet(address oldBlocklist, address newBlocklist);\n}\n"
    },
    "contracts/external/chainalysis/ISanctionsList.sol": {
      "content": "/// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.16;\n\ninterface ISanctionsList {\n  function isSanctioned(address addr) external view returns (bool);\n}\n"
    },
    "contracts/sanctions/ISanctionsListClient.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/external/chainalysis/ISanctionsList.sol\";\n\n/**\n * @title ISanctionsListClient\n * @author Ondo Finance\n * @notice The client interface for sanctions contract.\n */\ninterface ISanctionsListClient {\n  /// @notice Returns reference to the sanctions list that this client queries\n  function sanctionsList() external view returns (ISanctionsList);\n\n  /// @notice Sets the sanctions list reference\n  function setSanctionsList(address sanctionsList) external;\n\n  /// @notice Error for when caller attempts to set the `sanctionsList`\n  ///         reference to the zero address\n  error SanctionsListZeroAddress();\n\n  /// @notice Error for when caller attempts to perform an action on a\n  ///         sanctioned account\n  error SanctionedAccount();\n\n  /**\n   * @dev Event for when the sanctions list reference is set\n   *\n   * @param oldSanctionsList The old list\n   * @param newSanctionsList The new list\n   */\n  event SanctionsListSet(address oldSanctionsList, address newSanctionsList);\n}\n"
    },
    "contracts/sanctions/SanctionsListClientUpgradeable.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"contracts/external/chainalysis/ISanctionsList.sol\";\nimport \"contracts/sanctions/ISanctionsListClient.sol\";\n\n/**\n * @title SanctionsListClient\n * @author Ondo Finance\n * @notice This abstract contract enables inheritors to query whether accounts\n *         are sanctioned or not\n */\nabstract contract SanctionsListClientUpgradeable is\n  Initializable,\n  ISanctionsListClient\n{\n  // Sanctions list address\n  ISanctionsList public override sanctionsList;\n\n  /**\n   * @notice Initialize the contract by setting blocklist variable\n   *\n   * @param _sanctionsList Address of the sanctionsList contract\n   *\n   * @dev Function should be called by the inheriting contract on\n   *      initialization\n   */\n  function __SanctionsListClientInitializable_init(\n    address _sanctionsList\n  ) internal onlyInitializing {\n    __SanctionsListClientInitializable_init_unchained(_sanctionsList);\n  }\n\n  /**\n   * @dev Internal function to future-proof parent linearization. Matches OZ\n   *      upgradeable suggestions\n   */\n  function __SanctionsListClientInitializable_init_unchained(\n    address _sanctionsList\n  ) internal onlyInitializing {\n    _setSanctionsList(_sanctionsList);\n  }\n\n  /**\n   * @notice Sets the sanctions list address for this client\n   *\n   * @param _sanctionsList The new sanctions list address\n   */\n  function _setSanctionsList(address _sanctionsList) internal {\n    if (_sanctionsList == address(0)) {\n      revert SanctionsListZeroAddress();\n    }\n    address oldSanctionsList = address(sanctionsList);\n    sanctionsList = ISanctionsList(_sanctionsList);\n    emit SanctionsListSet(oldSanctionsList, _sanctionsList);\n  }\n\n  /**\n   * @notice Checks whether an address has been sanctioned\n   *\n   * @param account The account to check\n   */\n  function _isSanctioned(address account) internal view returns (bool) {\n    return sanctionsList.isSanctioned(account);\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n  /**\n   * @dev Indicates that the contract has been initialized.\n   * @custom:oz-retyped-from bool\n   */\n  uint8 private _initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private _initializing;\n\n  /**\n   * @dev Triggered when the contract has been initialized or reinitialized.\n   */\n  event Initialized(uint8 version);\n\n  /**\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n   * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n   */\n  modifier initializer() {\n    bool isTopLevelCall = !_initializing;\n    require(\n      (isTopLevelCall && _initialized < 1) ||\n        (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n      \"Initializable: contract is already initialized\"\n    );\n    _initialized = 1;\n    if (isTopLevelCall) {\n      _initializing = true;\n    }\n    _;\n    if (isTopLevelCall) {\n      _initializing = false;\n      emit Initialized(1);\n    }\n  }\n\n  /**\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n   * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n   * used to initialize parent contracts.\n   *\n   * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n   * initialization step. This is essential to configure modules that are added through upgrades and that require\n   * initialization.\n   *\n   * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n   * a contract, executing them in the right order is up to the developer or operator.\n   */\n  modifier reinitializer(uint8 version) {\n    require(\n      !_initializing && _initialized < version,\n      \"Initializable: contract is already initialized\"\n    );\n    _initialized = version;\n    _initializing = true;\n    _;\n    _initializing = false;\n    emit Initialized(version);\n  }\n\n  /**\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n   * {initializer} and {reinitializer} modifiers, directly or indirectly.\n   */\n  modifier onlyInitializing() {\n    require(_initializing, \"Initializable: contract is not initializing\");\n    _;\n  }\n\n  /**\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n   * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n   * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n   * through proxies.\n   */\n  function _disableInitializers() internal virtual {\n    require(!_initializing, \"Initializable: contract is initializing\");\n    if (_initialized < type(uint8).max) {\n      _initialized = type(uint8).max;\n      emit Initialized(type(uint8).max);\n    }\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   *\n   * [IMPORTANT]\n   * ====\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\n   *\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n   * constructor.\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(\n      success,\n      \"Address: unable to send value, recipient may have reverted\"\n    );\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n   * plain `call` is an unsafe replacement for a function call: use this\n   * function instead.\n   *\n   * If `target` reverts with a revert reason, it is bubbled up by this\n   * function (like regular Solidity function calls).\n   *\n   * Returns the raw returned data. To convert to the expected return value,\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n   *\n   * Requirements:\n   *\n   * - `target` must be a contract.\n   * - calling `target` with `data` must not revert.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(address target, bytes memory data)\n    internal\n    returns (bytes memory)\n  {\n    return functionCall(target, data, \"Address: low-level call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n   * `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but also transferring `value` wei to `target`.\n   *\n   * Requirements:\n   *\n   * - the calling contract must have an ETH balance of at least `value`.\n   * - the called Solidity function must be `payable`.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return\n      functionCallWithValue(\n        target,\n        data,\n        value,\n        \"Address: low-level call with value failed\"\n      );\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(\n      address(this).balance >= value,\n      \"Address: insufficient balance for call\"\n    );\n    require(isContract(target), \"Address: call to non-contract\");\n\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(address target, bytes memory data)\n    internal\n    view\n    returns (bytes memory)\n  {\n    return\n      functionStaticCall(target, data, \"Address: low-level static call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    require(isContract(target), \"Address: static call to non-contract\");\n\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n   * revert reason using the provided one.\n   *\n   * _Available since v4.3._\n   */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n        /// @solidity memory-safe-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n}\n"
    },
    "contracts/usdy/USDY.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/ERC20PresetMinterPauserUpgradeable.sol\";\nimport \"contracts/usdy/blocklist/BlocklistClientUpgradeable.sol\";\nimport \"contracts/usdy/allowlist/AllowlistClientUpgradeable.sol\";\nimport \"contracts/sanctions/SanctionsListClientUpgradeable.sol\";\n\ncontract USDY is\n  ERC20PresetMinterPauserUpgradeable,\n  BlocklistClientUpgradeable,\n  AllowlistClientUpgradeable,\n  SanctionsListClientUpgradeable\n{\n  bytes32 public constant LIST_CONFIGURER_ROLE =\n    keccak256(\"LIST_CONFIGURER_ROLE\");\n  bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(\n    string memory name,\n    string memory symbol,\n    address blocklist,\n    address allowlist,\n    address sanctionsList\n  ) public initializer {\n    __ERC20PresetMinterPauser_init(name, symbol);\n    __BlocklistClientInitializable_init(blocklist);\n    __AllowlistClientInitializable_init(allowlist);\n    __SanctionsListClientInitializable_init(sanctionsList);\n  }\n\n  /**\n   * @notice Sets the blocklist address\n   *\n   * @param blocklist New blocklist address\n   */\n  function setBlocklist(\n    address blocklist\n  ) external override onlyRole(LIST_CONFIGURER_ROLE) {\n    _setBlocklist(blocklist);\n  }\n\n  /**\n   * @notice Sets the allowlist address\n   *\n   * @param allowlist New allowlist address\n   */\n  function setAllowlist(\n    address allowlist\n  ) external override onlyRole(LIST_CONFIGURER_ROLE) {\n    _setAllowlist(allowlist);\n  }\n\n  /**\n   * @notice Sets the sanctions list address\n   *\n   * @param sanctionsList New sanctions list address\n   */\n  function setSanctionsList(\n    address sanctionsList\n  ) external override onlyRole(LIST_CONFIGURER_ROLE) {\n    _setSanctionsList(sanctionsList);\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal override {\n    super._beforeTokenTransfer(from, to, amount);\n\n    // Check constraints when `transferFrom` is called to facliitate\n    // a transfer between two parties that are not `from` or `to`.\n    if (from != msg.sender && to != msg.sender) {\n      require(!_isBlocked(msg.sender), \"USDY: 'sender' address blocked\");\n      require(!_isSanctioned(msg.sender), \"USDY: 'sender' address sanctioned\");\n      require(\n        _isAllowed(msg.sender),\n        \"USDY: 'sender' address not on allowlist\"\n      );\n    }\n\n    if (from != address(0)) {\n      // If not minting\n      require(!_isBlocked(from), \"USDY: 'from' address blocked\");\n      require(!_isSanctioned(from), \"USDY: 'from' address sanctioned\");\n      require(_isAllowed(from), \"USDY: 'from' address not on allowlist\");\n    }\n\n    if (to != address(0)) {\n      // If not burning\n      require(!_isBlocked(to), \"USDY: 'to' address blocked\");\n      require(!_isSanctioned(to), \"USDY: 'to' address sanctioned\");\n      require(_isAllowed(to), \"USDY: 'to' address not on allowlist\");\n    }\n  }\n\n  /**\n   * @notice Burns a specific amount of tokens\n   *\n   * @param from The account whose tokens will be burned\n   * @param amount The amount of token to be burned\n   *\n   * @dev This function can be considered an admin-burn and is only callable\n   *      by an address with the `BURNER_ROLE`\n   */\n  function burn(address from, uint256 amount) external onlyRole(BURNER_ROLE) {\n    _burn(from, amount);\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/ERC20PresetMinterPauserUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/presets/ERC20PresetMinterPauser.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/ERC20BurnableUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n *\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\n */\ncontract ERC20PresetMinterPauserUpgradeable is\n  Initializable,\n  ContextUpgradeable,\n  AccessControlEnumerableUpgradeable,\n  ERC20BurnableUpgradeable,\n  ERC20PausableUpgradeable\n{\n  function initialize(string memory name, string memory symbol)\n    public\n    virtual\n    initializer\n  {\n    __ERC20PresetMinterPauser_init(name, symbol);\n  }\n\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n  /**\n   * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n   * account that deploys the contract.\n   *\n   * See {ERC20-constructor}.\n   */\n  function __ERC20PresetMinterPauser_init(\n    string memory name,\n    string memory symbol\n  ) internal onlyInitializing {\n    __ERC20_init_unchained(name, symbol);\n    __Pausable_init_unchained();\n    __ERC20PresetMinterPauser_init_unchained(name, symbol);\n  }\n\n  function __ERC20PresetMinterPauser_init_unchained(\n    string memory,\n    string memory\n  ) internal onlyInitializing {\n    _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n    _setupRole(MINTER_ROLE, _msgSender());\n    _setupRole(PAUSER_ROLE, _msgSender());\n  }\n\n  /**\n   * @dev Creates `amount` new tokens for `to`.\n   *\n   * See {ERC20-_mint}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `MINTER_ROLE`.\n   */\n  function mint(address to, uint256 amount) public virtual {\n    require(\n      hasRole(MINTER_ROLE, _msgSender()),\n      \"ERC20PresetMinterPauser: must have minter role to mint\"\n    );\n    _mint(to, amount);\n  }\n\n  /**\n   * @dev Pauses all token transfers.\n   *\n   * See {ERC20Pausable} and {Pausable-_pause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `PAUSER_ROLE`.\n   */\n  function pause() public virtual {\n    require(\n      hasRole(PAUSER_ROLE, _msgSender()),\n      \"ERC20PresetMinterPauser: must have pauser role to pause\"\n    );\n    _pause();\n  }\n\n  /**\n   * @dev Unpauses all token transfers.\n   *\n   * See {ERC20Pausable} and {Pausable-_unpause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `PAUSER_ROLE`.\n   */\n  function unpause() public virtual {\n    require(\n      hasRole(PAUSER_ROLE, _msgSender()),\n      \"ERC20PresetMinterPauser: must have pauser role to unpause\"\n    );\n    _unpause();\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual override(ERC20Upgradeable, ERC20PausableUpgradeable) {\n    super._beforeTokenTransfer(from, to, amount);\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/usdy/blocklist/BlocklistClientUpgradeable.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IBlocklist.sol\";\nimport \"contracts/interfaces/IBlocklistClient.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\n/**\n * @title BlocklistClient\n * @author Ondo Finance\n * @notice This abstract contract manages state for upgradeable blocklist\n *         clients\n */\nabstract contract BlocklistClientUpgradeable is\n  Initializable,\n  IBlocklistClient\n{\n  // Blocklist contract\n  IBlocklist public override blocklist;\n\n  /**\n   * @notice Initialize the contract by setting blocklist variable\n   *\n   * @param _blocklist Address of the blocklist contract\n   *\n   * @dev Function should be called by the inheriting contract on\n   *      initialization\n   */\n  function __BlocklistClientInitializable_init(\n    address _blocklist\n  ) internal onlyInitializing {\n    __BlocklistClientInitializable_init_unchained(_blocklist);\n  }\n\n  /**\n   * @dev Internal function to future-proof parent linearization. Matches OZ\n   *      upgradeable suggestions\n   */\n  function __BlocklistClientInitializable_init_unchained(\n    address _blocklist\n  ) internal onlyInitializing {\n    _setBlocklist(_blocklist);\n  }\n\n  /**\n   * @notice Sets the blocklist address for this client\n   *\n   * @param _blocklist The new blocklist address\n   */\n  function _setBlocklist(address _blocklist) internal {\n    if (_blocklist == address(0)) {\n      revert BlocklistZeroAddress();\n    }\n    address oldBlocklist = address(blocklist);\n    blocklist = IBlocklist(_blocklist);\n    emit BlocklistSet(oldBlocklist, _blocklist);\n  }\n\n  /**\n   * @notice Checks whether an address has been blocked\n   *\n   * @param account The account to check\n   */\n  function _isBlocked(address account) internal view returns (bool) {\n    return blocklist.isBlocked(account);\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/usdy/allowlist/AllowlistClientUpgradeable.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IAllowlist.sol\";\nimport \"contracts/interfaces/IAllowlistClient.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\n/**\n * @title AllowlistClientInitializable\n * @author Ondo Finance\n * @notice This abstract contract manages state required for clients\n *         of the allowlist\n */\nabstract contract AllowlistClientUpgradeable is\n  Initializable,\n  IAllowlistClient\n{\n  // allowlist address\n  IAllowlist public override allowlist;\n\n  /**\n   * @notice Initialize the contract by setting allowlist variable\n   *\n   * @param _allowlist Address of the allowlist contract\n   *\n   * @dev Function should be called by the inheriting contract on\n   *      initialization\n   */\n  function __AllowlistClientInitializable_init(\n    address _allowlist\n  ) internal onlyInitializing {\n    __AllowlistClientInitializable_init_unchained(_allowlist);\n  }\n\n  /**\n   * @dev Internal function to future-proof parent linearization. Matches OZ\n   *      upgradeable suggestions\n   */\n  function __AllowlistClientInitializable_init_unchained(\n    address _allowlist\n  ) internal onlyInitializing {\n    _setAllowlist(_allowlist);\n  }\n\n  /**\n   * @notice Sets the allowlist address for this client\n   *\n   * @param _allowlist The new allowlist address\n   */\n  function _setAllowlist(address _allowlist) internal {\n    if (_allowlist == address(0)) {\n      revert AllowlistZeroAddress();\n    }\n    address oldAllowlist = address(allowlist);\n    allowlist = IAllowlist(_allowlist);\n    emit AllowlistSet(oldAllowlist, _allowlist);\n  }\n\n  /**\n   * @notice Checks whether an address has been Blocked\n   *\n   * @param account The account to check\n   */\n  function _isAllowed(address account) internal view returns (bool) {\n    return allowlist.isAllowed(account);\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/IERC20MetadataUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is\n  Initializable,\n  ContextUpgradeable,\n  IERC20Upgradeable,\n  IERC20MetadataUpgradeable\n{\n  mapping(address => uint256) private _balances;\n\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n\n  /**\n   * @dev Sets the values for {name} and {symbol}.\n   *\n   * The default value of {decimals} is 18. To select a different value for\n   * {decimals} you should overload it.\n   *\n   * All two of these values are immutable: they can only be set once during\n   * construction.\n   */\n  function __ERC20_init(string memory name_, string memory symbol_)\n    internal\n    onlyInitializing\n  {\n    __ERC20_init_unchained(name_, symbol_);\n  }\n\n  function __ERC20_init_unchained(string memory name_, string memory symbol_)\n    internal\n    onlyInitializing\n  {\n    _name = name_;\n    _symbol = symbol_;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() public view virtual override returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public view virtual override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\n   * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n   *\n   * Tokens usually opt for a value of 18, imitating the relationship between\n   * Ether and Wei. This is the value {ERC20} uses, unless this function is\n   * overridden;\n   *\n   * NOTE: This information is only used for _display_ purposes: it in\n   * no way affects any of the arithmetic of the contract, including\n   * {IERC20-balanceOf} and {IERC20-transfer}.\n   */\n  function decimals() public view virtual override returns (uint8) {\n    return 18;\n  }\n\n  /**\n   * @dev See {IERC20-totalSupply}.\n   */\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {IERC20-balanceOf}.\n   */\n  function balanceOf(address account)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {IERC20-transfer}.\n   *\n   * Requirements:\n   *\n   * - `to` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(address to, uint256 amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    address owner = _msgSender();\n    _transfer(owner, to, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-allowance}.\n   */\n  function allowance(address owner, address spender)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {IERC20-approve}.\n   *\n   * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n   * `transferFrom`. This is semantically equivalent to an infinite approval.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint256 amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    address owner = _msgSender();\n    _approve(owner, spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-transferFrom}.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {ERC20}.\n   *\n   * NOTE: Does not update the allowance if the current allowance\n   * is the maximum `uint256`.\n   *\n   * Requirements:\n   *\n   * - `from` and `to` cannot be the zero address.\n   * - `from` must have a balance of at least `amount`.\n   * - the caller must have allowance for ``from``'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    address spender = _msgSender();\n    _spendAllowance(from, spender, amount);\n    _transfer(from, to, amount);\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(address spender, uint256 addedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    address owner = _msgSender();\n    _approve(owner, spender, allowance(owner, spender) + addedValue);\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    address owner = _msgSender();\n    uint256 currentAllowance = allowance(owner, spender);\n    require(\n      currentAllowance >= subtractedValue,\n      \"ERC20: decreased allowance below zero\"\n    );\n    unchecked {\n      _approve(owner, spender, currentAllowance - subtractedValue);\n    }\n\n    return true;\n  }\n\n  /**\n   * @dev Moves `amount` of tokens from `from` to `to`.\n   *\n   * This internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `from` must have a balance of at least `amount`.\n   */\n  function _transfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {\n    require(from != address(0), \"ERC20: transfer from the zero address\");\n    require(to != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(from, to, amount);\n\n    uint256 fromBalance = _balances[from];\n    require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n    unchecked {\n      _balances[from] = fromBalance - amount;\n    }\n    _balances[to] += amount;\n\n    emit Transfer(from, to, amount);\n\n    _afterTokenTransfer(from, to, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   *\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   */\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply += amount;\n    _balances[account] += amount;\n    emit Transfer(address(0), account, amount);\n\n    _afterTokenTransfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * Emits a {Transfer} event with `to` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   * - `account` must have at least `amount` tokens.\n   */\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n    unchecked {\n      _balances[account] = accountBalance - amount;\n    }\n    _totalSupply -= amount;\n\n    emit Transfer(account, address(0), amount);\n\n    _afterTokenTransfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n   *\n   * This internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n   *\n   * Does not update the allowance amount in case of infinite allowance.\n   * Revert if not enough allowance is available.\n   *\n   * Might emit an {Approval} event.\n   */\n  function _spendAllowance(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    uint256 currentAllowance = allowance(owner, spender);\n    if (currentAllowance != type(uint256).max) {\n      require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n      unchecked {\n        _approve(owner, spender, currentAllowance - amount);\n      }\n    }\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * will be transferred to `to`.\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n\n  /**\n   * @dev Hook that is called after any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * has been transferred to `to`.\n   * - when `from` is zero, `amount` tokens have been minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _afterTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[45] private __gap;\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is\n  Initializable,\n  ContextUpgradeable,\n  ERC20Upgradeable\n{\n  function __ERC20Burnable_init() internal onlyInitializing {}\n\n  function __ERC20Burnable_init_unchained() internal onlyInitializing {}\n\n  /**\n   * @dev Destroys `amount` tokens from the caller.\n   *\n   * See {ERC20-_burn}.\n   */\n  function burn(uint256 amount) public virtual {\n    _burn(_msgSender(), amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n   * allowance.\n   *\n   * See {ERC20-_burn} and {ERC20-allowance}.\n   *\n   * Requirements:\n   *\n   * - the caller must have allowance for ``accounts``'s tokens of at least\n   * `amount`.\n   */\n  function burnFrom(address account, uint256 amount) public virtual {\n    _spendAllowance(account, _msgSender(), amount);\n    _burn(account, amount);\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20PausableUpgradeable is\n  Initializable,\n  ERC20Upgradeable,\n  PausableUpgradeable\n{\n  function __ERC20Pausable_init() internal onlyInitializing {\n    __Pausable_init_unchained();\n  }\n\n  function __ERC20Pausable_init_unchained() internal onlyInitializing {}\n\n  /**\n   * @dev See {ERC20-_beforeTokenTransfer}.\n   *\n   * Requirements:\n   *\n   * - the contract must not be paused.\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual override {\n    super._beforeTokenTransfer(from, to, amount);\n\n    require(!paused(), \"ERC20Pausable: token transfer while paused\");\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is\n  Initializable,\n  IAccessControlEnumerableUpgradeable,\n  AccessControlUpgradeable\n{\n  function __AccessControlEnumerable_init() internal onlyInitializing {}\n\n  function __AccessControlEnumerable_init_unchained()\n    internal\n    onlyInitializing\n  {}\n\n  using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n  mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return\n      interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev Returns one of the accounts that have `role`. `index` must be a\n   * value between 0 and {getRoleMemberCount}, non-inclusive.\n   *\n   * Role bearers are not sorted in any particular way, and their ordering may\n   * change at any point.\n   *\n   * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n   * you perform all queries on the same block. See the following\n   * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n   * for more information.\n   */\n  function getRoleMember(bytes32 role, uint256 index)\n    public\n    view\n    virtual\n    override\n    returns (address)\n  {\n    return _roleMembers[role].at(index);\n  }\n\n  /**\n   * @dev Returns the number of accounts that have `role`. Can be used\n   * together with {getRoleMember} to enumerate all bearers of a role.\n   */\n  function getRoleMemberCount(bytes32 role)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _roleMembers[role].length();\n  }\n\n  /**\n   * @dev Overload {_grantRole} to track enumerable memberships\n   */\n  function _grantRole(bytes32 role, address account) internal virtual override {\n    super._grantRole(role, account);\n    _roleMembers[role].add(account);\n  }\n\n  /**\n   * @dev Overload {_revokeRole} to track enumerable memberships\n   */\n  function _revokeRole(bytes32 role, address account)\n    internal\n    virtual\n    override\n  {\n    super._revokeRole(role, account);\n    _roleMembers[role].remove(account);\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[49] private __gap;\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n  function __Context_init() internal onlyInitializing {}\n\n  function __Context_init_unchained() internal onlyInitializing {}\n\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `to`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `from` to `to` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external returns (bool);\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the decimals places of the token.\n   */\n  function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n  /**\n   * @dev Emitted when the pause is triggered by `account`.\n   */\n  event Paused(address account);\n\n  /**\n   * @dev Emitted when the pause is lifted by `account`.\n   */\n  event Unpaused(address account);\n\n  bool private _paused;\n\n  /**\n   * @dev Initializes the contract in unpaused state.\n   */\n  function __Pausable_init() internal onlyInitializing {\n    __Pausable_init_unchained();\n  }\n\n  function __Pausable_init_unchained() internal onlyInitializing {\n    _paused = false;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   *\n   * Requirements:\n   *\n   * - The contract must not be paused.\n   */\n  modifier whenNotPaused() {\n    _requireNotPaused();\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   *\n   * Requirements:\n   *\n   * - The contract must be paused.\n   */\n  modifier whenPaused() {\n    _requirePaused();\n    _;\n  }\n\n  /**\n   * @dev Returns true if the contract is paused, and false otherwise.\n   */\n  function paused() public view virtual returns (bool) {\n    return _paused;\n  }\n\n  /**\n   * @dev Throws if the contract is paused.\n   */\n  function _requireNotPaused() internal view virtual {\n    require(!paused(), \"Pausable: paused\");\n  }\n\n  /**\n   * @dev Throws if the contract is not paused.\n   */\n  function _requirePaused() internal view virtual {\n    require(paused(), \"Pausable: not paused\");\n  }\n\n  /**\n   * @dev Triggers stopped state.\n   *\n   * Requirements:\n   *\n   * - The contract must not be paused.\n   */\n  function _pause() internal virtual whenNotPaused {\n    _paused = true;\n    emit Paused(_msgSender());\n  }\n\n  /**\n   * @dev Returns to normal state.\n   *\n   * Requirements:\n   *\n   * - The contract must be paused.\n   */\n  function _unpause() internal virtual whenPaused {\n    _paused = false;\n    emit Unpaused(_msgSender());\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[49] private __gap;\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n  /**\n   * @dev Returns one of the accounts that have `role`. `index` must be a\n   * value between 0 and {getRoleMemberCount}, non-inclusive.\n   *\n   * Role bearers are not sorted in any particular way, and their ordering may\n   * change at any point.\n   *\n   * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n   * you perform all queries on the same block. See the following\n   * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n   * for more information.\n   */\n  function getRoleMember(bytes32 role, uint256 index)\n    external\n    view\n    returns (address);\n\n  /**\n   * @dev Returns the number of accounts that have `role`. Can be used\n   * together with {getRoleMember} to enumerate all bearers of a role.\n   */\n  function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/ERC165Upgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is\n  Initializable,\n  ContextUpgradeable,\n  IAccessControlUpgradeable,\n  ERC165Upgradeable\n{\n  function __AccessControl_init() internal onlyInitializing {}\n\n  function __AccessControl_init_unchained() internal onlyInitializing {}\n\n  struct RoleData {\n    mapping(address => bool) members;\n    bytes32 adminRole;\n  }\n\n  mapping(bytes32 => RoleData) private _roles;\n\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n  /**\n   * @dev Modifier that checks that an account has a specific role. Reverts\n   * with a standardized message including the required role.\n   *\n   * The format of the revert reason is given by the following regular expression:\n   *\n   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n   *\n   * _Available since v4.1._\n   */\n  modifier onlyRole(bytes32 role) {\n    _checkRole(role);\n    _;\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return\n      interfaceId == type(IAccessControlUpgradeable).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev Returns `true` if `account` has been granted `role`.\n   */\n  function hasRole(bytes32 role, address account)\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return _roles[role].members[account];\n  }\n\n  /**\n   * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n   * Overriding this function changes the behavior of the {onlyRole} modifier.\n   *\n   * Format of the revert message is described in {_checkRole}.\n   *\n   * _Available since v4.6._\n   */\n  function _checkRole(bytes32 role) internal view virtual {\n    _checkRole(role, _msgSender());\n  }\n\n  /**\n   * @dev Revert with a standard message if `account` is missing `role`.\n   *\n   * The format of the revert reason is given by the following regular expression:\n   *\n   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n   */\n  function _checkRole(bytes32 role, address account) internal view virtual {\n    if (!hasRole(role, account)) {\n      revert(\n        string(\n          abi.encodePacked(\n            \"AccessControl: account \",\n            StringsUpgradeable.toHexString(uint160(account), 20),\n            \" is missing role \",\n            StringsUpgradeable.toHexString(uint256(role), 32)\n          )\n        )\n      );\n    }\n  }\n\n  /**\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\n   * {revokeRole}.\n   *\n   * To change a role's admin, use {_setRoleAdmin}.\n   */\n  function getRoleAdmin(bytes32 role)\n    public\n    view\n    virtual\n    override\n    returns (bytes32)\n  {\n    return _roles[role].adminRole;\n  }\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   *\n   * May emit a {RoleGranted} event.\n   */\n  function grantRole(bytes32 role, address account)\n    public\n    virtual\n    override\n    onlyRole(getRoleAdmin(role))\n  {\n    _grantRole(role, account);\n  }\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   *\n   * May emit a {RoleRevoked} event.\n   */\n  function revokeRole(bytes32 role, address account)\n    public\n    virtual\n    override\n    onlyRole(getRoleAdmin(role))\n  {\n    _revokeRole(role, account);\n  }\n\n  /**\n   * @dev Revokes `role` from the calling account.\n   *\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\n   * purpose is to provide a mechanism for accounts to lose their privileges\n   * if they are compromised (such as when a trusted device is misplaced).\n   *\n   * If the calling account had been revoked `role`, emits a {RoleRevoked}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must be `account`.\n   *\n   * May emit a {RoleRevoked} event.\n   */\n  function renounceRole(bytes32 role, address account) public virtual override {\n    require(\n      account == _msgSender(),\n      \"AccessControl: can only renounce roles for self\"\n    );\n\n    _revokeRole(role, account);\n  }\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event. Note that unlike {grantRole}, this function doesn't perform any\n   * checks on the calling account.\n   *\n   * May emit a {RoleGranted} event.\n   *\n   * [WARNING]\n   * ====\n   * This function should only be called from the constructor when setting\n   * up the initial roles for the system.\n   *\n   * Using this function in any other way is effectively circumventing the admin\n   * system imposed by {AccessControl}.\n   * ====\n   *\n   * NOTE: This function is deprecated in favor of {_grantRole}.\n   */\n  function _setupRole(bytes32 role, address account) internal virtual {\n    _grantRole(role, account);\n  }\n\n  /**\n   * @dev Sets `adminRole` as ``role``'s admin role.\n   *\n   * Emits a {RoleAdminChanged} event.\n   */\n  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n    bytes32 previousAdminRole = getRoleAdmin(role);\n    _roles[role].adminRole = adminRole;\n    emit RoleAdminChanged(role, previousAdminRole, adminRole);\n  }\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * Internal function without access restriction.\n   *\n   * May emit a {RoleGranted} event.\n   */\n  function _grantRole(bytes32 role, address account) internal virtual {\n    if (!hasRole(role, account)) {\n      _roles[role].members[account] = true;\n      emit RoleGranted(role, account, _msgSender());\n    }\n  }\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * Internal function without access restriction.\n   *\n   * May emit a {RoleRevoked} event.\n   */\n  function _revokeRole(bytes32 role, address account) internal virtual {\n    if (hasRole(role, account)) {\n      _roles[role].members[account] = false;\n      emit RoleRevoked(role, account, _msgSender());\n    }\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[49] private __gap;\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSetUpgradeable {\n  // To implement this library for multiple types with as little code\n  // repetition as possible, we write it in terms of a generic Set type with\n  // bytes32 values.\n  // The Set implementation uses private functions, and user-facing\n  // implementations (such as AddressSet) are just wrappers around the\n  // underlying Set.\n  // This means that we can only create new EnumerableSets for types that fit\n  // in bytes32.\n\n  struct Set {\n    // Storage of set values\n    bytes32[] _values;\n    // Position of the value in the `values` array, plus 1 because index 0\n    // means a value is not in the set.\n    mapping(bytes32 => uint256) _indexes;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function _add(Set storage set, bytes32 value) private returns (bool) {\n    if (!_contains(set, value)) {\n      set._values.push(value);\n      // The value is stored at length-1, but we add 1 to all indexes\n      // and use 0 as a sentinel value\n      set._indexes[value] = set._values.length;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\n    // We read and store the value's index to prevent multiple reads from the same storage slot\n    uint256 valueIndex = set._indexes[value];\n\n    if (valueIndex != 0) {\n      // Equivalent to contains(set, value)\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\n      // This modifies the order of the array, as noted in {at}.\n\n      uint256 toDeleteIndex = valueIndex - 1;\n      uint256 lastIndex = set._values.length - 1;\n\n      if (lastIndex != toDeleteIndex) {\n        bytes32 lastValue = set._values[lastIndex];\n\n        // Move the last value to the index where the value to delete is\n        set._values[toDeleteIndex] = lastValue;\n        // Update the index for the moved value\n        set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n      }\n\n      // Delete the slot where the moved value was stored\n      set._values.pop();\n\n      // Delete the index for the deleted slot\n      delete set._indexes[value];\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function _contains(Set storage set, bytes32 value)\n    private\n    view\n    returns (bool)\n  {\n    return set._indexes[value] != 0;\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n   */\n  function _length(Set storage set) private view returns (uint256) {\n    return set._values.length;\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\n    return set._values[index];\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function _values(Set storage set) private view returns (bytes32[] memory) {\n    return set._values;\n  }\n\n  // Bytes32Set\n\n  struct Bytes32Set {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _add(set._inner, value);\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(Bytes32Set storage set, bytes32 value)\n    internal\n    returns (bool)\n  {\n    return _remove(set._inner, value);\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(Bytes32Set storage set, bytes32 value)\n    internal\n    view\n    returns (bool)\n  {\n    return _contains(set._inner, value);\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(Bytes32Set storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(Bytes32Set storage set, uint256 index)\n    internal\n    view\n    returns (bytes32)\n  {\n    return _at(set._inner, index);\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(Bytes32Set storage set)\n    internal\n    view\n    returns (bytes32[] memory)\n  {\n    return _values(set._inner);\n  }\n\n  // AddressSet\n\n  struct AddressSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(AddressSet storage set, address value) internal returns (bool) {\n    return _add(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(AddressSet storage set, address value)\n    internal\n    returns (bool)\n  {\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(AddressSet storage set, address value)\n    internal\n    view\n    returns (bool)\n  {\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(AddressSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(AddressSet storage set, uint256 index)\n    internal\n    view\n    returns (address)\n  {\n    return address(uint160(uint256(_at(set._inner, index))));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(AddressSet storage set)\n    internal\n    view\n    returns (address[] memory)\n  {\n    bytes32[] memory store = _values(set._inner);\n    address[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // UintSet\n\n  struct UintSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\n    return _add(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\n    return _remove(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(UintSet storage set, uint256 value)\n    internal\n    view\n    returns (bool)\n  {\n    return _contains(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n   */\n  function length(UintSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(UintSet storage set, uint256 index)\n    internal\n    view\n    returns (uint256)\n  {\n    return uint256(_at(set._inner, index));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(UintSet storage set)\n    internal\n    view\n    returns (uint256[] memory)\n  {\n    bytes32[] memory store = _values(set._inner);\n    uint256[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n  /**\n   * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n   *\n   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n   * {RoleAdminChanged} not being emitted signaling this.\n   *\n   * _Available since v3.1._\n   */\n  event RoleAdminChanged(\n    bytes32 indexed role,\n    bytes32 indexed previousAdminRole,\n    bytes32 indexed newAdminRole\n  );\n\n  /**\n   * @dev Emitted when `account` is granted `role`.\n   *\n   * `sender` is the account that originated the contract call, an admin role\n   * bearer except when using {AccessControl-_setupRole}.\n   */\n  event RoleGranted(\n    bytes32 indexed role,\n    address indexed account,\n    address indexed sender\n  );\n\n  /**\n   * @dev Emitted when `account` is revoked `role`.\n   *\n   * `sender` is the account that originated the contract call:\n   *   - if using `revokeRole`, it is the admin role bearer\n   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n   */\n  event RoleRevoked(\n    bytes32 indexed role,\n    address indexed account,\n    address indexed sender\n  );\n\n  /**\n   * @dev Returns `true` if `account` has been granted `role`.\n   */\n  function hasRole(bytes32 role, address account) external view returns (bool);\n\n  /**\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\n   * {revokeRole}.\n   *\n   * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n   */\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function grantRole(bytes32 role, address account) external;\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function revokeRole(bytes32 role, address account) external;\n\n  /**\n   * @dev Revokes `role` from the calling account.\n   *\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\n   * purpose is to provide a mechanism for accounts to lose their privileges\n   * if they are compromised (such as when a trusted device is misplaced).\n   *\n   * If the calling account had been granted `role`, emits a {RoleRevoked}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must be `account`.\n   */\n  function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n  bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n  uint8 private constant _ADDRESS_LENGTH = 20;\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n   */\n  function toString(uint256 value) internal pure returns (string memory) {\n    // Inspired by OraclizeAPI's implementation - MIT licence\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n    if (value == 0) {\n      return \"0\";\n    }\n    uint256 temp = value;\n    uint256 digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n   */\n  function toHexString(uint256 value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0x00\";\n    }\n    uint256 temp = value;\n    uint256 length = 0;\n    while (temp != 0) {\n      length++;\n      temp >>= 8;\n    }\n    return toHexString(value, length);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n   */\n  function toHexString(uint256 value, uint256 length)\n    internal\n    pure\n    returns (string memory)\n  {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = \"0\";\n    buffer[1] = \"x\";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = _HEX_SYMBOLS[value & 0xf];\n      value >>= 4;\n    }\n    require(value == 0, \"Strings: hex length insufficient\");\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n   */\n  function toHexString(address addr) internal pure returns (string memory) {\n    return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/utils/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/IERC165Upgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n  function __ERC165_init() internal onlyInitializing {}\n\n  function __ERC165_init_unchained() internal onlyInitializing {}\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return interfaceId == type(IERC165Upgradeable).interfaceId;\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/utils/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30 000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IAllowlist.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\ninterface IAllowlist {\n  function addTerm(string calldata term) external;\n\n  function setCurrentTermIndex(uint256 _currentTermIndex) external;\n\n  function setValidTermIndexes(uint256[] calldata indexes) external;\n\n  function isAllowed(address account) external view returns (bool);\n\n  function getCurrentTerm() external view returns (string memory);\n\n  function getValidTermIndexes() external view returns (uint256[] memory);\n\n  function addAccountToAllowlist(\n    uint256 _currentTermIndex,\n    address account,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function addSelfToAllowlist(uint256 termIndex) external;\n\n  function setAccountStatus(\n    address account,\n    uint256 termIndex,\n    bool status\n  ) external;\n\n  /**\n   * @notice Event emitted when a term is added\n   *\n   * @param hashedMessage The hash of the terms string that was added\n   * @param termIndex     The index of the term that was added\n   */\n  event TermAdded(bytes32 hashedMessage, uint256 termIndex);\n\n  /**\n   * @notice Event emitted when the current term index is set\n   *\n   * @param oldIndex The old current term index\n   * @param newIndex The new current term index\n   */\n  event CurrentTermIndexSet(uint256 oldIndex, uint256 newIndex);\n\n  /**\n   * @notice Event emitted when the valid term indexes are set\n   *\n   * @param oldIndexes The old valid term indexes\n   * @param newIndexes The new valid term indexes\n   */\n  event ValidTermIndexesSet(uint256[] oldIndexes, uint256[] newIndexes);\n\n  /**\n   * @notice Event emitted when an accoun status is set by an admin\n   *\n   * @param account   The account whose status was set\n   * @param termIndex The term index of the account whose status that was set\n   * @param status    The new status of the account\n   */\n  event AccountStatusSetByAdmin(\n    address indexed account,\n    uint256 indexed termIndex,\n    bool status\n  );\n\n  /**\n   * @notice Event emitted when an account adds itself added to the allowlist\n   *\n   * @param account   The account that was added\n   * @param termIndex The term index for which the account was added\n   */\n  event AccountAddedSelf(address indexed account, uint256 indexed termIndex);\n\n  /**\n   * @notice Event emitted when an account is added to the allowlist by a signature\n   *\n   * @param account   The account that was added\n   * @param termIndex The term index for which the account was added\n   * @param v         The v value of the signature\n   * @param r         The r value of the signature\n   * @param s         The s value of the signature\n   */\n  event AccountAddedFromSignature(\n    address indexed account,\n    uint256 indexed termIndex,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  );\n\n  /**\n   * @notice Event emitted when an account status is set\n   *\n   * @param account   The account whose status was set\n   * @param termIndex The term index of the account whose status was set\n   * @param status    The new status of the account\n   */\n  event AccountStatusSet(\n    address indexed account,\n    uint256 indexed termIndex,\n    bool status\n  );\n\n  /// ERRORS ///\n  error InvalidTermIndex();\n  error InvalidVSignature();\n  error AlreadyVerified();\n  error InvalidSigner();\n}\n"
    },
    "contracts/interfaces/IAllowlistClient.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IAllowlist.sol\";\n\n/**\n * @title IAllowlistClient\n * @author Ondo Finance\n * @notice The client interface for Ondo's Allowlist contract.\n */\ninterface IAllowlistClient {\n  /// @notice Returns reference to the allowlist that this client queries\n  function allowlist() external view returns (IAllowlist);\n\n  /// @notice Sets the allowlist contract reference\n  function setAllowlist(address allowlist) external;\n\n  /**\n   * @dev Event for when the allowlist reference is set\n   *\n   * @param oldAllowlist The old allowlist\n   * @param newAllowlist The new allowlist\n   */\n  event AllowlistSet(address oldAllowlist, address newAllowlist);\n\n  /// @notice Error for when caller attempts to set the allowlist reference\n  ///         to the zero address.\n  error AllowlistZeroAddress();\n}\n"
    },
    "contracts/usdy/USDYFactory.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\n// Proxy admin contract used in OZ upgrades plugin\nimport \"contracts/external/openzeppelin/contracts/proxy/ProxyAdmin.sol\";\nimport \"contracts/Proxy.sol\";\nimport \"contracts/usdy/USDY.sol\";\nimport \"contracts/interfaces/IMulticall.sol\";\n\n/**\n * @title USDYFactory\n * @author Ondo Finance\n * @notice This contract serves as a Factory for the upgradable USDY token contract.\n *         Upon calling `deployUSDY` the `guardian` address (set in constructor) will\n *         deploy the following:\n *         1) USDY - The implementation contract, ERC20 contract with the initializer disabled\n *         2) ProxyAdmin - OZ ProxyAdmin contract, used to upgrade the proxy instance.\n *                         @notice Owner is set to `guardian` address.\n *         3) TransparentUpgradeableProxy - OZ, proxy contract. Admin is set to `address(proxyAdmin)`.\n *                                          `_logic' is set to `address(cash)`.\n *\n *         Following the above mentioned deployment, the address of the CashFactory contract will:\n *         i) Grant the `DEFAULT_ADMIN_ROLE` & PAUSER_ROLE to the `guardian` address\n *         ii) Revoke the `MINTER_ROLE`, `PAUSER_ROLE` & `DEFAULT_ADMIN_ROLE` from address(this).\n *         iii) Transfer ownership of the ProxyAdmin to that of the `guardian` address.\n *\n * @notice `guardian` address in constructor is a msig.\n */\ncontract USDYFactory is IMulticall {\n  struct USDYListData {\n    address blocklist;\n    address allowlist;\n    address sanctionsList;\n  }\n\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n  bytes32 public constant DEFAULT_ADMIN_ROLE = bytes32(0);\n\n  address internal immutable guardian;\n  USDY public usdyImplementation;\n  ProxyAdmin public usdyProxyAdmin;\n  TokenProxy public usdyProxy;\n\n  constructor(address _guardian) {\n    guardian = _guardian;\n  }\n\n  /**\n   * @dev This function will deploy an upgradable instance of USDY\n   *\n   * @param name   The name of the token we want to deploy.\n   * @param ticker The ticker for the token we want to deploy.\n   *\n   * @return address The address of the proxy contract.\n   * @return address The address of the proxyAdmin contract.\n   * @return address The address of the implementation contract.\n   *\n   * @notice 1) Will automatically revoke all deployer roles granted to\n   *            address(this).\n   *         2) Will grant DEFAULT_ADMIN & PAUSER_ROLE(S) to `guardian`\n   *            address specified in constructor.\n   *         3) Will transfer ownership of the proxyAdmin to guardian\n   *            address.\n   *\n   */\n  function deployUSDY(\n    string calldata name,\n    string calldata ticker,\n    USDYListData calldata listData\n  ) external onlyGuardian returns (address, address, address) {\n    usdyImplementation = new USDY();\n    usdyProxyAdmin = new ProxyAdmin();\n    usdyProxy = new TokenProxy(\n      address(usdyImplementation),\n      address(usdyProxyAdmin),\n      \"\"\n    );\n    USDY usdyProxied = USDY(address(usdyProxy));\n    usdyProxied.initialize(\n      name,\n      ticker,\n      listData.blocklist,\n      listData.allowlist,\n      listData.sanctionsList\n    );\n\n    usdyProxied.grantRole(DEFAULT_ADMIN_ROLE, guardian);\n    usdyProxied.grantRole(PAUSER_ROLE, guardian);\n\n    usdyProxied.revokeRole(MINTER_ROLE, address(this));\n    usdyProxied.revokeRole(PAUSER_ROLE, address(this));\n    usdyProxied.revokeRole(DEFAULT_ADMIN_ROLE, address(this));\n\n    usdyProxyAdmin.transferOwnership(guardian);\n    assert(usdyProxyAdmin.owner() == guardian);\n    emit USDYDeployed(\n      address(usdyProxied),\n      address(usdyProxyAdmin),\n      address(usdyImplementation),\n      name,\n      ticker,\n      listData\n    );\n\n    return (\n      address(usdyProxied),\n      address(usdyProxyAdmin),\n      address(usdyImplementation)\n    );\n  }\n\n  /**\n   * @notice Allows for arbitrary batched calls\n   *\n   * @dev All external calls made through this function will\n   *      msg.sender == contract address\n   *\n   * @param exCallData Struct consisting of\n   *       1) target - contract to call\n   *       2) data - data to call target with\n   *       3) value - eth value to call target with\n   */\n  function multiexcall(\n    ExCallData[] calldata exCallData\n  ) external payable override onlyGuardian returns (bytes[] memory results) {\n    results = new bytes[](exCallData.length);\n    for (uint256 i = 0; i < exCallData.length; ++i) {\n      (bool success, bytes memory ret) = address(exCallData[i].target).call{\n        value: exCallData[i].value\n      }(exCallData[i].data);\n      require(success, \"Call Failed\");\n      results[i] = ret;\n    }\n  }\n\n  /**\n   * @dev Event emitted when upgradable USDY is deployed\n   *\n   * @param proxy             The address for the proxy contract\n   * @param proxyAdmin        The address for the proxy admin contract\n   * @param implementation    The address for the implementation contract\n   */\n  event USDYDeployed(\n    address proxy,\n    address proxyAdmin,\n    address implementation,\n    string name,\n    string ticker,\n    USDYListData listData\n  );\n\n  modifier onlyGuardian() {\n    require(msg.sender == guardian, \"USDYFactory: You are not the Guardian\");\n    _;\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts/proxy/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\";\nimport \"contracts/external/openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n  /**\n   * @dev Returns the current implementation of `proxy`.\n   *\n   * Requirements:\n   *\n   * - This contract must be the admin of `proxy`.\n   */\n  function getProxyImplementation(TransparentUpgradeableProxy proxy)\n    public\n    view\n    virtual\n    returns (address)\n  {\n    // We need to manually run the static call since the getter cannot be flagged as view\n    // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n    (bool success, bytes memory returndata) =\n      address(proxy).staticcall(hex\"5c60da1b\");\n    require(success);\n    return abi.decode(returndata, (address));\n  }\n\n  /**\n   * @dev Returns the current admin of `proxy`.\n   *\n   * Requirements:\n   *\n   * - This contract must be the admin of `proxy`.\n   */\n  function getProxyAdmin(TransparentUpgradeableProxy proxy)\n    public\n    view\n    virtual\n    returns (address)\n  {\n    // We need to manually run the static call since the getter cannot be flagged as view\n    // bytes4(keccak256(\"admin()\")) == 0xf851a440\n    (bool success, bytes memory returndata) =\n      address(proxy).staticcall(hex\"f851a440\");\n    require(success);\n    return abi.decode(returndata, (address));\n  }\n\n  /**\n   * @dev Changes the admin of `proxy` to `newAdmin`.\n   *\n   * Requirements:\n   *\n   * - This contract must be the current admin of `proxy`.\n   */\n  function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin)\n    public\n    virtual\n    onlyOwner\n  {\n    proxy.changeAdmin(newAdmin);\n  }\n\n  /**\n   * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n   *\n   * Requirements:\n   *\n   * - This contract must be the admin of `proxy`.\n   */\n  function upgrade(TransparentUpgradeableProxy proxy, address implementation)\n    public\n    virtual\n    onlyOwner\n  {\n    proxy.upgradeTo(implementation);\n  }\n\n  /**\n   * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n   * {TransparentUpgradeableProxy-upgradeToAndCall}.\n   *\n   * Requirements:\n   *\n   * - This contract must be the admin of `proxy`.\n   */\n  function upgradeAndCall(\n    TransparentUpgradeableProxy proxy,\n    address implementation,\n    bytes memory data\n  ) public payable virtual onlyOwner {\n    proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n  }\n}\n"
    },
    "contracts/Proxy.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/external/openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\";\n\ncontract TokenProxy is TransparentUpgradeableProxy {\n  constructor(\n    address _logic,\n    address _admin,\n    bytes memory _data\n  ) TransparentUpgradeableProxy(_logic, _admin, _data) {}\n}\n"
    },
    "contracts/interfaces/IMulticall.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\n/**\n * @title IMulticall\n * @author Ondo Finance\n * @notice This interface dictates the required external functions for Ondo's\n *         multicall contract.\n */\ninterface IMulticall {\n  /// @dev External call data structure\n  struct ExCallData {\n    // The contract we intend to call\n    address target;\n    // The encoded function data for the call\n    bytes data;\n    // The ether value to be sent in the call\n    uint256 value;\n  }\n\n  /**\n   * @notice Batches multiple function calls to different target contracts\n   *         and returns the resulting data provided all calls were successful\n   *\n   * @dev The `msg.sender` is always the contract from which this function\n   *      is being called\n   *\n   * @param exdata The ExCallData struct array containing the information\n   *               regarding which contract to call, what data to call with,\n   *               and what ether value to send along with the call\n   *\n   * @return results The resulting data returned from each call made\n   */\n  function multiexcall(\n    ExCallData[] calldata exdata\n  ) external payable returns (bytes[] memory results);\n}\n"
    },
    "contracts/external/openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts/proxy/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n  /**\n   * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n   * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n   */\n  constructor(\n    address _logic,\n    address admin_,\n    bytes memory _data\n  ) payable ERC1967Proxy(_logic, _data) {\n    assert(\n      _ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1)\n    );\n    _changeAdmin(admin_);\n  }\n\n  /**\n   * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n   */\n  modifier ifAdmin() {\n    if (msg.sender == _getAdmin()) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n\n  /**\n   * @dev Returns the current admin.\n   *\n   * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n   *\n   * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n   * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n   * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n   */\n  function admin() external ifAdmin returns (address admin_) {\n    admin_ = _getAdmin();\n  }\n\n  /**\n   * @dev Returns the current implementation.\n   *\n   * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n   *\n   * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n   * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n   * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n   */\n  function implementation() external ifAdmin returns (address implementation_) {\n    implementation_ = _implementation();\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   *\n   * Emits an {AdminChanged} event.\n   *\n   * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n   */\n  function changeAdmin(address newAdmin) external virtual ifAdmin {\n    _changeAdmin(newAdmin);\n  }\n\n  /**\n   * @dev Upgrade the implementation of the proxy.\n   *\n   * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n   */\n  function upgradeTo(address newImplementation) external ifAdmin {\n    _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n  }\n\n  /**\n   * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n   * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n   * proxied contract.\n   *\n   * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n   */\n  function upgradeToAndCall(address newImplementation, bytes calldata data)\n    external\n    payable\n    ifAdmin\n  {\n    _upgradeToAndCall(newImplementation, data, true);\n  }\n\n  /**\n   * @dev Returns the current admin.\n   */\n  function _admin() internal view virtual returns (address) {\n    return _getAdmin();\n  }\n\n  /**\n   * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n   */\n  function _beforeFallback() internal virtual override {\n    require(\n      msg.sender != _getAdmin(),\n      \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\"\n    );\n    super._beforeFallback();\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts/utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n  address private _owner;\n\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  /**\n   * @dev Initializes the contract setting the deployer as the initial owner.\n   */\n  constructor() {\n    _transferOwnership(_msgSender());\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function owner() public view virtual returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  /**\n   * @dev Leaves the contract without owner. It will not be possible to call\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\n   *\n   * NOTE: Renouncing ownership will leave the contract without an owner,\n   * thereby removing any functionality that is only available to the owner.\n   */\n  function renounceOwnership() public virtual onlyOwner {\n    _transferOwnership(address(0));\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    _transferOwnership(newOwner);\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Internal function without access restriction.\n   */\n  function _transferOwnership(address newOwner) internal virtual {\n    address oldOwner = _owner;\n    _owner = newOwner;\n    emit OwnershipTransferred(oldOwner, newOwner);\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts/proxy/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts/proxy/Proxy.sol\";\nimport \"contracts/external/openzeppelin/contracts/proxy/ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n  /**\n   * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n   *\n   * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n   * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n   */\n  constructor(address _logic, bytes memory _data) payable {\n    assert(\n      _IMPLEMENTATION_SLOT ==\n        bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1)\n    );\n    _upgradeToAndCall(_logic, _data, false);\n  }\n\n  /**\n   * @dev Returns the current implementation address.\n   */\n  function _implementation()\n    internal\n    view\n    virtual\n    override\n    returns (address impl)\n  {\n    return ERC1967Upgrade._getImplementation();\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n  /**\n   * @dev Delegates the current call to `implementation`.\n   *\n   * This function does not return to its internal call site, it will return directly to the external caller.\n   */\n  function _delegate(address implementation) internal virtual {\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n        // delegatecall returns 0 on error.\n        case 0 {\n          revert(0, returndatasize())\n        }\n        default {\n          return(0, returndatasize())\n        }\n    }\n  }\n\n  /**\n   * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n   * and {_fallback} should delegate.\n   */\n  function _implementation() internal view virtual returns (address);\n\n  /**\n   * @dev Delegates the current call to the address returned by `_implementation()`.\n   *\n   * This function does not return to its internall call site, it will return directly to the external caller.\n   */\n  function _fallback() internal virtual {\n    _beforeFallback();\n    _delegate(_implementation());\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n   * function in the contract matches the call data.\n   */\n  fallback() external payable {\n    _fallback();\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n   * is empty.\n   */\n  receive() external payable {\n    _fallback();\n  }\n\n  /**\n   * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n   * call, or as part of the Solidity `fallback` or `receive` functions.\n   *\n   * If overriden should call `super._beforeFallback()`.\n   */\n  function _beforeFallback() internal virtual {}\n}\n"
    },
    "contracts/external/openzeppelin/contracts/proxy/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"contracts/external/openzeppelin/contracts/proxy/IBeacon.sol\";\nimport \"contracts/external/openzeppelin/contracts/proxy/draft-IERC1822.sol\";\nimport \"contracts/external/openzeppelin/contracts/utils/Address.sol\";\nimport \"contracts/external/openzeppelin/contracts/utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n  // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n  bytes32 private constant _ROLLBACK_SLOT =\n    0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n  /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant _IMPLEMENTATION_SLOT =\n    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /**\n   * @dev Emitted when the implementation is upgraded.\n   */\n  event Upgraded(address indexed implementation);\n\n  /**\n   * @dev Returns the current implementation address.\n   */\n  function _getImplementation() internal view returns (address) {\n    return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 implementation slot.\n   */\n  function _setImplementation(address newImplementation) private {\n    require(\n      Address.isContract(newImplementation),\n      \"ERC1967: new implementation is not a contract\"\n    );\n    StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n  }\n\n  /**\n   * @dev Perform implementation upgrade\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /**\n   * @dev Perform implementation upgrade with additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCall(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) internal {\n    _upgradeTo(newImplementation);\n    if (data.length > 0 || forceCall) {\n      Address.functionDelegateCall(newImplementation, data);\n    }\n  }\n\n  /**\n   * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n   *\n   * Emits an {Upgraded} event.\n   */\n  function _upgradeToAndCallUUPS(\n    address newImplementation,\n    bytes memory data,\n    bool forceCall\n  ) internal {\n    // Upgrades from old implementations will perform a rollback test. This test requires the new\n    // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n    // this special case will break upgrade paths from old UUPS implementation to new ones.\n    if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n      _setImplementation(newImplementation);\n    } else {\n      try IERC1822Proxiable(newImplementation).proxiableUUID() returns (\n        bytes32 slot\n      ) {\n        require(\n          slot == _IMPLEMENTATION_SLOT,\n          \"ERC1967Upgrade: unsupported proxiableUUID\"\n        );\n      } catch {\n        revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n      }\n      _upgradeToAndCall(newImplementation, data, forceCall);\n    }\n  }\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant _ADMIN_SLOT =\n    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  /**\n   * @dev Emitted when the admin account has changed.\n   */\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  /**\n   * @dev Returns the current admin.\n   */\n  function _getAdmin() internal view returns (address) {\n    return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new address in the EIP1967 admin slot.\n   */\n  function _setAdmin(address newAdmin) private {\n    require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n    StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   *\n   * Emits an {AdminChanged} event.\n   */\n  function _changeAdmin(address newAdmin) internal {\n    emit AdminChanged(_getAdmin(), newAdmin);\n    _setAdmin(newAdmin);\n  }\n\n  /**\n   * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n   * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n   */\n  bytes32 internal constant _BEACON_SLOT =\n    0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n  /**\n   * @dev Emitted when the beacon is upgraded.\n   */\n  event BeaconUpgraded(address indexed beacon);\n\n  /**\n   * @dev Returns the current beacon.\n   */\n  function _getBeacon() internal view returns (address) {\n    return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n  }\n\n  /**\n   * @dev Stores a new beacon in the EIP1967 beacon slot.\n   */\n  function _setBeacon(address newBeacon) private {\n    require(\n      Address.isContract(newBeacon),\n      \"ERC1967: new beacon is not a contract\"\n    );\n    require(\n      Address.isContract(IBeacon(newBeacon).implementation()),\n      \"ERC1967: beacon implementation is not a contract\"\n    );\n    StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n  }\n\n  /**\n   * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n   * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n   *\n   * Emits a {BeaconUpgraded} event.\n   */\n  function _upgradeBeaconToAndCall(\n    address newBeacon,\n    bytes memory data,\n    bool forceCall\n  ) internal {\n    _setBeacon(newBeacon);\n    emit BeaconUpgraded(newBeacon);\n    if (data.length > 0 || forceCall) {\n      Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n    }\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts/proxy/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n  /**\n   * @dev Must return an address that can be used as a delegate call target.\n   *\n   * {BeaconProxy} will check that this address is a contract.\n   */\n  function implementation() external view returns (address);\n}\n"
    },
    "contracts/external/openzeppelin/contracts/proxy/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n  /**\n   * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n   * address.\n   *\n   * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n   * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n   * function revert if invoked through a proxy.\n   */\n  function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "contracts/external/openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n  struct AddressSlot {\n    address value;\n  }\n\n  struct BooleanSlot {\n    bool value;\n  }\n\n  struct Bytes32Slot {\n    bytes32 value;\n  }\n\n  struct Uint256Slot {\n    uint256 value;\n  }\n\n  /**\n   * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n   */\n  function getAddressSlot(bytes32 slot)\n    internal\n    pure\n    returns (AddressSlot storage r)\n  {\n    assembly {\n      r.slot := slot\n    }\n  }\n\n  /**\n   * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n   */\n  function getBooleanSlot(bytes32 slot)\n    internal\n    pure\n    returns (BooleanSlot storage r)\n  {\n    assembly {\n      r.slot := slot\n    }\n  }\n\n  /**\n   * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n   */\n  function getBytes32Slot(bytes32 slot)\n    internal\n    pure\n    returns (Bytes32Slot storage r)\n  {\n    assembly {\n      r.slot := slot\n    }\n  }\n\n  /**\n   * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n   */\n  function getUint256Slot(bytes32 slot)\n    internal\n    pure\n    returns (Uint256Slot storage r)\n  {\n    assembly {\n      r.slot := slot\n    }\n  }\n}\n"
    },
    "contracts/usdy/allowlist/AllowlistFactory.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\n// Proxy admin contract used in OZ upgrades plugin\nimport \"contracts/external/openzeppelin/contracts/proxy/ProxyAdmin.sol\";\nimport \"contracts/usdy/allowlist/AllowlistProxy.sol\";\nimport \"contracts/usdy/allowlist/AllowlistUpgradeable.sol\";\nimport \"contracts/interfaces/IMulticall.sol\";\n\n/**\n * @title AllowlistFactory\n * @author Ondo Finance\n * @notice This contract serves as a Factory for the upgradable AllowlistUpgradeable contract.\n *         Upon calling `deployAllowlist` the `guardian` address (set in constructor) will\n *         deploy the following:\n *         1) AllowlistUpgradeable - The implementation contract.\n *         2) ProxyAdmin - OZ ProxyAdmin contract, used to upgrade the proxy instance.\n *                         @notice Owner is set to `guardian` address.\n *         3) TransparentUpgradeableProxy - OZ, proxy contract. Admin is set to `address(proxyAdmin)`.\n *                                          `_logic' is set to `address(cash)`.\n *\n * @notice `guardian` address in constructor is a msig.\n */\ncontract AllowlistFactory is IMulticall {\n  bytes32 public constant DEFAULT_ADMIN_ROLE = bytes32(0);\n\n  address internal immutable guardian;\n  AllowlistUpgradeable public allowlistImplementation;\n  ProxyAdmin public allowlistProxyAdmin;\n  AllowlistProxy public allowlistProxy;\n\n  constructor(address _guardian) {\n    guardian = _guardian;\n  }\n\n  /**\n   * @dev This function will deploy an upgradable instance of AllowlistUpgradeable\n   *\n   * @param admin  The admin account for the AllowlistUpgradeable contract.\n   * @param setter The setter account for the AllowlistUpgradeable contract.\n   *\n   * @return address The address of the proxy contract.\n   * @return address The address of the proxyAdmin contract.\n   * @return address The address of the implementation contract.\n   *\n   */\n  function deployAllowlist(\n    address admin,\n    address setter\n  ) external onlyGuardian returns (address, address, address) {\n    allowlistImplementation = new AllowlistUpgradeable();\n\n    allowlistProxyAdmin = new ProxyAdmin();\n    allowlistProxy = new AllowlistProxy(\n      address(allowlistImplementation),\n      address(allowlistProxyAdmin),\n      \"\"\n    );\n    AllowlistUpgradeable allowlistProxied = AllowlistUpgradeable(\n      address(allowlistProxy)\n    );\n\n    allowlistProxied.initialize(admin, setter);\n\n    allowlistProxyAdmin.transferOwnership(guardian);\n    assert(allowlistProxyAdmin.owner() == guardian);\n    emit AllowlistDeployed(\n      address(allowlistProxied),\n      address(allowlistProxyAdmin),\n      address(allowlistImplementation)\n    );\n    return (\n      address(allowlistProxied),\n      address(allowlistProxyAdmin),\n      address(allowlistImplementation)\n    );\n  }\n\n  /**\n   * @notice Allows for arbitrary batched calls\n   *\n   * @dev All external calls made through this function will\n   *      msg.sender == contract address\n   *\n   * @param exCallData Struct consisting of\n   *       1) target - contract to call\n   *       2) data - data to call target with\n   *       3) value - eth value to call target with\n   */\n  function multiexcall(\n    ExCallData[] calldata exCallData\n  ) external payable override onlyGuardian returns (bytes[] memory results) {\n    results = new bytes[](exCallData.length);\n    for (uint256 i = 0; i < exCallData.length; ++i) {\n      (bool success, bytes memory ret) = address(exCallData[i].target).call{\n        value: exCallData[i].value\n      }(exCallData[i].data);\n      require(success, \"Call Failed\");\n      results[i] = ret;\n    }\n  }\n\n  /**\n   * @dev Event emitted when upgradable AllowlistUpgradeable is deployed\n   *\n   * @param proxy             The address for the proxy contract\n   * @param proxyAdmin        The address for the proxy admin contract\n   * @param implementation    The address for the implementation contract\n   */\n  event AllowlistDeployed(\n    address proxy,\n    address proxyAdmin,\n    address implementation\n  );\n\n  modifier onlyGuardian() {\n    require(\n      msg.sender == guardian,\n      \"AllowlistFactory: You are not the Guardian\"\n    );\n    _;\n  }\n}\n"
    },
    "contracts/usdy/allowlist/AllowlistProxy.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/external/openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\";\n\ncontract AllowlistProxy is TransparentUpgradeableProxy {\n  constructor(\n    address _logic,\n    address _admin,\n    bytes memory _data\n  ) TransparentUpgradeableProxy(_logic, _admin, _data) {}\n}\n"
    },
    "contracts/usdy/allowlist/AllowlistUpgradeable.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\nimport \"contracts/external/openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"contracts/interfaces/IAllowlist.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\n\n/**\n * @title AllowlistUpgradeable\n * @author Ondo Finance\n * @notice This contract manages the allowlist status for accounts.\n */\ncontract AllowlistUpgradeable is\n  Initializable,\n  AccessControlEnumerableUpgradeable,\n  IAllowlist\n{\n  /// @dev Role based access control roles\n  bytes32 public constant ALLOWLIST_ADMIN = keccak256(\"ALLOWLIST_ADMIN\");\n  bytes32 public constant ALLOWLIST_SETTER = keccak256(\"ALLOWLIST_SETTER\");\n\n  /// @dev {<EOA> : {<term index> : <is verified>}};\n  mapping(address => mapping(uint256 => bool)) public verifications;\n\n  string[] public terms;\n  uint256 public currentTermIndex = 0;\n  uint256[] public validIndexes;\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(address admin, address setter) public initializer {\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    _grantRole(ALLOWLIST_ADMIN, admin);\n    _grantRole(ALLOWLIST_SETTER, setter);\n  }\n\n  /**\n   * @notice Gets a list term indexes that are valid for a user to be on the\n   *         allowlist\n   */\n  function getValidTermIndexes()\n    external\n    view\n    override\n    returns (uint256[] memory)\n  {\n    return validIndexes;\n  }\n\n  /**\n   * @notice Returns the current terms string associated with the\n   *         `currentTermIndex`\n   */\n  function getCurrentTerm() external view override returns (string memory) {\n    return terms[currentTermIndex];\n  }\n\n  /**\n   * @notice Adds a term to the list of possible terms\n   *\n   * @param term Term to add\n   *\n   * @dev This function sets the current term index as the added term\n   * @dev The added term is not valid until it's added to validIndexes\n   */\n  function addTerm(\n    string calldata term\n  ) external override onlyRole(ALLOWLIST_ADMIN) {\n    terms.push(term);\n    setCurrentTermIndex(terms.length - 1);\n    emit TermAdded(keccak256(bytes(term)), terms.length - 1);\n  }\n\n  /**\n   * @notice Sets the current term index\n   *\n   * @param _currentTermIndex New current term index\n   *\n   * @dev The current term index is not a valid term until it's added to\n   *      validIndexes\n   * @dev This function will revert if the `_currentTermIndex` out of bounds\n   *      of the terms array\n   */\n  function setCurrentTermIndex(\n    uint256 _currentTermIndex\n  ) public override onlyRole(ALLOWLIST_ADMIN) {\n    if (_currentTermIndex >= terms.length) {\n      revert InvalidTermIndex();\n    }\n    uint256 oldIndex = currentTermIndex;\n    currentTermIndex = _currentTermIndex;\n    emit CurrentTermIndexSet(oldIndex, _currentTermIndex);\n  }\n\n  /**\n   * @notice Sets the list of valid term indexes\n   *\n   * @param _validIndexes List of new valid term indexes\n   *\n   * @dev Once the validIndexes are set, any user who has been verified to sign\n   *      a particular term will pass the `isAllowed` check\n   */\n  function setValidTermIndexes(\n    uint256[] calldata _validIndexes\n  ) external override onlyRole(ALLOWLIST_ADMIN) {\n    for (uint256 i; i < _validIndexes.length; ++i) {\n      if (_validIndexes[i] >= terms.length) {\n        revert InvalidTermIndex();\n      }\n    }\n    uint256[] memory oldIndexes = validIndexes;\n    validIndexes = _validIndexes;\n    emit ValidTermIndexesSet(oldIndexes, _validIndexes);\n  }\n\n  /**\n   * @notice Function that checks whether a user passes the allowlist check\n   *\n   * @param account Address of the account to check\n   *\n   * @dev Contracts are always allowed. Any entity that has signed a valid term\n   *      or added themselves to the allowslit for a valid term will pass the\n   *      check\n   */\n  function isAllowed(address account) external view override returns (bool) {\n    // Contracts are always allowed\n    if (AddressUpgradeable.isContract(account)) {\n      return true;\n    }\n\n    uint256 validIndexesLength = validIndexes.length;\n    for (uint256 i; i < validIndexesLength; ++i) {\n      if (verifications[account][validIndexes[i]]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @notice Function that allows a user to add themselves to the allowlist\n   *         for a given `termIndex`\n   *\n   * @param termIndex Term index for which the user is adding themselves to the\n   *                  allowlist\n   */\n  function addSelfToAllowlist(uint256 termIndex) external override {\n    if (verifications[msg.sender][termIndex]) {\n      revert AlreadyVerified();\n    }\n    _setAccountStatus(msg.sender, termIndex, true);\n    emit AccountAddedSelf(msg.sender, termIndex);\n  }\n\n  /**\n   * @notice Admin function to set an accounts status for a given term index\n   *\n   * @param account   Address of the account to set the status for\n   * @param termIndex Term index for which to update status for\n   * @param status    New status of the account\n   *\n   * @dev If a user's status has been set to false, a user can then set their\n   *      status back to true. This behavior is known. The allowlist should be\n   *      used in conjunction with a blocklist\n   */\n  function setAccountStatus(\n    address account,\n    uint256 termIndex,\n    bool status\n  ) external override onlyRole(ALLOWLIST_SETTER) {\n    _setAccountStatus(account, termIndex, status);\n    emit AccountStatusSetByAdmin(account, termIndex, status);\n  }\n\n  /**\n   * @notice Function that allows anyone to add a user to the allowlist with a\n   *         given off-chain signature\n   *\n   * @param termIndex Term index for which the user is adding themselves to the\n   *                  allowlist\n   * @param account   Address of the account to add to the allowlist\n   * @param v         v component of the signature\n   * @param r         r component of the signature\n   * @param s         s component of the signature\n   */\n  function addAccountToAllowlist(\n    uint256 termIndex,\n    address account,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external override {\n    if (verifications[account][termIndex]) {\n      revert AlreadyVerified();\n    }\n\n    if (v != 27 && v != 28) {\n      revert InvalidVSignature();\n    }\n\n    bytes32 hashedMessage = ECDSA.toEthSignedMessageHash(\n      bytes(terms[termIndex])\n    );\n    address signer = ECDSA.recover(hashedMessage, v, r, s);\n\n    if (signer != account) {\n      revert InvalidSigner();\n    }\n    _setAccountStatus(account, termIndex, true);\n    emit AccountAddedFromSignature(account, termIndex, v, r, s);\n  }\n\n  /**\n   * @notice Internal function to set the status of an account for a given term\n   *\n   * @param account   Address of the account to set the status for\n   * @param termIndex Term index for which to update status for\n   * @param status    New status of the account\n   */\n  function _setAccountStatus(\n    address account,\n    uint256 termIndex,\n    bool status\n  ) internal {\n    if (termIndex >= terms.length) {\n      revert InvalidTermIndex();\n    }\n    verifications[account][termIndex] = status;\n    emit AccountStatusSet(account, termIndex, status);\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "contracts/ommf/wrappedOMMF/wOMMF.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/ERC20PresetMinterPauserUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"contracts/kyc/KYCRegistryClientUpgradeable.sol\";\nimport \"contracts/interfaces/IOmmf.sol\";\n\n/// @notice This RWA token has enabled transfers only for addresses with the TRANSFER_ROLE.\ncontract WOMMF is\n  ERC20PresetMinterPauserUpgradeable,\n  KYCRegistryClientUpgradeable\n{\n  IOMMF public ommf;\n  bytes32 public constant BURNER_ROLE = keccak256(\"BURN_ROLE\");\n  bytes32 public constant KYC_CONFIGURER_ROLE =\n    keccak256(\"KYC_CONFIGURER_ROLE\");\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Function to initialize the proxy wOMMF contract\n   *\n   * @param name        The name of this token\n   * @param symbol      The symbol for this token\n   * @param ommfAddress The address of the underlying token to wrap\n   */\n  function initialize(\n    address admin,\n    string memory name,\n    string memory symbol,\n    address ommfAddress,\n    address kycRegistry,\n    uint256 requirementGroup\n  ) public initializer {\n    __ERC20PresetMinterPauser_init(name, symbol);\n    __KYCRegistryClientInitializable_init(kycRegistry, requirementGroup);\n    ommf = IOMMF(ommfAddress);\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    _grantRole(PAUSER_ROLE, admin);\n    _grantRole(BURNER_ROLE, admin);\n    _grantRole(KYC_CONFIGURER_ROLE, admin);\n  }\n\n  /**\n   * @notice Function called by users to wrap their wOMMF tokens\n   *\n   * @param _ommfAmount The amount of OMMF Tokens to wrap\n   *\n   * @dev KYC checks implicit in OMMF Transfer\n   */\n  function wrap(uint256 _ommfAmount) external {\n    require(_ommfAmount > 0, \"wOMMF: can't wrap zero OMMF tokens\");\n    uint256 shares = ommf.getSharesByPooledCash(_ommfAmount);\n    _mint(msg.sender, shares);\n    ommf.transferFrom(msg.sender, address(this), _ommfAmount);\n  }\n\n  /**\n   * @notice Function called by users to unwrap their wOMMF tokens\n   *\n   * @param _wOMMFAmount The amount of wOMMF to unwrap\n   *\n   * @dev KYC checks implicit in OMMF Transfer\n   */\n  function unwrap(uint256 _wOMMFAmount) external {\n    require(_wOMMFAmount > 0, \"wOMMF: can't unwrap zero wOMMF tokens\");\n    uint256 ommfAmount = ommf.getPooledCashByShares(_wOMMFAmount);\n    _burn(msg.sender, _wOMMFAmount);\n    ommf.transfer(msg.sender, ommfAmount);\n  }\n\n  /**\n   * @notice Function to get the amount of wOMMF tokens given an\n   *         amount of OMMF tokens\n   *\n   * @param _OMMFAmount The amount of OMMF tokens to convert to\n   *                    wOMMF\n   */\n  function getwOMMFByOMMF(uint256 _OMMFAmount) external view returns (uint256) {\n    return ommf.getSharesByPooledCash(_OMMFAmount);\n  }\n\n  /**\n   * @notice Functions to get the amount of OMMF tokens given an\n   *         amount of wOMMF tokens\n   *\n   * @param _wOMMFAmount The amount of wOMMF tokens to convert to\n   *                     OMMF\n   */\n  function getOMMFbywOMMF(\n    uint256 _wOMMFAmount\n  ) external view returns (uint256) {\n    return ommf.getPooledCashByShares(_wOMMFAmount);\n  }\n\n  /**\n   * @notice Returns the amount of OMMF tokens redeemable for a\n   *         single token on wOMMF\n   */\n  function OMMFPerToken() external view returns (uint256) {\n    return ommf.getPooledCashByShares(1e18);\n  }\n\n  /**\n   * @notice Returns the amount of wOMMF tokens redeemable for a\n   *         single token of OMMF\n   */\n  function tokensPerOMMF() external view returns (uint256) {\n    return ommf.getSharesByPooledCash(1e18);\n  }\n\n  /**\n   * @notice Admin function to burn wOMMF tokens from a given address\n   *\n   * @param account The account to burn the tokens from\n   * @param amount  The amount of tokens to burn\n   *\n   * @dev Function will withdraw the OMMF tokens corresponding to the\n   *      wOMMF tokens burned to the `account`\n   * @dev Function will send underlying OMMF to the `BURNER_ROLE` account\n   *      that initiated the admin burn\n   */\n  function adminBurn(\n    address account,\n    uint256 amount\n  ) public onlyRole(BURNER_ROLE) {\n    _burn(account, amount);\n    uint256 ommfAmount = ommf.getPooledCashByShares(amount);\n    ommf.transfer(msg.sender, ommfAmount);\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   *      minting and burning.\n   *\n   * @param from   The source of tokens being transferred\n   * @param to     The destination for tokens being transferred\n   * @param amount The amount of tokens being transferred\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual override {\n    super._beforeTokenTransfer(from, to, amount);\n    if (from != _msgSender() && to != _msgSender()) {\n      require(\n        _getKYCStatus(_msgSender()),\n        \"wOMMF: must be KYC'd to initiate transfer\"\n      );\n    }\n    if (from != address(0)) {\n      require(\n        _getKYCStatus(from),\n        \"wOMMF: `from` address must be KYC'd to send tokens\"\n      );\n    }\n    if (to != address(0)) {\n      require(_getKYCStatus(to), \"wOMMF: `to` address must be KYC'd\");\n    }\n  }\n\n  function setKYCRequirementGroup(\n    uint256 group\n  ) external override onlyRole(KYC_CONFIGURER_ROLE) {\n    _setKYCRequirementGroup(group);\n  }\n\n  function setKYCRegistry(\n    address registry\n  ) external override onlyRole(KYC_CONFIGURER_ROLE) {\n    _setKYCRegistry(registry);\n  }\n}\n"
    },
    "contracts/kyc/KYCRegistryClientUpgradeable.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/kyc/IKYCRegistry.sol\";\nimport \"contracts/kyc/IKYCRegistryClient.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\n/**\n * @title KYCRegistryClientInitializable\n * @author Ondo Finance\n * @notice This abstract contract manages state required for clients\n *         of the KYC registry.\n */\nabstract contract KYCRegistryClientUpgradeable is\n  Initializable,\n  IKYCRegistryClient\n{\n  // KYC Registry address\n  IKYCRegistry public override kycRegistry;\n  // KYC requirement group\n  uint256 public override kycRequirementGroup;\n\n  /**\n   * @notice Initialize the contract by setting registry variable\n   *\n   * @param _kycRegistry         Address of the registry contract\n   * @param _kycRequirementGroup KYC requirement group associated with this\n   *                             client\n   *\n   * @dev Function should be called by the inheriting contract on\n   *      initialization\n   */\n  function __KYCRegistryClientInitializable_init(\n    address _kycRegistry,\n    uint256 _kycRequirementGroup\n  ) internal onlyInitializing {\n    __KYCRegistryClientInitializable_init_unchained(\n      _kycRegistry,\n      _kycRequirementGroup\n    );\n  }\n\n  /**\n   * @dev Internal function to future-proof parent linearization. Matches OZ\n   *      upgradeable suggestions\n   */\n  function __KYCRegistryClientInitializable_init_unchained(\n    address _kycRegistry,\n    uint256 _kycRequirementGroup\n  ) internal onlyInitializing {\n    _setKYCRegistry(_kycRegistry);\n    _setKYCRequirementGroup(_kycRequirementGroup);\n  }\n\n  /**\n   * @notice Sets the KYC registry address for this client\n   *\n   * @param _kycRegistry The new KYC registry address\n   */\n  function _setKYCRegistry(address _kycRegistry) internal {\n    if (_kycRegistry == address(0)) {\n      revert RegistryZeroAddress();\n    }\n    address oldKYCRegistry = address(kycRegistry);\n    kycRegistry = IKYCRegistry(_kycRegistry);\n    emit KYCRegistrySet(oldKYCRegistry, _kycRegistry);\n  }\n\n  /**\n   * @notice Sets the KYC registry requirement group for this\n   *         client to check kyc status for\n   *\n   * @param _kycRequirementGroup The new KYC group\n   */\n  function _setKYCRequirementGroup(uint256 _kycRequirementGroup) internal {\n    uint256 oldKYCLevel = kycRequirementGroup;\n    kycRequirementGroup = _kycRequirementGroup;\n    emit KYCRequirementGroupSet(oldKYCLevel, _kycRequirementGroup);\n  }\n\n  /**\n   * @notice Checks whether an address has been KYC'd\n   *\n   * @param account The address to check\n   */\n  function _getKYCStatus(address account) internal view returns (bool) {\n    return kycRegistry.getKYCStatus(kycRequirementGroup, account);\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/interfaces/IOmmf.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\n\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\n\npragma solidity 0.8.16; // latest available for using OZ\n\ninterface IOMMF is IERC20 {\n  function getPooledCashByShares(uint256) external view returns (uint256);\n\n  function getSharesByPooledCash(uint256) external view returns (uint256);\n\n  function submit(address _referral) external payable returns (uint256);\n}\n"
    },
    "contracts/ommf/wrappedOMMF/wOMMF_factory.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\n// Proxy admin contract used in OZ upgrades plugin\nimport \"contracts/external/openzeppelin/contracts/proxy/ProxyAdmin.sol\";\nimport \"contracts/Proxy.sol\";\nimport \"contracts/ommf/wrappedOMMF/wOMMF.sol\";\nimport \"contracts/interfaces/IMulticall.sol\";\n\n/**\n * @title wommfFactory\n * @author Ondo Finance\n * @notice This contract serves as a Factory for the upgradable wOMMF token contract.\n *         Upon calling `deployWOMMF` the `guardian` address (set in constructor) will\n *         deploy the following:\n *         1) wOMMF - The implementation contract, ERC20 contract with the initializer disabled\n *         2) ProxyAdmin - OZ ProxyAdmin contract, used to upgrade the proxy instance.\n *                         @notice Owner is set to `guardian` address.\n *         3) TransparentUpgradeableProxy - OZ, proxy contract. Admin is set to `address(proxyAdmin)`.\n *                                          `_logic' is set to `address(rwa)`.\n *\n *         Following the above mentioned deployment, the address of the RWAFactory contract will:\n *         i) Transfer ownership of the ProxyAdmin to that of the `guardian` address.\n *         ii) Emit an event detailing the addresses on the upgradable contract array.\n *\n * @notice `guardian` address in constructor is a msig.\n */\ncontract WOMMFFactory is IMulticall {\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n  bytes32 public constant DEFAULT_ADMIN_ROLE = bytes32(0);\n\n  address internal immutable guardian;\n  WOMMF public wommfImplementation;\n  ProxyAdmin public wommfProxyAdmin;\n  TokenProxy public wommfProxy;\n\n  constructor(address _guardian) {\n    guardian = _guardian;\n  }\n\n  /**\n   * @dev This function will deploy an upgradable instance of RWA\n   *\n   * @param name             The name of the token we want to deploy.\n   * @param ticker           The ticker for the token we want to deploy.\n   * @param ommfAddress      The address of the OMMF token to wrap\n   * @param registry         The address of the KYC Registry\n   * @param requirementGroup The KYC requirement group for this token\n   *\n   * @return address The address of the proxy contract.\n   * @return address The address of the proxyAdmin contract.\n   * @return address The address of the implementation contract.\n   *\n   * @notice 1) Will automatically revoke all deployer roles granted to\n   *            address(this).\n   *         2) Will grant DEFAULT_ADMIN & PAUSER_ROLE(S) to `guardian`\n   *            address specified in constructor.\n   *         3) Will transfer ownership of the proxyAdmin to guardian\n   *            address.\n   *\n   */\n  function deployWOMMF(\n    string calldata name,\n    string calldata ticker,\n    address ommfAddress,\n    address registry,\n    uint256 requirementGroup\n  ) external onlyGuardian returns (address, address, address) {\n    wommfImplementation = new WOMMF();\n    wommfProxyAdmin = new ProxyAdmin();\n    wommfProxy = new TokenProxy(\n      address(wommfImplementation),\n      address(wommfProxyAdmin),\n      \"\"\n    );\n    WOMMF wOMMFProxied = WOMMF(address(wommfProxy));\n    wOMMFProxied.initialize(\n      guardian,\n      name,\n      ticker,\n      ommfAddress,\n      registry,\n      requirementGroup\n    );\n    wOMMFProxied.revokeRole(MINTER_ROLE, address(this));\n    wOMMFProxied.revokeRole(PAUSER_ROLE, address(this));\n    wOMMFProxied.revokeRole(DEFAULT_ADMIN_ROLE, address(this));\n\n    wommfProxyAdmin.transferOwnership(guardian);\n    assert(wommfProxyAdmin.owner() == guardian);\n    emit WOMMFDeployed(\n      address(wOMMFProxied),\n      address(wommfProxyAdmin),\n      address(wommfImplementation),\n      name,\n      ticker\n    );\n    return (\n      address(wOMMFProxied),\n      address(wommfProxyAdmin),\n      address(wommfImplementation)\n    );\n  }\n\n  /**\n   * @notice Allows for arbitrary batched calls\n   *\n   * @dev All external calls made through this function will\n   *      msg.sender == contract address\n   *\n   * @param exCallData Struct consisting of\n   *       1) target - contract to call\n   *       2) data - data to call target with\n   *       3) value - eth value to call target with\n   */\n  function multiexcall(\n    ExCallData[] calldata exCallData\n  ) external payable override onlyGuardian returns (bytes[] memory results) {\n    results = new bytes[](exCallData.length);\n    for (uint256 i = 0; i < exCallData.length; ++i) {\n      (bool success, bytes memory ret) = address(exCallData[i].target).call{\n        value: exCallData[i].value\n      }(exCallData[i].data);\n      require(success, \"Call Failed\");\n      results[i] = ret;\n    }\n  }\n\n  /**\n   * @dev Event emitted when upgradable RWA token is deployed\n   *\n   * @param proxy             The address for the proxy contract\n   * @param proxyAdmin        The address for the proxy admin contract\n   * @param implementation    The address for the implementation contract\n   */\n  event WOMMFDeployed(\n    address proxy,\n    address proxyAdmin,\n    address implementation,\n    string name,\n    string ticker\n  );\n\n  modifier onlyGuardian() {\n    require(msg.sender == guardian, \"WOMMFFactory: You are not the Guardian\");\n    _;\n  }\n}\n"
    },
    "contracts/ommf/ommf_token/ommf_factory.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\n// Proxy admin contract used in OZ upgrades plugin\nimport \"contracts/external/openzeppelin/contracts/proxy/ProxyAdmin.sol\";\nimport \"contracts/Proxy.sol\";\nimport \"contracts/ommf/ommf_token/ommf.sol\";\nimport \"contracts/interfaces/IMulticall.sol\";\n\n/**\n * @title ommfFactory\n * @author Ondo Finance\n * @notice This contract serves as a Factory for the upgradable OMMF token contract.\n *         Upon calling `deployOMMF` the `guardian` address (set in constructor) will\n *         deploy the following:\n *         1) OMMF - The implementation contract, ERC20 contract with the initializer disabled\n *         2) ProxyAdmin - OZ ProxyAdmin contract, used to upgrade the proxy instance.\n *                         @notice Owner is set to `guardian` address.\n *         3) TransparentUpgradeableProxy - OZ, proxy contract. Admin is set to `address(proxyAdmin)`.\n *                                          `_logic' is set to `address(OMMF)`.\n *\n *         Following the above mentioned deployment, the address of the OMMFFactory contract will:\n *         i) Grant the `DEFAULT_ADMIN_ROLE` & PAUSER_ROLE to the `guardian` address\n *         ii) Revoke the `MINTER_ROLE`, `PAUSER_ROLE` & `DEFAULT_ADMIN_ROLE` from address(this).\n *         iii) Transfer ownership of the ProxyAdmin to that of the `guardian` address.\n *\n * @notice `guardian` address in constructor is a msig.\n */\ncontract OMMFFactory is IMulticall {\n  address internal immutable guardian;\n  OMMF public ommfImplementation;\n  ProxyAdmin public ommfProxyAdmin;\n  TokenProxy public ommfProxy;\n\n  constructor(address _guardian) {\n    guardian = _guardian;\n  }\n\n  /**\n   * @dev This function will deploy an upgradable instance of OMMF\n   *\n   * @param registry         The address of the KYC Registry\n   * @param requirementGroup The Requirement group of the Registry\n   *\n   * @return address The address of the proxy contract.\n   * @return address The address of the proxyAdmin contract.\n   * @return address The address of the implementation contract.\n   *\n   * @notice 1) Will automatically revoke all deployer roles granted to\n   *            address(this).\n   *         2) Will grant DEFAULT_ADMIN & PAUSER_ROLE(S) to `guardian`\n   *            address specified in constructor.\n   *         3) Will transfer ownership of the proxyAdmin to guardian\n   *            address.\n   *\n   */\n  function deployOMMF(\n    address registry,\n    uint256 requirementGroup\n  ) external onlyGuardian returns (address, address, address) {\n    ommfImplementation = new OMMF();\n    ommfProxyAdmin = new ProxyAdmin();\n    ommfProxy = new TokenProxy(\n      address(ommfImplementation),\n      address(ommfProxyAdmin),\n      \"\"\n    );\n    OMMF ommfProxied = OMMF(address(ommfProxy));\n    ommfProxied.initialize(guardian, registry, requirementGroup);\n\n    ommfProxyAdmin.transferOwnership(guardian);\n    assert(ommfProxyAdmin.owner() == guardian);\n    emit OMMFDeployed(\n      address(ommfProxy),\n      address(ommfProxyAdmin),\n      address(ommfImplementation),\n      \"Ondo Money Market Fund Token\",\n      \"OMMF\"\n    );\n    return (\n      address(ommfProxy),\n      address(ommfProxyAdmin),\n      address(ommfImplementation)\n    );\n  }\n\n  /**\n   * @notice Allows for arbitrary batched calls\n   *\n   * @dev All external calls made through this function will\n   *      msg.sender == contract address\n   *\n   * @param exCallData Struct consisting of\n   *       1) target - contract to call\n   *       2) data - data to call target with\n   *       3) value - eth value to call target with\n   */\n  function multiexcall(\n    ExCallData[] calldata exCallData\n  ) external payable override onlyGuardian returns (bytes[] memory results) {\n    results = new bytes[](exCallData.length);\n    for (uint256 i = 0; i < exCallData.length; ++i) {\n      (bool success, bytes memory ret) = address(exCallData[i].target).call{\n        value: exCallData[i].value\n      }(exCallData[i].data);\n      require(success, \"Call Failed\");\n      results[i] = ret;\n    }\n  }\n\n  /**\n   * @dev Event emitted when upgradable OMMF is deployed\n   *\n   * @param proxy             The address for the proxy contract\n   * @param proxyAdmin        The address for the proxy admin contract\n   * @param implementation    The address for the implementation contract\n   */\n  event OMMFDeployed(\n    address proxy,\n    address proxyAdmin,\n    address implementation,\n    string name,\n    string ticker\n  );\n\n  modifier onlyGuardian() {\n    require(msg.sender == guardian, \"ommfFactory: You are not the Guardian\");\n    _;\n  }\n}\n"
    },
    "contracts/ommf/ommf_token/ommf.sol": {
      "content": "pragma solidity 0.8.16;\n\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC20/IERC20MetadataUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"contracts/kyc/KYCRegistryClientUpgradeable.sol\";\n\n/**\n * @title Interest-bearing ERC20-like token for OMMF.\n *\n * OMMF balances are dynamic and represent the holder's share in the total amount\n * of Cash controlled by the protocol. Account shares aren't normalized, so the\n * contract also stores the sum of all shares to calculate each account's token balance\n * which equals to:\n *\n *   shares[account] * _getTotalPooledCash() / _getTotalShares()\n *\n * For example, assume that we have:\n *\n *   _getTotalPooledCash() -> 10 USDC underlying OMMF\n *   sharesOf(user1) -> 100\n *   sharesOf(user2) -> 400\n *\n * Therefore:\n *\n *   balanceOf(user1) -> 2 tokens which corresponds 2 OMMF\n *   balanceOf(user2) -> 8 tokens which corresponds 8 OMMF\n *\n * Since balances of all token holders change when the amount of total pooled Cash\n * changes, this token cannot fully implement ERC20 standard: it only emits `Transfer`\n * events upon explicit transfer between holders. In contrast, when total amount of\n * pooled Cash increases, no `Transfer` events are generated: doing so would require\n * emitting an event for each token holder and thus running an unbounded loop.\n *\n */\n\ncontract OMMF is\n  Initializable,\n  ContextUpgradeable,\n  PausableUpgradeable,\n  AccessControlEnumerableUpgradeable,\n  KYCRegistryClientUpgradeable,\n  IERC20Upgradeable,\n  IERC20MetadataUpgradeable\n{\n  /**\n   * @dev OMMF balances are dynamic and are calculated based on the accounts' shares\n   * and the total amount of Cash controlled by the protocol. Account shares aren't\n   * normalized, so the contract also stores the sum of all shares to calculate\n   * each account's token balance which equals to:\n   *\n   *   shares[account] * _getTotalPooledCash() / _getTotalShares()\n   */\n  mapping(address => uint256) private shares;\n\n  /// @dev Allowances are nominated in tokens, not token shares.\n  mapping(address => mapping(address => uint256)) private allowances;\n\n  // Total shares in existence\n  uint256 private totalShares;\n\n  // Total cash in fund\n  uint256 public depositedCash;\n\n  // Address of the oracle that updates `depositedCash`\n  address public oracle;\n\n  /// @dev Role based access control roles\n  bytes32 public constant OMMF_MANAGER_ROLE = keccak256(\"ADMIN_ROLE\");\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n  bytes32 public constant BURNER_ROLE = keccak256(\"BURN_ROLE\");\n  bytes32 public constant KYC_CONFIGURER_ROLE =\n    keccak256(\"KYC_CONFIGURER_ROLE\");\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(\n    address admin,\n    address kycRegistry,\n    uint256 requirementGroup\n  ) public virtual initializer {\n    __OMMF_init(admin, kycRegistry, requirementGroup);\n  }\n\n  function __OMMF_init(\n    address admin,\n    address kycRegistry,\n    uint256 requirementGroup\n  ) internal onlyInitializing {\n    __Pausable_init_unchained();\n    __KYCRegistryClientInitializable_init_unchained(\n      kycRegistry,\n      requirementGroup\n    );\n    __OMMF_init_unchained(admin);\n  }\n\n  function __OMMF_init_unchained(address admin) internal onlyInitializing {\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    _grantRole(OMMF_MANAGER_ROLE, admin);\n    _grantRole(PAUSER_ROLE, admin);\n    _grantRole(MINTER_ROLE, admin);\n    _grantRole(BURNER_ROLE, admin);\n    _grantRole(KYC_CONFIGURER_ROLE, admin);\n  }\n\n  /**\n   * @notice An executed shares transfer from `sender` to `recipient`.\n   *\n   * @dev emitted in pair with an ERC20-defined `Transfer` event.\n   */\n  event TransferShares(\n    address indexed from,\n    address indexed to,\n    uint256 sharesValue\n  );\n\n  /**\n   * @notice An executed `burnShares` request\n   *\n   * @dev Reports simultaneously burnt shares amount\n   * and corresponding OMMF amount.\n   * The shares amount is calculated twice: before and after the burning incurred rebase.\n   *\n   * @param account holder of the burnt shares\n   * @param preRebaseTokenAmount amount of OMMF the burnt shares corresponded to before the burn\n   * @param postRebaseTokenAmount amount of OMMF the burnt shares corresponded to after the burn\n   * @param sharesAmount amount of burnt shares\n   */\n  event SharesBurnt(\n    address indexed account,\n    uint256 preRebaseTokenAmount,\n    uint256 postRebaseTokenAmount,\n    uint256 sharesAmount\n  );\n\n  /**\n   * @notice An executed `burnShares` request\n   *\n   * @dev Reports simultaneously burnt shares amount\n   * and corresponding OMMF amount.\n   * The OMMF amount is calculated twice: before and after the burning incurred rebase.\n   *\n   * @param account holder of the burnt shares\n   * @param tokensBurnt amount of burnt tokens\n   */\n  event TokensBurnt(address indexed account, uint256 tokensBurnt);\n\n  /**\n   * @return the name of the token.\n   */\n  function name() public pure returns (string memory) {\n    return \"Ondo Money Market Fund Token\";\n  }\n\n  /**\n   * @return the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public pure returns (string memory) {\n    return \"OMMF\";\n  }\n\n  /**\n   * @return the number of decimals for getting user representation of a token amount.\n   */\n  function decimals() public pure returns (uint8) {\n    return 18;\n  }\n\n  /**\n   * @return the amount of tokens in existence.\n   *\n   * @dev Always equals to `_getTotalPooledCash()` since token amount\n   * is pegged to the total amount of OMMF controlled by the protocol.\n   */\n  function totalSupply() public view returns (uint256) {\n    return _getTotalPooledCash();\n  }\n\n  /**\n   * @return the entire amount of OMMF controlled by the protocol.\n   *\n   * @dev The sum of all OMMF balances in the protocol, equals to the total supply of OMMF.\n   */\n  function getTotalPooledCash() public view returns (uint256) {\n    return _getTotalPooledCash();\n  }\n\n  /**\n   * @return the amount of tokens owned by the `_account`.\n   *\n   * @dev Balances are dynamic and equal the `_account`'s share in the amount of the\n   * total Cash controlled by the protocol. See `sharesOf`.\n   */\n  function balanceOf(address _account) public view returns (uint256) {\n    return getPooledCashByShares(_sharesOf(_account));\n  }\n\n  /**\n   * @notice Moves `_amount` tokens from the caller's account to the `_recipient` account.\n   *\n   * @return a boolean value indicating whether the operation succeeded.\n   * Emits a `Transfer` event.\n   * Emits a `TransferShares` event.\n   *\n   * Requirements:\n   *\n   * - `_recipient` cannot be the zero address.\n   * - the caller must have a balance of at least `_amount`.\n   * - the contract must not be paused.\n   *\n   * @dev The `_amount` argument is the amount of tokens, not shares.\n   */\n  function transfer(address _recipient, uint256 _amount) public returns (bool) {\n    _transfer(msg.sender, _recipient, _amount);\n    return true;\n  }\n\n  /**\n   * @return the remaining number of tokens that `_spender` is allowed to spend\n   * on behalf of `_owner` through `transferFrom`. This is zero by default.\n   *\n   * @dev This value changes when `approve` or `transferFrom` is called.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n  ) public view returns (uint256) {\n    return allowances[_owner][_spender];\n  }\n\n  /**\n   * @notice Sets `_amount` as the allowance of `_spender` over the caller's tokens.\n   *\n   * @return a boolean value indicating whether the operation succeeded.\n   * Emits an `Approval` event.\n   *\n   * Requirements:\n   *\n   * - `_spender` cannot be the zero address.\n   * - the contract must not be paused.\n   *\n   * @dev The `_amount` argument is the amount of tokens, not shares.\n   */\n  function approve(address _spender, uint256 _amount) public returns (bool) {\n    _approve(msg.sender, _spender, _amount);\n    return true;\n  }\n\n  /**\n   * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n   * allowance mechanism. `_amount` is then deducted from the caller's\n   * allowance.\n   *\n   * @return a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a `Transfer` event.\n   * Emits a `TransferShares` event.\n   * Emits an `Approval` event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `_sender` and `_recipient` cannot be the zero addresses.\n   * - `_sender` must have a balance of at least `_amount`.\n   * - the caller must have allowance for `_sender`'s tokens of at least `_amount`.\n   * - the contract must not be paused.\n   *\n   * @dev The `_amount` argument is the amount of tokens, not shares.\n   */\n  function transferFrom(\n    address _sender,\n    address _recipient,\n    uint256 _amount\n  ) public returns (bool) {\n    uint256 currentAllowance = allowances[_sender][msg.sender];\n    require(currentAllowance >= _amount, \"TRANSFER_AMOUNT_EXCEEDS_ALLOWANCE\");\n\n    _transfer(_sender, _recipient, _amount);\n    _approve(_sender, msg.sender, currentAllowance - _amount);\n    return true;\n  }\n\n  /**\n   * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n   *\n   * This is an alternative to `approve` that can be used as a mitigation for\n   * problems described in:\n   * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\n   * Emits an `Approval` event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `_spender` cannot be the the zero address.\n   * - the contract must not be paused.\n   */\n  function increaseAllowance(\n    address _spender,\n    uint256 _addedValue\n  ) public returns (bool) {\n    _approve(\n      msg.sender,\n      _spender,\n      allowances[msg.sender][_spender] + _addedValue\n    );\n    return true;\n  }\n\n  /**\n   * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n   *\n   * This is an alternative to `approve` that can be used as a mitigation for\n   * problems described in:\n   * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\n   * Emits an `Approval` event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `_spender` cannot be the zero address.\n   * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n   * - the contract must not be paused.\n   */\n  function decreaseAllowance(\n    address _spender,\n    uint256 _subtractedValue\n  ) public returns (bool) {\n    uint256 currentAllowance = allowances[msg.sender][_spender];\n    require(\n      currentAllowance >= _subtractedValue,\n      \"DECREASED_ALLOWANCE_BELOW_ZERO\"\n    );\n    _approve(msg.sender, _spender, currentAllowance - _subtractedValue);\n    return true;\n  }\n\n  /**\n   * @return the total amount of shares in existence.\n   *\n   * @dev The sum of all accounts' shares can be an arbitrary number, therefore\n   * it is necessary to store it in order to calculate each account's relative share.\n   */\n  function getTotalShares() public view returns (uint256) {\n    return totalShares;\n  }\n\n  /**\n   * @return the amount of shares owned by `_account`.\n   */\n  function sharesOf(address _account) public view returns (uint256) {\n    return _sharesOf(_account);\n  }\n\n  /**\n   * @return the amount of shares that corresponds to `cashAmount` protocol-controlled Cash.\n   */\n  function getSharesByPooledCash(\n    uint256 _cashAmount\n  ) public view returns (uint256) {\n    uint256 totalPooledCash = _getTotalPooledCash();\n    if (totalPooledCash == 0) {\n      return 0;\n    } else {\n      return (_cashAmount * totalShares) / totalPooledCash;\n    }\n  }\n\n  /**\n   * @return the amount of Cash that corresponds to `_sharesAmount` token shares.\n   */\n  function getPooledCashByShares(\n    uint256 _sharesAmount\n  ) public view returns (uint256) {\n    if (totalShares == 0) {\n      return 0;\n    } else {\n      return (_sharesAmount * _getTotalPooledCash()) / totalShares;\n    }\n  }\n\n  /**\n   * @notice Moves `_sharesAmount` token shares from the caller's account to the `_recipient` account.\n   *\n   * @return amount of transferred tokens.\n   * Emits a `TransferShares` event.\n   * Emits a `Transfer` event.\n   *\n   * Requirements:\n   *\n   * - `_recipient` cannot be the zero address.\n   * - the caller must have at least `_sharesAmount` shares.\n   * - the contract must not be paused.\n   *\n   * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n   */\n  function transferShares(\n    address _recipient,\n    uint256 _sharesAmount\n  ) public returns (uint256) {\n    _transferShares(msg.sender, _recipient, _sharesAmount);\n    emit TransferShares(msg.sender, _recipient, _sharesAmount);\n    uint256 tokensAmount = getPooledCashByShares(_sharesAmount);\n    emit Transfer(msg.sender, _recipient, tokensAmount);\n    return tokensAmount;\n  }\n\n  /**\n   * @notice Gets the total amount of Cash controlled by the system\n   * @return the total amount (in wei) of Cash controlled by the protocol.\n   * @dev This is used for calculating tokens from shares and vice versa.\n   */\n  function _getTotalPooledCash() internal view returns (uint256) {\n    return depositedCash;\n  }\n\n  /**\n   * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n   * Emits a `Transfer` event.\n   * Emits a `TransferShares` event.\n   */\n  function _transfer(\n    address _sender,\n    address _recipient,\n    uint256 _amount\n  ) internal {\n    uint256 _sharesToTransfer = getSharesByPooledCash(_amount);\n    _transferShares(_sender, _recipient, _sharesToTransfer);\n    emit Transfer(_sender, _recipient, _amount);\n    emit TransferShares(_sender, _recipient, _sharesToTransfer);\n  }\n\n  /**\n   * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n   *\n   * Emits an `Approval` event.\n   *\n   * Requirements:\n   *\n   * - `_owner` cannot be the zero address.\n   * - `_spender` cannot be the zero address.\n   * - the contract must not be paused.\n   */\n  function _approve(\n    address _owner,\n    address _spender,\n    uint256 _amount\n  ) internal whenNotPaused {\n    require(_owner != address(0), \"APPROVE_FROM_ZERO_ADDRESS\");\n    require(_spender != address(0), \"APPROVE_TO_ZERO_ADDRESS\");\n\n    allowances[_owner][_spender] = _amount;\n    emit Approval(_owner, _spender, _amount);\n  }\n\n  /**\n   * @return the amount of shares owned by `_account`.\n   */\n  function _sharesOf(address _account) internal view returns (uint256) {\n    return shares[_account];\n  }\n\n  /**\n   * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n   *\n   * Requirements:\n   *\n   * - `_sender` cannot be the zero address.\n   * - `_recipient` cannot be the zero address.\n   * - `_sender` must hold at least `_sharesAmount` shares.\n   * - the contract must not be paused.\n   */\n  function _transferShares(\n    address _sender,\n    address _recipient,\n    uint256 _sharesAmount\n  ) internal whenNotPaused {\n    require(_sender != address(0), \"TRANSFER_FROM_THE_ZERO_ADDRESS\");\n    require(_recipient != address(0), \"TRANSFER_TO_THE_ZERO_ADDRESS\");\n\n    _beforeTokenTransfer(_sender, _recipient, _sharesAmount);\n\n    uint256 currentSenderShares = shares[_sender];\n    require(\n      _sharesAmount <= currentSenderShares,\n      \"TRANSFER_AMOUNT_EXCEEDS_BALANCE\"\n    );\n\n    shares[_sender] = currentSenderShares - _sharesAmount;\n    shares[_recipient] = shares[_recipient] + _sharesAmount;\n  }\n\n  /**\n   * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n   * @dev This doesn't increase the token total supply.\n   *\n   * Requirements:\n   *\n   * - `_recipient` cannot be the zero address.\n   * - the contract must not be paused.\n   */\n  function _mintShares(\n    address _recipient,\n    uint256 _sharesAmount\n  ) internal whenNotPaused returns (uint256) {\n    require(_recipient != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");\n\n    _beforeTokenTransfer(address(0), _recipient, _sharesAmount);\n\n    totalShares += _sharesAmount;\n\n    shares[_recipient] = shares[_recipient] + _sharesAmount;\n\n    return totalShares;\n\n    // Notice: we're not emitting a Transfer event from the zero address here since shares mint\n    // works by taking the amount of tokens corresponding to the minted shares from all other\n    // token holders, proportionally to their share. The total supply of the token doesn't change\n    // as the result. This is equivalent to performing a send from each other token holder's\n    // address to `address`, but we cannot reflect this as it would require sending an unbounded\n    // number of events.\n  }\n\n  /**\n   * @notice Destroys `_sharesAmount` shares from `_account`'s holdings, decreasing the total amount of shares.\n   * @dev This doesn't decrease the token total supply.\n   *\n   * Requirements:\n   *\n   * - `_account` cannot be the zero address.\n   * - `_account` must hold at least `_sharesAmount` shares.\n   * - the contract must not be paused.\n   */\n  function _burnShares(\n    address _account,\n    uint256 _sharesAmount\n  ) internal whenNotPaused returns (uint256) {\n    require(_account != address(0), \"BURN_FROM_THE_ZERO_ADDRESS\");\n\n    _beforeTokenTransfer(_account, address(0), _sharesAmount);\n\n    uint256 accountShares = shares[_account];\n    require(_sharesAmount <= accountShares, \"BURN_AMOUNT_EXCEEDS_BALANCE\");\n\n    uint256 preRebaseTokenAmount = getPooledCashByShares(_sharesAmount);\n\n    totalShares -= _sharesAmount;\n\n    shares[_account] = accountShares - _sharesAmount;\n\n    uint256 postRebaseTokenAmount = getPooledCashByShares(_sharesAmount);\n\n    emit SharesBurnt(\n      _account,\n      preRebaseTokenAmount,\n      postRebaseTokenAmount,\n      _sharesAmount\n    );\n\n    return totalShares;\n\n    // Notice: we're not emitting a Transfer event to the zero address here since shares burn\n    // works by redistributing the amount of tokens corresponding to the burned shares between\n    // all other token holders. The total supply of the token doesn't change as the result.\n    // This is equivalent to performing a send from `address` to each other token holder address,\n    // but we cannot reflect this as it would require sending an unbounded number of events.\n\n    // We're emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * will be transferred to `to`.\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256\n  ) internal virtual {\n    if (from != _msgSender() && to != _msgSender()) {\n      require(\n        _getKYCStatus(_msgSender()),\n        \"OMMF: must be KYC'd to initiate transfer\"\n      );\n    }\n\n    if (from != address(0)) {\n      // Only check KYC if not minting\n      require(\n        _getKYCStatus(from),\n        \"OMMF: `from` address must be KYC'd to send tokens\"\n      );\n    }\n\n    if (to != address(0)) {\n      // Only check KYC if not burning\n      require(\n        _getKYCStatus(to),\n        \"OMMF: `to` address must be KYC'd to receive tokens\"\n      );\n    }\n  }\n\n  /**\n   * @notice Updates underlying cash in fund\n   * @dev periodically called by the Oracle contract\n   * @param _depositedCash Total cash in fund\n   */\n  function handleOracleReport(uint256 _depositedCash) external whenNotPaused {\n    require(msg.sender == oracle, \"OMMF: not oracle\");\n    depositedCash = _depositedCash;\n  }\n\n  /**\n   * @notice Sets the Oracle address\n   * @dev The new oracle can call `handleOracleReport` for rebases\n   * @param _oracle Address of the new oracle\n   */\n  function setOracle(address _oracle) external onlyRole(OMMF_MANAGER_ROLE) {\n    oracle = _oracle;\n  }\n\n  /**\n   * @notice Send funds to the pool\n   * @return Amount of OMMF shares generated\n   */\n  function mint(\n    address user,\n    uint256 depositAmount\n  ) external onlyRole(MINTER_ROLE) returns (uint256) {\n    require(depositAmount > 0, \"OMMF: zero deposit amount\");\n\n    uint256 sharesAmount = getSharesByPooledCash(depositAmount);\n    if (sharesAmount == 0) {\n      // totalControlledCash is 0: first-ever deposit\n      // assume that shares correspond to Cash 1-to-1\n      sharesAmount = depositAmount;\n    }\n\n    _mintShares(user, sharesAmount);\n\n    depositedCash += depositAmount;\n\n    _emitTransferAfterMintingShares(user, sharesAmount);\n    return sharesAmount;\n  }\n\n  /**\n   * @notice Admin burn function to burn OMMF tokens from any account\n   * @param _account The account to burn tokens from\n   * @param _amount  The amount of OMMF tokens to burn\n   */\n  function burn(\n    address _account,\n    uint256 _amount\n  ) external onlyRole(BURNER_ROLE) {\n    uint256 sharesAmount = getSharesByPooledCash(_amount);\n\n    _burnShares(_account, sharesAmount);\n    depositedCash -= _amount; // OMMF corresponds to deposited collateral 1:1\n\n    emit TokensBurnt(_account, _amount);\n  }\n\n  /**\n   * @notice Burns `_amount` of OMMF tokens from msg.sender's holdings\n   * @param _amount The amount of OMMF tokens to burn\n   */\n  function burn(uint256 _amount) external {\n    require(\n      getPooledCashByShares(_sharesOf(msg.sender)) >= _amount,\n      \"BURN_AMOUNT_EXCEEDS_BALANCE\"\n    );\n    uint256 sharesAmount = getSharesByPooledCash(_amount);\n    _burnShares(msg.sender, sharesAmount);\n    depositedCash -= _amount;\n\n    emit TokensBurnt(msg.sender, _amount);\n  }\n\n  /**\n   * @notice Burns `_amount` of OMMF tokens from `_account`'s holdings,\n   *         deducting from the caller's allowance\n   * @param _account Account to burn tokens from\n   * @param _amount  Amount of tokens to burn\n   * @dev Decrements shares as well as `depositedAmount`\n   */\n  function burnFrom(address _account, uint256 _amount) external {\n    uint256 currentAllowance = allowances[_account][msg.sender];\n    require(currentAllowance >= _amount, \"BURN_AMOUNT_EXCEEDS_ALLOWANCE\");\n\n    uint256 sharesAmount = getSharesByPooledCash(_amount);\n\n    _burnShares(_account, sharesAmount);\n    depositedCash -= _amount; // OMMF corresponds to deposited collateral 1:1\n\n    _approve(_account, msg.sender, currentAllowance - _amount);\n\n    emit TokensBurnt(_account, _amount);\n  }\n\n  /**\n   * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n   */\n  function _emitTransferAfterMintingShares(\n    address _to,\n    uint256 _sharesAmount\n  ) internal {\n    emit Transfer(address(0), _to, getPooledCashByShares(_sharesAmount));\n    emit TransferShares(address(0), _to, _sharesAmount);\n  }\n\n  function pause() external onlyRole(PAUSER_ROLE) {\n    _pause();\n  }\n\n  function unpause() external onlyRole(OMMF_MANAGER_ROLE) {\n    _unpause();\n  }\n\n  function setKYCRequirementGroup(\n    uint256 group\n  ) external override onlyRole(KYC_CONFIGURER_ROLE) {\n    _setKYCRequirementGroup(group);\n  }\n\n  function setKYCRegistry(\n    address registry\n  ) external override onlyRole(KYC_CONFIGURER_ROLE) {\n    _setKYCRegistry(registry);\n  }\n}\n"
    },
    "contracts/ommf/ommf_token/ommf_rebaseSetter.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/rwaOracles/IRWAOracle.sol\";\nimport \"contracts/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"contracts/ommf/ommf_token/ommf.sol\";\n\n/// @notice This contract is based on `RWAOracleRateCheck`, with minor updates\n///         to call into the OMMF token\ncontract OMMFRebaseSetter is AccessControlEnumerable {\n  // Underlying Cash of RWA\n  int256 public rwaUnderlying;\n\n  // Timestamp in which the RWA underlying was last set\n  uint256 public priceTimestamp;\n\n  // Minimum time between price updates\n  uint256 public constant MIN_PRICE_UPDATE_WINDOW = 23 hours;\n\n  // Helper constant that allows us to specify basis points in calculations\n  uint256 public constant BPS_DENOMINATOR = 10_000;\n\n  // 1%, for example, if RWA price is 100 on day 1, it can't be more than\n  // 101 or less than 99 on day 2\n  uint256 public constant MAX_CHANGE_DIFF_BPS = 100;\n\n  // Max uint256\n  uint256 internal constant MAX_UINT256 = 2 ** 256 - 1;\n\n  // Role that can set RWA price\n  bytes32 public constant SETTER_ROLE = keccak256(\"SETTER_ROLE\");\n\n  // OMMF token\n  OMMF public immutable ommf;\n\n  /**\n   * @notice Constructor\n   *\n   * @param admin        The address of the admin\n   * @param setter       The address of the setter\n   * @param _ommf        The address of the OMMF token\n   */\n  constructor(address admin, address setter, address _ommf) {\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    _grantRole(SETTER_ROLE, setter);\n\n    ommf = OMMF(_ommf);\n\n    rwaUnderlying = int256(ommf.getTotalPooledCash());\n    priceTimestamp = block.timestamp;\n\n    emit RWAUnderlyingSet(0, rwaUnderlying, block.timestamp);\n  }\n\n  /**\n   * @notice Retrieve the last set RWA underlying value\n   *\n   * @dev `price` is in 18 decimals, `timestamp` is unix seconds since epoch\n   */\n  function getPriceData() external view returns (uint256, uint256) {\n    return (uint256(rwaUnderlying), priceTimestamp);\n  }\n\n  /**\n   * @notice Set the RWA underlying value\n   *\n   * @param oldUnderlying The old RWA underlying value\n   * @param newUnderlying The new RWA underlying value\n   *\n   * @dev `MAX_CHANGE_DIFF_BPS` can be a positive or negative percent deviation\n   * @dev This function will fail when ommf underlying is initially 0\n   * @dev This function will fail if `oldUnderlying` doesn't match\n   *      `ommf.getTotalPooledCash()`\n   */\n  function setRWAUnderlying(\n    int256 oldUnderlying,\n    int256 newUnderlying\n  ) external onlyRole(SETTER_ROLE) {\n    if (newUnderlying <= 0) {\n      revert InvalidPrice();\n    }\n    if (block.timestamp - priceTimestamp < MIN_PRICE_UPDATE_WINDOW) {\n      revert PriceUpdateWindowViolation();\n    }\n\n    int256 underlyingCash = int256(ommf.getTotalPooledCash());\n\n    if (oldUnderlying != underlyingCash) {\n      revert OldUnderlyingMismatch();\n    }\n\n    // If there have been new deposits, the `underlyingCash` will be greater\n    // than `rwaUnderlying`, so we compare to `newUnderlying` to\n    // `underlyingCash`\n    if (\n      _getPriceChangeBps(underlyingCash, newUnderlying) > MAX_CHANGE_DIFF_BPS\n    ) {\n      revert DeltaDifferenceConstraintViolation();\n    }\n\n    // Set new price\n    int256 oldUnderlying = underlyingCash;\n    rwaUnderlying = newUnderlying;\n    priceTimestamp = block.timestamp;\n\n    // Set price in OMMF token\n    ommf.handleOracleReport(uint256(newUnderlying));\n\n    emit RWAUnderlyingSet(oldUnderlying, newUnderlying, block.timestamp);\n  }\n\n  /**\n   * @notice Compute the price change in basis point\n   *\n   * @param previousPrice Previous price\n   * @param newPrice      New price\n   *\n   * @dev The price change can be negative.\n   */\n  function _getPriceChangeBps(\n    int256 previousPrice,\n    int256 newPrice\n  ) private pure returns (uint256) {\n    uint256 change = newPrice > previousPrice\n      ? uint256(newPrice - previousPrice)\n      : uint256(previousPrice - newPrice);\n    uint256 changeBps = mulDivUp(\n      change,\n      BPS_DENOMINATOR,\n      uint256(previousPrice)\n    );\n    return changeBps;\n  }\n\n  /**\n   * @notice MulDivUp function forked from solmate's implementation\n   *\n   * @dev Forked from solmate's V6 release\n   */\n  function mulDivUp(\n    uint256 x,\n    uint256 y,\n    uint256 denominator\n  ) internal pure returns (uint256 z) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n      if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n        revert(0, 0)\n      }\n\n      // If x * y modulo the denominator is strictly greater than 0,\n      // 1 is added to round up the division of x * y by the denominator.\n      z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          Events & Errors\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Emitted when the RWA Underlying is set\n   *\n   * @param oldRwaUnderlying The old RWA underlying\n   * @param newRwaUnderlying The new RWA underlying\n   * @param timestamp        The timestamp at which the underlying was set\n   */\n  event RWAUnderlyingSet(\n    int256 oldRwaUnderlying,\n    int256 newRwaUnderlying,\n    uint256 timestamp\n  );\n\n  // Errors\n  error InvalidPrice();\n  error PriceUpdateWindowViolation();\n  error DeltaDifferenceConstraintViolation();\n  error OldUnderlyingMismatch();\n}\n"
    },
    "contracts/rwaOracles/IRWAOracle.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\ninterface IRWAOracle {\n  /// @notice Retrieve RWA price data\n  function getPriceData()\n    external\n    view\n    returns (uint256 price, uint256 timestamp);\n}\n"
    },
    "contracts/usdy/USDYPricer.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\n\npragma solidity 0.8.16;\n\nimport \"contracts/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"contracts/interfaces/IPricer.sol\";\n\ncontract USDYPricer is AccessControlEnumerable, IPricer {\n  // Struct representing information for a given priceId\n  struct PriceInfo {\n    uint256 price;\n    uint256 timestamp;\n  }\n  // Mapping from priceId to PriceInfo\n  mapping(uint256 => PriceInfo) public prices;\n\n  // Array of priceIds\n  /// @dev These priceIds are not ordered by timestamp\n  uint256[] public priceIds;\n\n  // Pointer to last set priceId\n  /// @dev This price may not be the latest price since prices can be added\n  /// out of order in relation to their timestamp\n  uint256 public currentPriceId;\n\n  // Pointer to priceId associated with the latest price\n  uint256 public latestPriceId;\n\n  bytes32 public constant PRICE_UPDATE_ROLE = keccak256(\"PRICE_UPDATE_ROLE\");\n\n  constructor(address admin, address pricer) {\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    _grantRole(PRICE_UPDATE_ROLE, pricer);\n  }\n\n  /**\n   * @notice Gets the latest price of the asset\n   *\n   * @return uint256 The latest price of the asset\n   */\n  function getLatestPrice() external view override returns (uint256) {\n    return prices[latestPriceId].price;\n  }\n\n  /**\n   * @notice Gets the latest price of the asset\n   *\n   * @return uint256 The price of the asset\n   */\n  function getPrice(uint256 priceId) external view override returns (uint256) {\n    return prices[priceId].price;\n  }\n\n  /**\n   * @notice Adds a price to the pricer\n   *\n   * @param price     The price to add\n   * @param timestamp The timestamp associated with the price\n   *\n   * @dev Updates the oracle price if price is the latest\n   */\n  function addPrice(\n    uint256 price,\n    uint256 timestamp\n  ) external override onlyRole(PRICE_UPDATE_ROLE) {\n    if (price == 0) {\n      revert InvalidPrice();\n    }\n\n    // Set price\n    uint256 priceId = ++currentPriceId;\n    prices[priceId] = PriceInfo(price, timestamp);\n    priceIds.push(priceId);\n\n    // Update latestPriceId\n    if (timestamp > prices[latestPriceId].timestamp) {\n      latestPriceId = priceId;\n    }\n\n    emit PriceAdded(priceId, price, timestamp);\n  }\n\n  /**\n   * @notice Updates a price in the pricer\n   *\n   * @param priceId The priceId to update\n   * @param price   The price to set\n   */\n  function updatePrice(\n    uint256 priceId,\n    uint256 price\n  ) external override onlyRole(PRICE_UPDATE_ROLE) {\n    if (price == 0) {\n      revert InvalidPrice();\n    }\n    if (prices[priceId].price == 0) {\n      revert PriceIdDoesNotExist();\n    }\n\n    PriceInfo memory oldPriceInfo = prices[priceId];\n    prices[priceId] = PriceInfo(price, oldPriceInfo.timestamp);\n\n    emit PriceUpdated(priceId, oldPriceInfo.price, price);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                           Events & Errors\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Emitted when a price is added\n   *\n   * @param priceId   The priceId associated with the price\n   * @param price     The price that was added\n   * @param timestamp The timestamp associated with the price\n   */\n  event PriceAdded(uint256 indexed priceId, uint256 price, uint256 timestamp);\n\n  /**\n   * @notice Emitted when a price is updated\n   *\n   * @param priceId  The priceId associated with the price to update\n   * @param oldPrice The old price associated with the priceId\n   * @param newPrice The price that was updated to\n   */\n  event PriceUpdated(\n    uint256 indexed priceId,\n    uint256 oldPrice,\n    uint256 newPrice\n  );\n\n  // Errors\n  error InvalidPrice();\n  error PriceIdDoesNotExist();\n}\n"
    },
    "contracts/interfaces/IPricer.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\ninterface IPricer {\n  /**\n   * @notice Gets the latest price of the asset\n   *\n   * @return uint256 The latest price of the asset\n   */\n  function getLatestPrice() external view returns (uint256);\n\n  /**\n   * @notice Gets the price of the asset at a specific priceId\n   *\n   * @param priceId The priceId at which to get the price\n   *\n   * @return uint256 The price of the asset with the given priceId\n   */\n  function getPrice(uint256 priceId) external view returns (uint256);\n\n  /**\n   * @notice Adds a price to the pricer\n   *\n   * @param price     The price to add\n   * @param timestamp The timestamp associated with the price\n   *\n   * @dev Updates the oracle price if price is the latest\n   */\n  function addPrice(uint256 price, uint256 timestamp) external;\n\n  /**\n   * @notice Updates a price in the pricer\n   *\n   * @param priceId The priceId to update\n   * @param price   The price to set\n   */\n  function updatePrice(uint256 priceId, uint256 price) external;\n}\n"
    },
    "contracts/interfaces/IPricerWithOracle.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IPricer.sol\";\n\ninterface IPricerWithOracle is IPricer {\n  /**\n   * @notice Updates a price in the pricer by pulling it from the oracle\n   */\n  function addLatestOraclePrice() external;\n}\n"
    },
    "contracts/PricerWithOracle.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\n\npragma solidity 0.8.16;\n\nimport \"contracts/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"contracts/interfaces/IPricerWithOracle.sol\";\nimport \"contracts/Pricer.sol\";\nimport \"contracts/rwaOracles/IRWAOracleSetter.sol\";\n\ncontract PricerWithOracle is\n  AccessControlEnumerable,\n  Pricer,\n  IPricerWithOracle\n{\n  // Pointer to rwaOracle\n  IRWAOracleSetter public immutable rwaOracle;\n\n  constructor(\n    address admin,\n    address pricer,\n    address _rwaOracle\n  ) Pricer(admin, pricer) {\n    rwaOracle = IRWAOracleSetter(_rwaOracle);\n\n    // Set initial priceId data\n    uint256 priceId = ++currentPriceId;\n    (uint256 latestOraclePrice, uint256 timestamp) = rwaOracle.getPriceData();\n    prices[priceId] = PriceInfo(latestOraclePrice, timestamp);\n    priceIds.push(priceId);\n    latestPriceId = priceId;\n    emit PriceAdded(priceId, latestOraclePrice, timestamp);\n  }\n\n  /**\n   * @notice Adds a price to the pricer\n   *\n   * @param price     The price to add\n   * @param timestamp The timestamp associated with the price\n   *\n   * @dev Updates the oracle price if price is the latest\n   */\n  function addPrice(\n    uint256 price,\n    uint256 timestamp\n  ) external override(Pricer, IPricer) onlyRole(PRICE_UPDATE_ROLE) {\n    if (price == 0) {\n      revert InvalidPrice();\n    }\n\n    // Set price\n    uint256 priceId = ++currentPriceId;\n    prices[priceId] = PriceInfo(price, timestamp);\n    priceIds.push(priceId);\n\n    // Update latestPriceId & Oracle Price\n    if (timestamp > prices[latestPriceId].timestamp) {\n      _updateOraclePrice(price, latestPriceId);\n      latestPriceId = priceId;\n    }\n\n    emit PriceAdded(priceId, price, timestamp);\n  }\n\n  /**\n   * @notice Adds a price in the pricer to match the oracle price\n   *\n   * @dev This function can be used to \"catch-up\" the Pricer with the oracle\n   *      price if the latest oracle price was not set through the Pricer\n   */\n  function addLatestOraclePrice() external onlyRole(PRICE_UPDATE_ROLE) {\n    (uint256 latestOraclePrice, uint256 latestOraclePriceTimestamp) = rwaOracle\n      .getPriceData();\n\n    PriceInfo memory latestPriceInfo = prices[latestPriceId];\n    if (\n      latestPriceInfo.price == latestOraclePrice &&\n      latestPriceInfo.timestamp == latestOraclePriceTimestamp\n    ) {\n      revert PricesAlreadyMatch();\n    }\n\n    // Set price\n    uint256 priceId = ++currentPriceId;\n    prices[priceId] = PriceInfo(latestOraclePrice, latestOraclePriceTimestamp);\n    priceIds.push(priceId);\n\n    // Update latestPriceId. latestPriceInfo.timestamp is always\n    // <= latestOraclePriceTimestamp, so we can skip a check\n    latestPriceId = priceId;\n\n    emit PriceAdded(priceId, latestOraclePrice, latestOraclePriceTimestamp);\n  }\n\n  /**\n   * @notice Updates the RWA oracle price\n   *\n   * @param price         The price to set in the oracle\n   * @param _latestPriceId The priceId associated with the latest price\n   */\n  function _updateOraclePrice(uint256 price, uint256 _latestPriceId) internal {\n    (uint256 latestOraclePrice, ) = rwaOracle.getPriceData();\n    if (prices[_latestPriceId].price != latestOraclePrice) {\n      revert LatestPriceMismatch();\n    }\n    rwaOracle.setPrice(int256(price));\n  }\n\n  // Errors\n  error LatestPriceMismatch();\n  error PricesAlreadyMatch();\n}\n"
    },
    "contracts/Pricer.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\n\npragma solidity 0.8.16;\n\nimport \"contracts/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"contracts/interfaces/IPricer.sol\";\n\ncontract Pricer is AccessControlEnumerable, IPricer {\n  // Struct representing information for a given priceId\n  struct PriceInfo {\n    uint256 price;\n    uint256 timestamp;\n  }\n  // Mapping from priceId to PriceInfo\n  mapping(uint256 => PriceInfo) public prices;\n\n  // Array of priceIds\n  /// @dev These priceIds are not ordered by timestamp\n  uint256[] public priceIds;\n\n  // Pointer to last set priceId\n  /// @dev This price may not be the latest price since prices can be added\n  /// out of order in relation to their timestamp\n  uint256 public currentPriceId;\n\n  // Pointer to priceId associated with the latest price\n  uint256 public latestPriceId;\n\n  bytes32 public constant PRICE_UPDATE_ROLE = keccak256(\"PRICE_UPDATE_ROLE\");\n\n  constructor(address admin, address pricer) {\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    _grantRole(PRICE_UPDATE_ROLE, pricer);\n  }\n\n  /**\n   * @notice Gets the latest price of the asset\n   *\n   * @return uint256 The latest price of the asset\n   */\n  function getLatestPrice() external view override returns (uint256) {\n    return prices[latestPriceId].price;\n  }\n\n  /**\n   * @notice Gets the latest price of the asset\n   *\n   * @return uint256 The price of the asset\n   */\n  function getPrice(uint256 priceId) external view override returns (uint256) {\n    return prices[priceId].price;\n  }\n\n  /**\n   * @notice Adds a price to the pricer\n   *\n   * @param price     The price to add\n   * @param timestamp The timestamp associated with the price\n   */\n  function addPrice(\n    uint256 price,\n    uint256 timestamp\n  ) external virtual override onlyRole(PRICE_UPDATE_ROLE) {\n    if (price == 0) {\n      revert InvalidPrice();\n    }\n\n    // Set price\n    uint256 priceId = ++currentPriceId;\n    prices[priceId] = PriceInfo(price, timestamp);\n    priceIds.push(priceId);\n\n    // Update latestPriceId\n    if (timestamp > prices[latestPriceId].timestamp) {\n      latestPriceId = priceId;\n    }\n\n    emit PriceAdded(priceId, price, timestamp);\n  }\n\n  /**\n   * @notice Updates a price in the pricer\n   *\n   * @param priceId The priceId to update\n   * @param price   The price to set\n   */\n  function updatePrice(\n    uint256 priceId,\n    uint256 price\n  ) external override onlyRole(PRICE_UPDATE_ROLE) {\n    if (price == 0) {\n      revert InvalidPrice();\n    }\n    if (prices[priceId].price == 0) {\n      revert PriceIdDoesNotExist();\n    }\n\n    PriceInfo memory oldPriceInfo = prices[priceId];\n    prices[priceId] = PriceInfo(price, oldPriceInfo.timestamp);\n\n    emit PriceUpdated(priceId, oldPriceInfo.price, price);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                           Events & Errors\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Emitted when a price is added\n   *\n   * @param priceId   The priceId associated with the price\n   * @param price     The price that was added\n   * @param timestamp The timestamp associated with the price\n   */\n  event PriceAdded(uint256 indexed priceId, uint256 price, uint256 timestamp);\n\n  /**\n   * @notice Emitted when a price is updated\n   *\n   * @param priceId  The priceId associated with the price to update\n   * @param oldPrice The old price associated with the priceId\n   * @param newPrice The price that was updated to\n   */\n  event PriceUpdated(\n    uint256 indexed priceId,\n    uint256 oldPrice,\n    uint256 newPrice\n  );\n\n  // Errors\n  error InvalidPrice();\n  error PriceIdDoesNotExist();\n}\n"
    },
    "contracts/rwaOracles/IRWAOracleSetter.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\ninterface IRWAOracleSetter {\n  /// @notice Retrieve RWA price data\n  function getPriceData()\n    external\n    view\n    returns (uint256 price, uint256 timestamp);\n\n  /// @notice Set the RWA price\n  function setPrice(int256 price) external;\n}\n"
    },
    "contracts/rwaOracles/RWAOracleRateCheck.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/rwaOracles/IRWAOracle.sol\";\nimport \"contracts/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\n\ncontract RWAOracleRateCheck is IRWAOracle, AccessControlEnumerable {\n  // Price of RWA token (OUSG, OSTB, OHYG, etc.)\n  int256 public rwaPrice;\n\n  // Timestamp in which the RWA token price was last set\n  uint256 public priceTimestamp;\n\n  // Minimum time between price updates\n  uint256 public constant MIN_PRICE_UPDATE_WINDOW = 23 hours;\n\n  // Helper constant that allows us to specify basis points in calculations\n  uint256 public constant BPS_DENOMINATOR = 10_000;\n\n  // 1%, for example, if RWA price is 100 on day 1, it can't be more than\n  // 101 or less than 99 on day 2\n  uint256 public constant MAX_CHANGE_DIFF_BPS = 100;\n\n  // Max uint256\n  uint256 internal constant MAX_UINT256 = 2 ** 256 - 1;\n\n  // Role that can set RWA price\n  bytes32 public constant SETTER_ROLE = keccak256(\"SETTER_ROLE\");\n\n  /**\n   * @notice Constructor\n   *\n   * @param admin The address of the admin\n   * @param setter The address of the setter\n   * @param initialprice The initial price of RWA\n   */\n  constructor(address admin, address setter, int256 initialprice) {\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    _grantRole(SETTER_ROLE, setter);\n\n    if (initialprice <= 0) {\n      revert InvalidPrice();\n    }\n\n    rwaPrice = initialprice;\n    priceTimestamp = block.timestamp;\n\n    emit RWAPriceSet(0, initialprice, block.timestamp);\n  }\n\n  /**\n   * @notice Retrieve the last set RWA price data\n   *\n   * @dev `price` is in 18 decimals, `timestamp` is unix seconds since epoch\n   */\n  function getPriceData() external view override returns (uint256, uint256) {\n    return (uint256(rwaPrice), priceTimestamp);\n  }\n\n  /**\n   * @notice Set the RWA price\n   *\n   * @param newPrice The new RWA price\n   *\n   * @dev `MAX_CHANGE_DIFF_BPS` can be a positive or negative percent deviation\n   */\n  function setPrice(int256 newPrice) external onlyRole(SETTER_ROLE) {\n    if (newPrice <= 0) {\n      revert InvalidPrice();\n    }\n    if (block.timestamp - priceTimestamp < MIN_PRICE_UPDATE_WINDOW) {\n      revert PriceUpdateWindowViolation();\n    }\n    if (_getPriceChangeBps(rwaPrice, newPrice) > MAX_CHANGE_DIFF_BPS) {\n      revert DeltaDifferenceConstraintViolation();\n    }\n\n    // Set new price\n    int256 oldPrice = rwaPrice;\n    rwaPrice = newPrice;\n    priceTimestamp = block.timestamp;\n\n    emit RWAPriceSet(oldPrice, newPrice, block.timestamp);\n  }\n\n  /**\n   * @notice Compute the price change in basis point\n   *\n   * @param previousPrice Previous price\n   * @param newPrice      New price\n   *\n   * @dev The price change can be negative.\n   */\n  function _getPriceChangeBps(\n    int256 previousPrice,\n    int256 newPrice\n  ) private pure returns (uint256) {\n    uint256 change = newPrice > previousPrice\n      ? uint256(newPrice - previousPrice)\n      : uint256(previousPrice - newPrice);\n    uint256 changeBps = mulDivUp(\n      change,\n      BPS_DENOMINATOR,\n      uint256(previousPrice)\n    );\n    return changeBps;\n  }\n\n  /**\n   * @notice MulDivUp function forked from solmate's implementation\n   *\n   * @dev Forked from solmate's V6 release\n   */\n  function mulDivUp(\n    uint256 x,\n    uint256 y,\n    uint256 denominator\n  ) internal pure returns (uint256 z) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n      if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n        revert(0, 0)\n      }\n\n      // If x * y modulo the denominator is strictly greater than 0,\n      // 1 is added to round up the division of x * y by the denominator.\n      z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          Events & Errors\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Emitted when the RWA price is set\n   *\n   * @param oldPrice The old RWA price\n   * @param newPrice The new RWA price\n   * @param timestamp The timestamp at which the price was set\n   */\n  event RWAPriceSet(int256 oldPrice, int256 newPrice, uint256 timestamp);\n\n  // Errors\n  error InvalidPrice();\n  error PriceUpdateWindowViolation();\n  error DeltaDifferenceConstraintViolation();\n}\n"
    },
    "contracts/rwaOracles/IRWAOracleExternalComparisonCheck.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n */\npragma solidity 0.8.16;\n\nimport \"contracts/rwaOracles/IRWAOracle.sol\";\n\ninterface IRWAOracleExternalComparisonCheck is IRWAOracle {\n  /// @notice Set the RWA price\n  function setPrice(int256 newPrice) external;\n\n  /// EVENTS ///\n  /**\n   * @dev Event for when the price is set nominally\n   *\n   * @param oldChainlinkPrice Old Chainlink price\n   * @param oldRoundId        Chainlink round ID of old price\n   * @param newChainlinkPrice New Chainlink price\n   * @param newRoundId        Chainlink round ID of old price\n   * @param oldRWAPrice       Old RWA price\n   * @param newRWAPrice       New RWA price\n   */\n  event RWAExternalComparisonCheckPriceSet(\n    int256 oldChainlinkPrice,\n    uint80 indexed oldRoundId,\n    int256 newChainlinkPrice,\n    uint80 indexed newRoundId,\n    int256 oldRWAPrice,\n    int256 newRWAPrice\n  );\n\n  /**\n   * @dev Event for when the Chainlink price is out of reasonable bounds is\n   *      is ignored\n   *\n   * @param oldChainlinkPrice Old Chainlink price\n   * @param oldRoundId        Chainlink round ID of old price\n   * @param newChainlinkPrice New Chainlink price\n   * @param newRoundId        Chainlink round ID of old price\n   */\n  event ChainlinkPriceIgnored(\n    int256 oldChainlinkPrice,\n    uint80 indexed oldRoundId,\n    int256 newChainlinkPrice,\n    uint80 indexed newRoundId\n  );\n\n  /// ERRORS ///\n  error CorruptedChainlinkResponse();\n  error ChainlinkOraclePriceStale();\n  error DeltaDifferenceConstraintViolation();\n  error AbsoluteDifferenceConstraintViolated();\n  error PriceUpdateWindowViolation();\n  error InvalidRWAPrice();\n  error ChainlinkRoundNotUpdated();\n  error InvalidAddress();\n}\n"
    },
    "contracts/rwaOracles/RWAOracleExternalComparisonCheck.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\nimport \"contracts/external/chainlink/AggregatorV3Interface.sol\";\nimport \"contracts/rwaOracles/IRWAOracleExternalComparisonCheck.sol\";\nimport \"contracts/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\n\ncontract RWAOracleExternalComparisonCheck is\n  IRWAOracleExternalComparisonCheck,\n  AccessControlEnumerable\n{\n  /// @notice Helper struct for storing SHV data from Chainlink\n  struct ChainlinkRoundData {\n    uint80 roundId;\n    int256 answer;\n    uint256 startedAt;\n    uint256 updatedAt;\n    uint80 answeredInRound;\n  }\n\n  // Price of RWA token (OUSG, OSTB, OHYG, etc.)\n  int256 public rwaPrice;\n\n  // Timestamp in which the RWA token price was last set\n  uint256 public priceTimestamp;\n\n  // The associated Chainlink price update associated with the stored\n  // `rwaPrice`\n  ChainlinkRoundData public lastSetRound;\n\n  // Chainlink oracle whose tracked instrument is used to constrain price updates.\n  AggregatorV3Interface public immutable chainlinkOracle;\n\n  // Description of oracle set in Constructor\n  string public description;\n\n  // How recent a Chainlink update needs to be in order to be associated to\n  // a RWA price change.\n  uint256 public constant MAX_CL_WINDOW = 25 hours;\n\n  // Helper constant that allows us to specify basis points in calculations\n  int256 public constant BPS_DENOMINATOR = 10_000;\n\n  // Amount of bps that the RWA price can differ from the SHV change. For\n  // example, if SHV changes by 1% in between RWA price updates,\n  // RWA token can change between .26% and 1.74%\n  uint256 public constant MAX_CHANGE_DIFF_BPS = 74;\n\n  // Max amount of bps that RWA price in a single price update.\n  uint256 public constant MAX_ABSOLUTE_DIFF_BPS = 200;\n\n  // Minimum time between price updates\n  uint256 public constant MIN_PRICE_UPDATE_WINDOW = 23 hours;\n\n  /// @notice How many decimals `rwaPrice` is represented in\n  /// @dev UNUSED AND UNENFORCED - This is present only for operational\n  ///      clarity.\n  uint256 public constant decimals = 18;\n\n  // Role that can set RWA price\n  bytes32 public constant SETTER_ROLE = keccak256(\"SETTER_ROLE\");\n\n  /**\n   * @notice constructor\n   *\n   * @param _initialPrice     The initial RWA price\n   * @param _chainlinkOracle Chainlink oracle to compare differences with\n   * @param _description     Human readable description\n   * @param _admin           admin which holds the DEFAULT_ADMIN_ROLE\n   * @param _setter          setter address which holds the role to set rwa price\n   */\n  constructor(\n    int256 _initialPrice,\n    address _chainlinkOracle,\n    string memory _description,\n    address _admin,\n    address _setter\n  ) {\n    if (_admin == address(0) || _setter == address(0)) {\n      revert InvalidAddress();\n    }\n    chainlinkOracle = AggregatorV3Interface(_chainlinkOracle);\n    // Revert if Chainlink oracle is not reporting 8 decimals\n    if (chainlinkOracle.decimals() != 8) {\n      revert CorruptedChainlinkResponse();\n    }\n\n    ChainlinkRoundData memory round = _getLatestChainlinkRoundData();\n    if (block.timestamp > round.updatedAt + MAX_CL_WINDOW) {\n      revert ChainlinkOraclePriceStale();\n    }\n\n    description = _description;\n    rwaPrice = _initialPrice;\n    priceTimestamp = block.timestamp;\n    lastSetRound = round;\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    _grantRole(SETTER_ROLE, _setter);\n  }\n\n  /**\n   * @notice Retrieve the last set RWA price data\n   *\n   * @dev `price` is in 18 decimals, `timestamp` is unix seconds since epoch\n   */\n  function getPriceData()\n    external\n    view\n    override\n    returns (uint256 price, uint256 timestamp)\n  {\n    price = uint256(rwaPrice);\n    timestamp = priceTimestamp;\n  }\n\n  /**\n   * @notice Sets the price of RWA if all the following criteria are met:\n   *  - It is able to pull a consistent and recent Chainlink price that is\n   *    different than the last used Chainlink round\n   *  - The price wasn't updated too recently (`MIN_PRICE_UPDATE_WINDOW`\n   *    seconds)\n   *  - The change in RWA price is < MAX_ABSOLUTE_DIFF_BPS\n   *  - The change in RWA price has not deviated `MAX_CHANGE_DIFF_BPS` more\n   *    than the change in the Chainlink price.\n   * If the change in Chainlink price is larger than `MAX_ABSOLUTE_DIFF_BPS +\n   * MAX_CHANGE_DIFF_BPS` it is deemed malfunctioning and ignored.\n   *\n   * @param newPrice The new price of some RWA token (In `decimals` decimals)\n   *\n   * @dev The decimal representation is not enforced yet must be respected by\n   *      the caller of this function and deployer of this contract\n   */\n  function setPrice(int256 newPrice) external override onlyRole(SETTER_ROLE) {\n    // RWA price must be greater than zero\n    if (newPrice <= 0) {\n      revert InvalidRWAPrice();\n    }\n\n    ChainlinkRoundData memory round = _getLatestChainlinkRoundData();\n    // Chainlink price update must be recent\n    if (block.timestamp > round.updatedAt + MAX_CL_WINDOW) {\n      revert ChainlinkOraclePriceStale();\n    }\n\n    // Chainlink price update must not be comparing the same rounds against\n    // eachother\n    if (round.roundId == lastSetRound.roundId) {\n      revert ChainlinkRoundNotUpdated();\n    }\n\n    // Ensure at least `MIN_PRICE_UPDATE_WINDOW` seconds have passed since\n    // last RWA price update\n    if (block.timestamp < priceTimestamp + MIN_PRICE_UPDATE_WINDOW) {\n      revert PriceUpdateWindowViolation();\n    }\n\n    int256 rwaPriceChangeBps = _getPriceChangeBps(rwaPrice, newPrice);\n    // Never allow a price change that violates the max absolute change\n    // threshold.\n    if (_abs_unsigned(rwaPriceChangeBps) > MAX_ABSOLUTE_DIFF_BPS) {\n      revert AbsoluteDifferenceConstraintViolated();\n    }\n\n    int256 chainlinkPriceChangeBps = _getPriceChangeBps(\n      lastSetRound.answer,\n      round.answer\n    );\n\n    if (\n      _abs_unsigned(chainlinkPriceChangeBps) <=\n      MAX_ABSOLUTE_DIFF_BPS + MAX_CHANGE_DIFF_BPS\n    ) {\n      // Chainlink price change is sane, so we compare rwa price changes\n      // against the Chainlink price changes.\n      uint256 changeDifferenceBps = _abs_unsigned(\n        rwaPriceChangeBps - chainlinkPriceChangeBps\n      );\n\n      if (changeDifferenceBps > MAX_CHANGE_DIFF_BPS) {\n        revert DeltaDifferenceConstraintViolation();\n      }\n    } else {\n      emit ChainlinkPriceIgnored(\n        lastSetRound.answer,\n        lastSetRound.roundId,\n        round.answer,\n        round.roundId\n      );\n    }\n\n    emit RWAExternalComparisonCheckPriceSet(\n      lastSetRound.answer,\n      lastSetRound.roundId,\n      round.answer,\n      round.roundId,\n      rwaPrice,\n      newPrice\n    );\n\n    rwaPrice = newPrice;\n    priceTimestamp = block.timestamp;\n    lastSetRound = round;\n  }\n\n  /**\n   * @notice Retrieve latest Chainlink data\n   *\n   * @dev Reverts if any corruption is detected in Chainlink response\n   */\n  function _getLatestChainlinkRoundData()\n    private\n    view\n    returns (ChainlinkRoundData memory round)\n  {\n    (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    ) = chainlinkOracle.latestRoundData();\n    if (\n      answer < 0 ||\n      roundId != answeredInRound ||\n      roundId == 0 ||\n      updatedAt == 0 ||\n      updatedAt > block.timestamp\n    ) {\n      revert CorruptedChainlinkResponse();\n    }\n    round = ChainlinkRoundData(\n      roundId,\n      answer,\n      startedAt,\n      updatedAt,\n      answeredInRound\n    );\n  }\n\n  /**\n   * @notice Compute the price change in basis point\n   *\n   * @param previousPrice Previous price\n   * @param newPrice      New price\n   *\n   * @dev The price change can be negative.\n   */\n  function _getPriceChangeBps(\n    int256 previousPrice,\n    int256 newPrice\n  ) private pure returns (int256 changeBps) {\n    int256 change = newPrice - previousPrice;\n    changeBps = (change * BPS_DENOMINATOR) / previousPrice;\n  }\n\n  /**\n   * @notice returns the absolute value of the input.\n   *\n   * @param x the number to return absolute value of.\n   */\n  function _abs_unsigned(int256 x) private pure returns (uint256) {\n    return x >= 0 ? uint256(x) : uint256(-x);\n  }\n}\n"
    },
    "contracts/external/chainlink/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/kyc/KYCRegistry.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/kyc/IKYCRegistry.sol\";\nimport \"contracts/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"contracts/external/chainalysis/ISanctionsList.sol\";\nimport \"contracts/external/openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport \"contracts/external/openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n/**\n * @title KYCRegistry\n * @author Ondo Finance\n * @notice This contract manages KYC status for addresses that interact with\n *         Ondo products.\n */\ncontract KYCRegistry is AccessControlEnumerable, IKYCRegistry, EIP712 {\n  bytes32 public constant _APPROVAL_TYPEHASH =\n    keccak256(\n      \"KYCApproval(uint256 kycRequirementGroup,address user,uint256 deadline)\"\n    );\n  // Admin role that has permission to add/remove KYC related roles\n  bytes32 public constant REGISTRY_ADMIN = keccak256(\"REGISTRY_ADMIN\");\n\n  // {<KYCLevel> => {<user account address> => is user KYC approved}\n  mapping(uint256 => mapping(address => bool)) public kycState;\n\n  // Represents which roles msg.sender must have in order to change\n  // KYC state at that group.\n  /// @dev Default admin role of 0x00... will be able to set all group roles\n  ///      that are unset.\n  mapping(uint256 => bytes32) public kycGroupRoles;\n\n  // Chainalysis sanctions list\n  ISanctionsList public immutable sanctionsList;\n\n  /// @notice constructor\n  constructor(\n    address admin,\n    address _sanctionsList\n  ) EIP712(\"OndoKYCRegistry\", \"1\") {\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    _grantRole(REGISTRY_ADMIN, admin);\n    sanctionsList = ISanctionsList(_sanctionsList);\n  }\n\n  /**\n   * @notice Add a provided user to the registry at a specified\n   *         `kycRequirementGroup`. In order to sucessfully call this function,\n   *         An external caller must provide a signature signed by an address\n   *         with the role `kycGroupRoles[kycRequirementGroup]`.\n   *\n   * @param kycRequirementGroup KYC requirement group to modify `user`'s\n   *                            KYC status for\n   * @param user                User address to change KYC status for\n   * @param deadline            Deadline for which the signature-auth based\n   *                            operations with the signature become invalid\n   * @param v                   Recovery ID (See EIP 155)\n   * @param r                   Part of ECDSA signature representation\n   * @param s                   Part of ECDSA signature representation\n   *\n   * @dev Please note that ecrecover (which the Registry uses) requires V be\n   *      27 or 28, so a conversion must be applied before interacting with\n   *      `addKYCAddressViaSignature`\n   */\n  function addKYCAddressViaSignature(\n    uint256 kycRequirementGroup,\n    address user,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    require(v == 27 || v == 28, \"KYCRegistry: invalid v value in signature\");\n    require(\n      !kycState[kycRequirementGroup][user],\n      \"KYCRegistry: user already verified\"\n    );\n    require(block.timestamp <= deadline, \"KYCRegistry: signature expired\");\n    bytes32 structHash = keccak256(\n      abi.encode(_APPROVAL_TYPEHASH, kycRequirementGroup, user, deadline)\n    );\n    // https://eips.ethereum.org/EIPS/eip-712 compliant\n    bytes32 expectedMessage = _hashTypedDataV4(structHash);\n\n    // `ECDSA.recover` reverts if signer is address(0)\n    address signer = ECDSA.recover(expectedMessage, v, r, s);\n    _checkRole(kycGroupRoles[kycRequirementGroup], signer);\n\n    kycState[kycRequirementGroup][user] = true;\n\n    emit KYCAddressAddViaSignature(\n      msg.sender,\n      user,\n      signer,\n      kycRequirementGroup,\n      deadline\n    );\n  }\n\n  /// @notice Getter for EIP 712 Domain separator.\n  function DOMAIN_SEPARATOR() external view returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n\n  /**\n   * @notice Get KYC status of `account` for the provided\n   *         `kycRequirementGroup`. In order to return true, `account`'s state\n   *         in this contract must be true and additionally pass a\n   *         `sanctionsList` check.\n   *\n   * @param kycRequirementGroup KYC group to check KYC status for\n   * @param account             Addresses to check KYC status for\n   */\n  function getKYCStatus(\n    uint256 kycRequirementGroup,\n    address account\n  ) external view override returns (bool) {\n    return\n      kycState[kycRequirementGroup][account] &&\n      !sanctionsList.isSanctioned(account);\n  }\n\n  /**\n   * @notice Assigns a role to specified `kycRequirementGroup` to gate changes\n   *         to that group's KYC state\n   *\n   * @param kycRequirementGroup KYC group to set role for\n   * @param role                The role being assigned to a group\n   */\n  function assignRoletoKYCGroup(\n    uint256 kycRequirementGroup,\n    bytes32 role\n  ) external onlyRole(REGISTRY_ADMIN) {\n    kycGroupRoles[kycRequirementGroup] = role;\n    emit RoleAssignedToKYCGroup(kycRequirementGroup, role);\n  }\n\n  /**\n   * @notice Add addresses to KYC list for specified `kycRequirementGroup`\n   *\n   * @param kycRequirementGroup KYC group associated with `addresses`\n   * @param addresses           List of addresses to grant KYC'd status\n   */\n  function addKYCAddresses(\n    uint256 kycRequirementGroup,\n    address[] calldata addresses\n  ) external onlyRole(kycGroupRoles[kycRequirementGroup]) {\n    uint256 length = addresses.length;\n    for (uint256 i = 0; i < length; i++) {\n      kycState[kycRequirementGroup][addresses[i]] = true;\n    }\n    emit KYCAddressesAdded(msg.sender, kycRequirementGroup, addresses);\n  }\n\n  /**\n   * @notice Remove addresses from KYC list\n   *\n   * @param kycRequirementGroup KYC group associated with `addresses`\n   * @param addresses           List of addresses to revoke KYC'd status\n   */\n  function removeKYCAddresses(\n    uint256 kycRequirementGroup,\n    address[] calldata addresses\n  ) external onlyRole(kycGroupRoles[kycRequirementGroup]) {\n    uint256 length = addresses.length;\n    for (uint256 i = 0; i < length; i++) {\n      kycState[kycRequirementGroup][addresses[i]] = false;\n    }\n    emit KYCAddressesRemoved(msg.sender, kycRequirementGroup, addresses);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        Events\n  //////////////////////////////////////////////////////////////*/\n  /**\n   * @dev Event emitted when a role is assigned to a KYC group\n   *\n   * @param kycRequirementGroup The KYC group\n   * @param role                The role being assigned\n   */\n  event RoleAssignedToKYCGroup(\n    uint256 indexed kycRequirementGroup,\n    bytes32 indexed role\n  );\n\n  /**\n   * @dev Event emitted when addresses are added to KYC requirement group\n   *\n   * @param sender              Sender of the transaction\n   * @param kycRequirementGroup KYC requirement group being updated\n   * @param addresses           Array of addresses being added as elligible\n   */\n  event KYCAddressesAdded(\n    address indexed sender,\n    uint256 indexed kycRequirementGroup,\n    address[] addresses\n  );\n\n  /**\n   * @dev Event emitted when a user is added to the KYCRegistry\n   *      by an external caller through signature-auth\n   *\n   * @param sender              Sender of the transaction\n   * @param user                User being added to registry\n   * @param signer              Digest signer\n   * @param kycRequirementGroup KYC requirement group being updated\n   * @param deadline            Expiration constraint on signature\n   */\n  event KYCAddressAddViaSignature(\n    address indexed sender,\n    address indexed user,\n    address indexed signer,\n    uint256 kycRequirementGroup,\n    uint256 deadline\n  );\n\n  /**\n   * @dev Event emitted when addresses are removed from KYC requirement group\n   *\n   * @param sender              Sender of the transaction\n   * @param kycRequirementGroup KYC requirement group being updated\n   * @param addresses           Array of addresses being added as elligible\n   */\n  event KYCAddressesRemoved(\n    address indexed sender,\n    uint256 indexed kycRequirementGroup,\n    address[] addresses\n  );\n}\n"
    },
    "contracts/external/openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "contracts/external/openzeppelin/contracts/token/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\nimport \"contracts/external/openzeppelin/contracts/token/IERC20Metadata.sol\";\nimport \"contracts/external/openzeppelin/contracts/utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n  mapping(address => uint256) private _balances;\n\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n\n  /**\n   * @dev Sets the values for {name} and {symbol}.\n   *\n   * The default value of {decimals} is 18. To select a different value for\n   * {decimals} you should overload it.\n   *\n   * All two of these values are immutable: they can only be set once during\n   * construction.\n   */\n  constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() public view virtual override returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public view virtual override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\n   * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n   *\n   * Tokens usually opt for a value of 18, imitating the relationship between\n   * Ether and Wei. This is the value {ERC20} uses, unless this function is\n   * overridden;\n   *\n   * NOTE: This information is only used for _display_ purposes: it in\n   * no way affects any of the arithmetic of the contract, including\n   * {IERC20-balanceOf} and {IERC20-transfer}.\n   */\n  function decimals() public view virtual override returns (uint8) {\n    return 18;\n  }\n\n  /**\n   * @dev See {IERC20-totalSupply}.\n   */\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {IERC20-balanceOf}.\n   */\n  function balanceOf(address account)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {IERC20-transfer}.\n   *\n   * Requirements:\n   *\n   * - `to` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(address to, uint256 amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    address owner = _msgSender();\n    _transfer(owner, to, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-allowance}.\n   */\n  function allowance(address owner, address spender)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {IERC20-approve}.\n   *\n   * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n   * `transferFrom`. This is semantically equivalent to an infinite approval.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint256 amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    address owner = _msgSender();\n    _approve(owner, spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-transferFrom}.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {ERC20}.\n   *\n   * NOTE: Does not update the allowance if the current allowance\n   * is the maximum `uint256`.\n   *\n   * Requirements:\n   *\n   * - `from` and `to` cannot be the zero address.\n   * - `from` must have a balance of at least `amount`.\n   * - the caller must have allowance for ``from``'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    address spender = _msgSender();\n    _spendAllowance(from, spender, amount);\n    _transfer(from, to, amount);\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(address spender, uint256 addedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    address owner = _msgSender();\n    _approve(owner, spender, _allowances[owner][spender] + addedValue);\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    address owner = _msgSender();\n    uint256 currentAllowance = _allowances[owner][spender];\n    require(\n      currentAllowance >= subtractedValue,\n      \"ERC20: decreased allowance below zero\"\n    );\n    unchecked {\n      _approve(owner, spender, currentAllowance - subtractedValue);\n    }\n\n    return true;\n  }\n\n  /**\n   * @dev Moves `amount` of tokens from `sender` to `recipient`.\n   *\n   * This internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `from` must have a balance of at least `amount`.\n   */\n  function _transfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {\n    require(from != address(0), \"ERC20: transfer from the zero address\");\n    require(to != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(from, to, amount);\n\n    uint256 fromBalance = _balances[from];\n    require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n    unchecked {\n      _balances[from] = fromBalance - amount;\n    }\n    _balances[to] += amount;\n\n    emit Transfer(from, to, amount);\n\n    _afterTokenTransfer(from, to, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   *\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   */\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply += amount;\n    _balances[account] += amount;\n    emit Transfer(address(0), account, amount);\n\n    _afterTokenTransfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * Emits a {Transfer} event with `to` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   * - `account` must have at least `amount` tokens.\n   */\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n    unchecked {\n      _balances[account] = accountBalance - amount;\n    }\n    _totalSupply -= amount;\n\n    emit Transfer(account, address(0), amount);\n\n    _afterTokenTransfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n   *\n   * This internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n   *\n   * Does not update the allowance amount in case of infinite allowance.\n   * Revert if not enough allowance is available.\n   *\n   * Might emit an {Approval} event.\n   */\n  function _spendAllowance(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    uint256 currentAllowance = allowance(owner, spender);\n    if (currentAllowance != type(uint256).max) {\n      require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n      unchecked {\n        _approve(owner, spender, currentAllowance - amount);\n      }\n    }\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * will be transferred to `to`.\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n\n  /**\n   * @dev Hook that is called after any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * has been transferred to `to`.\n   * - when `from` is zero, `amount` tokens have been minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _afterTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n}\n"
    },
    "contracts/external/openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n}"
    },
    "contracts/usdy/blocklist/Blocklist.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\nimport \"contracts/external/openzeppelin/contracts/access/Ownable2Step.sol\";\nimport \"contracts/interfaces/IBlocklist.sol\";\n\n/**\n * @title Blocklist\n * @author Ondo Finance\n * @notice This contract manages the blocklist status for accounts.\n */\ncontract Blocklist is Ownable2Step, IBlocklist {\n  constructor() {}\n\n  // {<address> => is account blocked}\n  mapping(address => bool) private blockedAddresses;\n\n  /**\n   * @notice Returns name of contract\n   */\n  function name() external pure returns (string memory) {\n    return \"Ondo Finance Blocklist Oracle\";\n  }\n\n  /**\n   * @notice Function to add a list of accounts to the blocklist\n   *\n   * @param accounts Array of addresses to block\n   */\n  function addToBlocklist(address[] calldata accounts) external onlyOwner {\n    for (uint256 i; i < accounts.length; ++i) {\n      blockedAddresses[accounts[i]] = true;\n    }\n    emit BlockedAddressesAdded(accounts);\n  }\n\n  /**\n   * @notice Function to remove a list of accounts from the blocklist\n   *\n   * @param accounts Array of addresses to unblock\n   */\n  function removeFromBlocklist(address[] calldata accounts) external onlyOwner {\n    for (uint256 i; i < accounts.length; ++i) {\n      blockedAddresses[accounts[i]] = false;\n    }\n    emit BlockedAddressesRemoved(accounts);\n  }\n\n  /**\n   * @notice Function to check if an account is blocked\n   *\n   * @param addr Address to check\n   *\n   * @return True if account is blocked, false otherwise\n   */\n  function isBlocked(address addr) external view returns (bool) {\n    return blockedAddresses[addr];\n  }\n}\n"
    },
    "contracts/usdy/allowlist/AllowlistClient.sol": {
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IAllowlist.sol\";\nimport \"contracts/interfaces/IAllowlistClient.sol\";\n\n/**\n * @title AllowlistClient\n * @author Ondo Finance\n * @notice This abstract contract manages state required for clients\n *         of the allowlist\n */\nabstract contract AllowlistClient is IAllowlistClient {\n  // allowlist address\n  IAllowlist public override allowlist;\n\n  /**\n   * @notice Constructor\n   *\n   * @param _allowlist Address of the blocklist contract\n   */\n  constructor(address _allowlist) {\n    _setAllowlist(_allowlist);\n  }\n\n  /**\n   * @notice Sets the allowlist address for this client\n   *\n   * @param _allowlist The new allowlist address\n   */\n  function _setAllowlist(address _allowlist) internal {\n    if (_allowlist == address(0)) {\n      revert AllowlistZeroAddress();\n    }\n    address oldAllowlist = address(allowlist);\n    allowlist = IAllowlist(_allowlist);\n    emit AllowlistSet(oldAllowlist, _allowlist);\n  }\n\n  /**\n   * @notice Checks whether an address has been Blocked\n   *\n   * @param account The account to check\n   */\n  function _isAllowed(address account) internal view returns (bool) {\n    return allowlist.isAllowed(account);\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n  /**\n   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n   */\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 indexed tokenId\n  );\n\n  /**\n   * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n   */\n  event Approval(\n    address indexed owner,\n    address indexed approved,\n    uint256 indexed tokenId\n  );\n\n  /**\n   * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n   */\n  event ApprovalForAll(\n    address indexed owner,\n    address indexed operator,\n    bool approved\n  );\n\n  /**\n   * @dev Returns the number of tokens in ``owner``'s account.\n   */\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  /**\n   * @dev Returns the owner of the `tokenId` token.\n   *\n   * Requirements:\n   *\n   * - `tokenId` must exist.\n   */\n  function ownerOf(uint256 tokenId) external view returns (address owner);\n\n  /**\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must exist and be owned by `from`.\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n   *\n   * Emits a {Transfer} event.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes calldata data\n  ) external;\n\n  /**\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must exist and be owned by `from`.\n   * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n   *\n   * Emits a {Transfer} event.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external;\n\n  /**\n   * @dev Transfers `tokenId` token from `from` to `to`.\n   *\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must be owned by `from`.\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external;\n\n  /**\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n   * The approval is cleared when the token is transferred.\n   *\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n   *\n   * Requirements:\n   *\n   * - The caller must own the token or be an approved operator.\n   * - `tokenId` must exist.\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address to, uint256 tokenId) external;\n\n  /**\n   * @dev Approve or remove `operator` as an operator for the caller.\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n   *\n   * Requirements:\n   *\n   * - The `operator` cannot be the caller.\n   *\n   * Emits an {ApprovalForAll} event.\n   */\n  function setApprovalForAll(address operator, bool _approved) external;\n\n  /**\n   * @dev Returns the account approved for `tokenId` token.\n   *\n   * Requirements:\n   *\n   * - `tokenId` must exist.\n   */\n  function getApproved(uint256 tokenId)\n    external\n    view\n    returns (address operator);\n\n  /**\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n   *\n   * See {setApprovalForAll}\n   */\n  function isApprovedForAll(address owner, address operator)\n    external\n    view\n    returns (bool);\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n  /**\n   * @dev Returns the token collection name.\n   */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the token collection symbol.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n   */\n  function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/IERC721MetadataUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/ERC165Upgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is\n  Initializable,\n  ContextUpgradeable,\n  ERC165Upgradeable,\n  IERC721Upgradeable,\n  IERC721MetadataUpgradeable\n{\n  using AddressUpgradeable for address;\n  using StringsUpgradeable for uint256;\n\n  // Token name\n  string private _name;\n\n  // Token symbol\n  string private _symbol;\n\n  // Mapping from token ID to owner address\n  mapping(uint256 => address) private _owners;\n\n  // Mapping owner address to token count\n  mapping(address => uint256) private _balances;\n\n  // Mapping from token ID to approved address\n  mapping(uint256 => address) private _tokenApprovals;\n\n  // Mapping from owner to operator approvals\n  mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n  /**\n   * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n   */\n  function __ERC721_init(string memory name_, string memory symbol_)\n    internal\n    onlyInitializing\n  {\n    __ERC721_init_unchained(name_, symbol_);\n  }\n\n  function __ERC721_init_unchained(string memory name_, string memory symbol_)\n    internal\n    onlyInitializing\n  {\n    _name = name_;\n    _symbol = symbol_;\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override(ERC165Upgradeable, IERC165Upgradeable)\n    returns (bool)\n  {\n    return\n      interfaceId == type(IERC721Upgradeable).interfaceId ||\n      interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev See {IERC721-balanceOf}.\n   */\n  function balanceOf(address owner)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n    return _balances[owner];\n  }\n\n  /**\n   * @dev See {IERC721-ownerOf}.\n   */\n  function ownerOf(uint256 tokenId)\n    public\n    view\n    virtual\n    override\n    returns (address)\n  {\n    address owner = _owners[tokenId];\n    require(owner != address(0), \"ERC721: invalid token ID\");\n    return owner;\n  }\n\n  /**\n   * @dev See {IERC721Metadata-name}.\n   */\n  function name() public view virtual override returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev See {IERC721Metadata-symbol}.\n   */\n  function symbol() public view virtual override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev See {IERC721Metadata-tokenURI}.\n   */\n  function tokenURI(uint256 tokenId)\n    public\n    view\n    virtual\n    override\n    returns (string memory)\n  {\n    _requireMinted(tokenId);\n\n    string memory baseURI = _baseURI();\n    return\n      bytes(baseURI).length > 0\n        ? string(abi.encodePacked(baseURI, tokenId.toString()))\n        : \"\";\n  }\n\n  /**\n   * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n   * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n   * by default, can be overridden in child contracts.\n   */\n  function _baseURI() internal view virtual returns (string memory) {\n    return \"\";\n  }\n\n  /**\n   * @dev See {IERC721-approve}.\n   */\n  function approve(address to, uint256 tokenId) public virtual override {\n    address owner = ERC721Upgradeable.ownerOf(tokenId);\n    require(to != owner, \"ERC721: approval to current owner\");\n\n    require(\n      _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n      \"ERC721: approve caller is not token owner nor approved for all\"\n    );\n\n    _approve(to, tokenId);\n  }\n\n  /**\n   * @dev See {IERC721-getApproved}.\n   */\n  function getApproved(uint256 tokenId)\n    public\n    view\n    virtual\n    override\n    returns (address)\n  {\n    _requireMinted(tokenId);\n\n    return _tokenApprovals[tokenId];\n  }\n\n  /**\n   * @dev See {IERC721-setApprovalForAll}.\n   */\n  function setApprovalForAll(address operator, bool approved)\n    public\n    virtual\n    override\n  {\n    _setApprovalForAll(_msgSender(), operator, approved);\n  }\n\n  /**\n   * @dev See {IERC721-isApprovedForAll}.\n   */\n  function isApprovedForAll(address owner, address operator)\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return _operatorApprovals[owner][operator];\n  }\n\n  /**\n   * @dev See {IERC721-transferFrom}.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) public virtual override {\n    //solhint-disable-next-line max-line-length\n    require(\n      _isApprovedOrOwner(_msgSender(), tokenId),\n      \"ERC721: caller is not token owner nor approved\"\n    );\n\n    _transfer(from, to, tokenId);\n  }\n\n  /**\n   * @dev See {IERC721-safeTransferFrom}.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) public virtual override {\n    safeTransferFrom(from, to, tokenId, \"\");\n  }\n\n  /**\n   * @dev See {IERC721-safeTransferFrom}.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory data\n  ) public virtual override {\n    require(\n      _isApprovedOrOwner(_msgSender(), tokenId),\n      \"ERC721: caller is not token owner nor approved\"\n    );\n    _safeTransfer(from, to, tokenId, data);\n  }\n\n  /**\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n   *\n   * `data` is additional data, it has no specified format and it is sent in call to `to`.\n   *\n   * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n   * implement alternative mechanisms to perform token transfer, such as signature-based.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must exist and be owned by `from`.\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n   *\n   * Emits a {Transfer} event.\n   */\n  function _safeTransfer(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory data\n  ) internal virtual {\n    _transfer(from, to, tokenId);\n    require(\n      _checkOnERC721Received(from, to, tokenId, data),\n      \"ERC721: transfer to non ERC721Receiver implementer\"\n    );\n  }\n\n  /**\n   * @dev Returns whether `tokenId` exists.\n   *\n   * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n   *\n   * Tokens start existing when they are minted (`_mint`),\n   * and stop existing when they are burned (`_burn`).\n   */\n  function _exists(uint256 tokenId) internal view virtual returns (bool) {\n    return _owners[tokenId] != address(0);\n  }\n\n  /**\n   * @dev Returns whether `spender` is allowed to manage `tokenId`.\n   *\n   * Requirements:\n   *\n   * - `tokenId` must exist.\n   */\n  function _isApprovedOrOwner(address spender, uint256 tokenId)\n    internal\n    view\n    virtual\n    returns (bool)\n  {\n    address owner = ERC721Upgradeable.ownerOf(tokenId);\n    return (spender == owner ||\n      isApprovedForAll(owner, spender) ||\n      getApproved(tokenId) == spender);\n  }\n\n  /**\n   * @dev Safely mints `tokenId` and transfers it to `to`.\n   *\n   * Requirements:\n   *\n   * - `tokenId` must not exist.\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n   *\n   * Emits a {Transfer} event.\n   */\n  function _safeMint(address to, uint256 tokenId) internal virtual {\n    _safeMint(to, tokenId, \"\");\n  }\n\n  /**\n   * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n   * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n   */\n  function _safeMint(\n    address to,\n    uint256 tokenId,\n    bytes memory data\n  ) internal virtual {\n    _mint(to, tokenId);\n    require(\n      _checkOnERC721Received(address(0), to, tokenId, data),\n      \"ERC721: transfer to non ERC721Receiver implementer\"\n    );\n  }\n\n  /**\n   * @dev Mints `tokenId` and transfers it to `to`.\n   *\n   * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n   *\n   * Requirements:\n   *\n   * - `tokenId` must not exist.\n   * - `to` cannot be the zero address.\n   *\n   * Emits a {Transfer} event.\n   */\n  function _mint(address to, uint256 tokenId) internal virtual {\n    require(to != address(0), \"ERC721: mint to the zero address\");\n    require(!_exists(tokenId), \"ERC721: token already minted\");\n\n    _beforeTokenTransfer(address(0), to, tokenId);\n\n    _balances[to] += 1;\n    _owners[tokenId] = to;\n\n    emit Transfer(address(0), to, tokenId);\n\n    _afterTokenTransfer(address(0), to, tokenId);\n  }\n\n  /**\n   * @dev Destroys `tokenId`.\n   * The approval is cleared when the token is burned.\n   *\n   * Requirements:\n   *\n   * - `tokenId` must exist.\n   *\n   * Emits a {Transfer} event.\n   */\n  function _burn(uint256 tokenId) internal virtual {\n    address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n    _beforeTokenTransfer(owner, address(0), tokenId);\n\n    // Clear approvals\n    _approve(address(0), tokenId);\n\n    _balances[owner] -= 1;\n    delete _owners[tokenId];\n\n    emit Transfer(owner, address(0), tokenId);\n\n    _afterTokenTransfer(owner, address(0), tokenId);\n  }\n\n  /**\n   * @dev Transfers `tokenId` from `from` to `to`.\n   *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n   *\n   * Requirements:\n   *\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must be owned by `from`.\n   *\n   * Emits a {Transfer} event.\n   */\n  function _transfer(\n    address from,\n    address to,\n    uint256 tokenId\n  ) internal virtual {\n    require(\n      ERC721Upgradeable.ownerOf(tokenId) == from,\n      \"ERC721: transfer from incorrect owner\"\n    );\n    require(to != address(0), \"ERC721: transfer to the zero address\");\n\n    _beforeTokenTransfer(from, to, tokenId);\n\n    // Clear approvals from the previous owner\n    _approve(address(0), tokenId);\n\n    _balances[from] -= 1;\n    _balances[to] += 1;\n    _owners[tokenId] = to;\n\n    emit Transfer(from, to, tokenId);\n\n    _afterTokenTransfer(from, to, tokenId);\n  }\n\n  /**\n   * @dev Approve `to` to operate on `tokenId`\n   *\n   * Emits an {Approval} event.\n   */\n  function _approve(address to, uint256 tokenId) internal virtual {\n    _tokenApprovals[tokenId] = to;\n    emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n  }\n\n  /**\n   * @dev Approve `operator` to operate on all of `owner` tokens\n   *\n   * Emits an {ApprovalForAll} event.\n   */\n  function _setApprovalForAll(\n    address owner,\n    address operator,\n    bool approved\n  ) internal virtual {\n    require(owner != operator, \"ERC721: approve to caller\");\n    _operatorApprovals[owner][operator] = approved;\n    emit ApprovalForAll(owner, operator, approved);\n  }\n\n  /**\n   * @dev Reverts if the `tokenId` has not been minted yet.\n   */\n  function _requireMinted(uint256 tokenId) internal view virtual {\n    require(_exists(tokenId), \"ERC721: invalid token ID\");\n  }\n\n  /**\n   * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n   * The call is not executed if the target address is not a contract.\n   *\n   * @param from address representing the previous owner of the given token ID\n   * @param to target address that will receive the tokens\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param data bytes optional data to send along with the call\n   * @return bool whether the call correctly returned the expected magic value\n   */\n  function _checkOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory data\n  ) private returns (bool) {\n    if (to.isContract()) {\n      try\n        IERC721ReceiverUpgradeable(to).onERC721Received(\n          _msgSender(),\n          from,\n          tokenId,\n          data\n        )\n      returns (bytes4 retval) {\n        return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n      } catch (bytes memory reason) {\n        if (reason.length == 0) {\n          revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n        } else {\n          /// @solidity memory-safe-assembly\n          assembly {\n            revert(add(32, reason), mload(reason))\n          }\n        }\n      }\n    } else {\n      return true;\n    }\n  }\n\n  /**\n   * @dev Hook that is called before any token transfer. This includes minting\n   * and burning.\n   *\n   * Calling conditions:\n   *\n   * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n   * transferred to `to`.\n   * - When `from` is zero, `tokenId` will be minted for `to`.\n   * - When `to` is zero, ``from``'s `tokenId` will be burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 tokenId\n  ) internal virtual {}\n\n  /**\n   * @dev Hook that is called after any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _afterTokenTransfer(\n    address from,\n    address to,\n    uint256 tokenId\n  ) internal virtual {}\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[44] private __gap;\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n  /**\n   * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n   * by `operator` from `from`, this function is called.\n   *\n   * It must return its Solidity selector to confirm the token transfer.\n   * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n   *\n   * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n   */\n  function onERC721Received(\n    address operator,\n    address from,\n    uint256 tokenId,\n    bytes calldata data\n  ) external returns (bytes4);\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/ERC721PresetMinterPauserAutoIdUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/presets/ERC721PresetMinterPauserAutoId.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/ERC721EnumerableUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/ERC721BurnableUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/ERC721PausableUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/CounterUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\n/**\n * @dev {ERC721} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *  - token ID and URI autogeneration\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n *\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\n */\ncontract ERC721PresetMinterPauserAutoIdUpgradeable is\n  Initializable,\n  ContextUpgradeable,\n  AccessControlEnumerableUpgradeable,\n  ERC721EnumerableUpgradeable,\n  ERC721BurnableUpgradeable,\n  ERC721PausableUpgradeable\n{\n  function initialize(\n    string memory name,\n    string memory symbol,\n    string memory baseTokenURI\n  ) public virtual initializer {\n    __ERC721PresetMinterPauserAutoId_init(name, symbol, baseTokenURI);\n  }\n\n  using CountersUpgradeable for CountersUpgradeable.Counter;\n\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n  CountersUpgradeable.Counter private _tokenIdTracker;\n\n  string private _baseTokenURI;\n\n  /**\n   * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n   * account that deploys the contract.\n   *\n   * Token URIs will be autogenerated based on `baseURI` and their token IDs.\n   * See {ERC721-tokenURI}.\n   */\n  function __ERC721PresetMinterPauserAutoId_init(\n    string memory name,\n    string memory symbol,\n    string memory baseTokenURI\n  ) internal onlyInitializing {\n    __ERC721_init_unchained(name, symbol);\n    __Pausable_init_unchained();\n    __ERC721PresetMinterPauserAutoId_init_unchained(name, symbol, baseTokenURI);\n  }\n\n  function __ERC721PresetMinterPauserAutoId_init_unchained(\n    string memory,\n    string memory,\n    string memory baseTokenURI\n  ) internal onlyInitializing {\n    _baseTokenURI = baseTokenURI;\n\n    _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n    _setupRole(MINTER_ROLE, _msgSender());\n    _setupRole(PAUSER_ROLE, _msgSender());\n  }\n\n  function _baseURI() internal view virtual override returns (string memory) {\n    return _baseTokenURI;\n  }\n\n  /**\n   * @dev Creates a new token for `to`. Its token ID will be automatically\n   * assigned (and available on the emitted {IERC721-Transfer} event), and the token\n   * URI autogenerated based on the base URI passed at construction.\n   *\n   * See {ERC721-_mint}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `MINTER_ROLE`.\n   */\n  function mint(address to) public virtual {\n    require(\n      hasRole(MINTER_ROLE, _msgSender()),\n      \"ERC721PresetMinterPauserAutoId: must have minter role to mint\"\n    );\n\n    // We cannot just use balanceOf to create the new tokenId because tokens\n    // can be burned (destroyed), so we need a separate counter.\n    _mint(to, _tokenIdTracker.current());\n    _tokenIdTracker.increment();\n  }\n\n  /**\n   * @dev Pauses all token transfers.\n   *\n   * See {ERC721Pausable} and {Pausable-_pause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `PAUSER_ROLE`.\n   */\n  function pause() public virtual {\n    require(\n      hasRole(PAUSER_ROLE, _msgSender()),\n      \"ERC721PresetMinterPauserAutoId: must have pauser role to pause\"\n    );\n    _pause();\n  }\n\n  /**\n   * @dev Unpauses all token transfers.\n   *\n   * See {ERC721Pausable} and {Pausable-_unpause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `PAUSER_ROLE`.\n   */\n  function unpause() public virtual {\n    require(\n      hasRole(PAUSER_ROLE, _msgSender()),\n      \"ERC721PresetMinterPauserAutoId: must have pauser role to unpause\"\n    );\n    _unpause();\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 tokenId\n  )\n    internal\n    virtual\n    override(\n      ERC721Upgradeable,\n      ERC721EnumerableUpgradeable,\n      ERC721PausableUpgradeable\n    )\n  {\n    super._beforeTokenTransfer(from, to, tokenId);\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override(\n      AccessControlEnumerableUpgradeable,\n      ERC721Upgradeable,\n      ERC721EnumerableUpgradeable\n    )\n    returns (bool)\n  {\n    return super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[48] private __gap;\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/ERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/IERC721EnumerableUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721EnumerableUpgradeable is\n  Initializable,\n  ERC721Upgradeable,\n  IERC721EnumerableUpgradeable\n{\n  function __ERC721Enumerable_init() internal onlyInitializing {}\n\n  function __ERC721Enumerable_init_unchained() internal onlyInitializing {}\n\n  // Mapping from owner to list of owned token IDs\n  mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n  // Mapping from token ID to index of the owner tokens list\n  mapping(uint256 => uint256) private _ownedTokensIndex;\n\n  // Array with all token ids, used for enumeration\n  uint256[] private _allTokens;\n\n  // Mapping from token id to position in the allTokens array\n  mapping(uint256 => uint256) private _allTokensIndex;\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override(IERC165Upgradeable, ERC721Upgradeable)\n    returns (bool)\n  {\n    return\n      interfaceId == type(IERC721EnumerableUpgradeable).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n   */\n  function tokenOfOwnerByIndex(address owner, uint256 index)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    require(\n      index < ERC721Upgradeable.balanceOf(owner),\n      \"ERC721Enumerable: owner index out of bounds\"\n    );\n    return _ownedTokens[owner][index];\n  }\n\n  /**\n   * @dev See {IERC721Enumerable-totalSupply}.\n   */\n  function totalSupply() public view virtual override returns (uint256) {\n    return _allTokens.length;\n  }\n\n  /**\n   * @dev See {IERC721Enumerable-tokenByIndex}.\n   */\n  function tokenByIndex(uint256 index)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    require(\n      index < ERC721EnumerableUpgradeable.totalSupply(),\n      \"ERC721Enumerable: global index out of bounds\"\n    );\n    return _allTokens[index];\n  }\n\n  /**\n   * @dev Hook that is called before any token transfer. This includes minting\n   * and burning.\n   *\n   * Calling conditions:\n   *\n   * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n   * transferred to `to`.\n   * - When `from` is zero, `tokenId` will be minted for `to`.\n   * - When `to` is zero, ``from``'s `tokenId` will be burned.\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 tokenId\n  ) internal virtual override {\n    super._beforeTokenTransfer(from, to, tokenId);\n\n    if (from == address(0)) {\n      _addTokenToAllTokensEnumeration(tokenId);\n    } else if (from != to) {\n      _removeTokenFromOwnerEnumeration(from, tokenId);\n    }\n    if (to == address(0)) {\n      _removeTokenFromAllTokensEnumeration(tokenId);\n    } else if (to != from) {\n      _addTokenToOwnerEnumeration(to, tokenId);\n    }\n  }\n\n  /**\n   * @dev Private function to add a token to this extension's ownership-tracking data structures.\n   * @param to address representing the new owner of the given token ID\n   * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n   */\n  function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n    uint256 length = ERC721Upgradeable.balanceOf(to);\n    _ownedTokens[to][length] = tokenId;\n    _ownedTokensIndex[tokenId] = length;\n  }\n\n  /**\n   * @dev Private function to add a token to this extension's token tracking data structures.\n   * @param tokenId uint256 ID of the token to be added to the tokens list\n   */\n  function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n    _allTokensIndex[tokenId] = _allTokens.length;\n    _allTokens.push(tokenId);\n  }\n\n  /**\n   * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n   * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n   * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n   * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n   * @param from address representing the previous owner of the given token ID\n   * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n   */\n  function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId)\n    private\n  {\n    // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n    // then delete the last slot (swap and pop).\n\n    uint256 lastTokenIndex = ERC721Upgradeable.balanceOf(from) - 1;\n    uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n    // When the token to delete is the last token, the swap operation is unnecessary\n    if (tokenIndex != lastTokenIndex) {\n      uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n      _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n      _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n    }\n\n    // This also deletes the contents at the last position of the array\n    delete _ownedTokensIndex[tokenId];\n    delete _ownedTokens[from][lastTokenIndex];\n  }\n\n  /**\n   * @dev Private function to remove a token from this extension's token tracking data structures.\n   * This has O(1) time complexity, but alters the order of the _allTokens array.\n   * @param tokenId uint256 ID of the token to be removed from the tokens list\n   */\n  function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n    // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n    // then delete the last slot (swap and pop).\n\n    uint256 lastTokenIndex = _allTokens.length - 1;\n    uint256 tokenIndex = _allTokensIndex[tokenId];\n\n    // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n    // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n    // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n    uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n    _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n    _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n    // This also deletes the contents at the last position of the array\n    delete _allTokensIndex[tokenId];\n    _allTokens.pop();\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[46] private __gap;\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/ERC721BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be burned (destroyed).\n */\nabstract contract ERC721BurnableUpgradeable is\n  Initializable,\n  ContextUpgradeable,\n  ERC721Upgradeable\n{\n  function __ERC721Burnable_init() internal onlyInitializing {}\n\n  function __ERC721Burnable_init_unchained() internal onlyInitializing {}\n\n  /**\n   * @dev Burns `tokenId`. See {ERC721-_burn}.\n   *\n   * Requirements:\n   *\n   * - The caller must own `tokenId` or be an approved operator.\n   */\n  function burn(uint256 tokenId) public virtual {\n    //solhint-disable-next-line max-line-length\n    require(\n      _isApprovedOrOwner(_msgSender(), tokenId),\n      \"ERC721: caller is not token owner nor approved\"\n    );\n    _burn(tokenId);\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/ERC721PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"contracts/external/openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\n/**\n * @dev ERC721 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC721PausableUpgradeable is\n  Initializable,\n  ERC721Upgradeable,\n  PausableUpgradeable\n{\n  function __ERC721Pausable_init() internal onlyInitializing {\n    __Pausable_init_unchained();\n  }\n\n  function __ERC721Pausable_init_unchained() internal onlyInitializing {}\n\n  /**\n   * @dev See {ERC721-_beforeTokenTransfer}.\n   *\n   * Requirements:\n   *\n   * - the contract must not be paused.\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 tokenId\n  ) internal virtual override {\n    super._beforeTokenTransfer(from, to, tokenId);\n\n    require(!paused(), \"ERC721Pausable: token transfer while paused\");\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/utils/CounterUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n  struct Counter {\n    // This variable should never be directly accessed by users of the library: interactions must be restricted to\n    // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n    // this feature: see https://github.com/ethereum/solidity/issues/4637\n    uint256 _value; // default: 0\n  }\n\n  function current(Counter storage counter) internal view returns (uint256) {\n    return counter._value;\n  }\n\n  function increment(Counter storage counter) internal {\n    unchecked {\n      counter._value += 1;\n    }\n  }\n\n  function decrement(Counter storage counter) internal {\n    uint256 value = counter._value;\n    require(value > 0, \"Counter: decrement overflow\");\n    unchecked {\n      counter._value = value - 1;\n    }\n  }\n\n  function reset(Counter storage counter) internal {\n    counter._value = 0;\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\n  /**\n   * @dev Returns the total amount of tokens stored by the contract.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n   * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n   */\n  function tokenOfOwnerByIndex(address owner, uint256 index)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n   * Use along with {totalSupply} to enumerate all tokens.\n   */\n  function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "contracts/external/openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts/utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n  /**\n   * @dev Emitted when the pause is triggered by `account`.\n   */\n  event Paused(address account);\n\n  /**\n   * @dev Emitted when the pause is lifted by `account`.\n   */\n  event Unpaused(address account);\n\n  bool private _paused;\n\n  /**\n   * @dev Initializes the contract in unpaused state.\n   */\n  constructor() {\n    _paused = false;\n  }\n\n  /**\n   * @dev Returns true if the contract is paused, and false otherwise.\n   */\n  function paused() public view virtual returns (bool) {\n    return _paused;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   *\n   * Requirements:\n   *\n   * - The contract must not be paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused(), \"Pausable: paused\");\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   *\n   * Requirements:\n   *\n   * - The contract must be paused.\n   */\n  modifier whenPaused() {\n    require(paused(), \"Pausable: not paused\");\n    _;\n  }\n\n  /**\n   * @dev Triggers stopped state.\n   *\n   * Requirements:\n   *\n   * - The contract must not be paused.\n   */\n  function _pause() internal virtual whenNotPaused {\n    _paused = true;\n    emit Paused(_msgSender());\n  }\n\n  /**\n   * @dev Returns to normal state.\n   *\n   * Requirements:\n   *\n   * - The contract must be paused.\n   */\n  function _unpause() internal virtual whenPaused {\n    _paused = false;\n    emit Unpaused(_msgSender());\n  }\n}\n"
    },
    "contracts/external/openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n  struct Counter {\n    // This variable should never be directly accessed by users of the library: interactions must be restricted to\n    // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n    // this feature: see https://github.com/ethereum/solidity/issues/4637\n    uint256 _value; // default: 0\n  }\n\n  function current(Counter storage counter) internal view returns (uint256) {\n    return counter._value;\n  }\n\n  function increment(Counter storage counter) internal {\n    unchecked {\n      counter._value += 1;\n    }\n  }\n\n  function decrement(Counter storage counter) internal {\n    uint256 value = counter._value;\n    require(value > 0, \"Counter: decrement overflow\");\n    unchecked {\n      counter._value = value - 1;\n    }\n  }\n\n  function reset(Counter storage counter) internal {\n    counter._value = 0;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}